<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Google Docs</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
/* ================= existing styles (unchanged) ================= */
body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #0a0e27;
    color: #e0e0e0;
    position: relative;
    overflow-x: hidden;
}

/* Visitor Counter Top Bar */
#visitorCounter {
    width: 100%; 
    text-align: center; 
    background: #050812;
    padding: 6px 0; 
    font-size: 13px; 
    color: #00ff88; 
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    position: relative;
    z-index: 1000;
    font-weight: 500;
    border-bottom: 1px solid rgba(0, 255, 136, 0.2);
}

/* Header */
header {
    background: linear-gradient(90deg, #0f0f1e, #1a1a2e);
    color: #00ffff;
    padding: 24px 20px;
    text-align: center;
    font-size: 28px;
    font-weight: 700;
    border-bottom: 2px solid #00ffff;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.2), inset 0 0 20px rgba(0, 255, 255, 0.05);
    border-radius: 0;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

header .headerText { line-height: 1.4; text-align: center; }
header small { font-size:16px; font-weight:normal; display:block; margin-top:4px; color:#00ff88; text-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }

#replayTutorialBtn {
    position:absolute; top:15px; right:15px; width:35px; height:35px;
    font-weight:bold; font-size:16px; border-radius: 2px; border: 2px solid #00ffff;
    background: rgba(0, 255, 255, 0.1); cursor:pointer;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.4); transition: all 0.3s ease;
    color: #00ffff;
}
#replayTutorialBtn:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }

/* Controls */
.controls {
    background: #0f0f1e; padding: 16px; display:flex; flex-wrap:wrap;
    justify-content:center; gap:10px; border-bottom: 1px solid #00ffff;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
}
.controls button {
    padding: 10px 18px; border: 2px solid; color:white; cursor:pointer;
    border-radius: 2px; font-size: 13px; display:flex; align-items:center; gap:8px;
    transition: all 0.15s ease;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    position: relative;
    overflow: hidden;
}
.controls button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    transition: left 0.15s ease;
    z-index: -1;
}
.controls button:hover::before { left: 0; }
.controls button:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 15px currentColor;
}
#reloadBtn { border-color: #00ccff; color: #00ccff; background: rgba(0, 204, 255, 0.1); }
#reloadBtn::before { background: rgba(0, 204, 255, 0.2); }
#reloadBtn:hover { background: rgba(0, 204, 255, 0.3); box-shadow: 0 0 20px rgba(0, 204, 255, 0.6); }

#fullscreenBtn { border-color: #ff00ff; color: #ff00ff; background: rgba(255, 0, 255, 0.1); }
#fullscreenBtn::before { background: rgba(255, 0, 255, 0.2); }
#fullscreenBtn:hover { background: rgba(255, 0, 255, 0.3); box-shadow: 0 0 20px rgba(255, 0, 255, 0.6); }

#zoomInBtn { border-color: #00ff88; color: #00ff88; background: rgba(0, 255, 136, 0.1); }
#zoomInBtn::before { background: rgba(0, 255, 136, 0.2); }
#zoomInBtn:hover { background: rgba(0, 255, 136, 0.3); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }

#zoomOutBtn { border-color: #00ff88; color: #00ff88; background: rgba(0, 255, 136, 0.1); }
#zoomOutBtn::before { background: rgba(0, 255, 136, 0.2); }
#zoomOutBtn:hover { background: rgba(0, 255, 136, 0.3); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }

#hideIframeBtn { border-color: #ffaa00; color: #ffaa00; background: rgba(255, 170, 0, 0.1); }
#hideIframeBtn::before { background: rgba(255, 170, 0, 0.2); }
#hideIframeBtn:hover { background: rgba(255, 170, 0, 0.3); box-shadow: 0 0 20px rgba(255, 170, 0, 0.6); }

#showIframeBtn { border-color: #ffaa00; color: #ffaa00; background: rgba(255, 170, 0, 0.1); }
#showIframeBtn::before { background: rgba(255, 170, 0, 0.2); }
#showIframeBtn:hover { background: rgba(255, 170, 0, 0.3); box-shadow: 0 0 20px rgba(255, 170, 0, 0.6); }

#extraSiteBtn { border-color: #ff1493; color: #ff1493; background: rgba(255, 20, 147, 0.1); }
#extraSiteBtn::before { background: rgba(255, 20, 147, 0.2); }
#extraSiteBtn:hover { background: rgba(255, 20, 147, 0.3); box-shadow: 0 0 20px rgba(255, 20, 147, 0.6); }

#backBtn { border-color: #ff1493; color: #ff1493; background: rgba(255, 20, 147, 0.1); }
#backBtn::before { background: rgba(255, 20, 147, 0.2); }
#backBtn:hover { background: rgba(255, 20, 147, 0.3); box-shadow: 0 0 20px rgba(255, 20, 147, 0.6); }

#privacyBtn { border-color: #00ffaa; color: #00ffaa; background: rgba(0, 255, 170, 0.1); font-weight: 600; }
#privacyBtn::before { background: rgba(0, 255, 170, 0.2); }
#privacyBtn:hover { background: rgba(0, 255, 170, 0.3); box-shadow: 0 0 20px rgba(0, 255, 170, 0.6); }

#toggleChatBtn { border-color: #00ffff; color: #00ffff; background: rgba(0, 255, 255, 0.1); }
#toggleChatBtn::before { background: rgba(0, 255, 255, 0.2); }
#toggleChatBtn:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }

#openDrawingBtn { border-color: #ff00ff !important; color: #ff00ff !important; background: rgba(255, 0, 255, 0.1) !important; }
#openDrawingBtn::before { background: rgba(255, 0, 255, 0.2) !important; }
#openDrawingBtn:hover { background: rgba(255, 0, 255, 0.3) !important; box-shadow: 0 0 20px rgba(255, 0, 255, 0.6) !important; }

#clearCanvasBtn { border-color: #ff0000 !important; color: #ff0000 !important; background: rgba(255, 0, 0, 0.1) !important; }
#clearCanvasBtn:hover { background: rgba(255, 0, 0, 0.3) !important; box-shadow: 0 0 20px rgba(255, 0, 0, 0.6) !important; }

/* Iframe */
#iframeContainer { position: relative; }
#embeddedSite {
    width: 100%; height: calc(100vh - 140px); border: 2px solid #00ffff;
    border-radius: 0; box-sizing:border-box; transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.05);
}

/* Tutorial Bubble */
#tutorialOverlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.6); z-index:9999; display:none; }
.tutorialBubble {
    position: absolute; max-width:280px; background: rgba(15, 15, 30, 0.98); color:#00ffff;
    padding:18px 20px; border-radius: 2px; border: 1px solid #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    text-align:center; font-size:15px; opacity:0;
    transform: translate(-50%, -20px); transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
.tutorialBubble.show { opacity:1; transform: translate(-50%,0); }
.tutorialBubble button { margin-top:12px; padding:8px 14px; border: 1px solid #00ffff; background: rgba(0, 255, 255, 0.1); color:#00ffff; border-radius: 2px; cursor:pointer; font-weight: 600; }
.tutorialBubble button:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); transform:translateY(-2px); }

#tutorialArrow {
    position:absolute; width:0; height:0; border-left:12px solid transparent; border-right:12px solid transparent;
    border-bottom:18px solid rgba(15, 15, 30, 0.98); z-index:10000; transition: all 0.4s ease;
    filter: drop-shadow(0 4px 8px rgba(0, 255, 255, 0.3));
}

/* Cinematic Fullscreen Popup */
#fullscreenPopup {
    position: fixed; top:0; left:0; width:100%; height:100%; display:flex;
    justify-content:center; align-items:center; z-index:10001; opacity:0; pointer-events:none;
    background: linear-gradient(135deg, #0a0e27, #1a1a3e);
    flex-direction: column; color:#00ffff; text-align:center; overflow:hidden;
}
#fullscreenPopup.show { opacity:1; pointer-events:auto; animation: cinematicFade 1.5s ease forwards; }
#fullscreenPopup.show .popupContent {
    animation: cinematicScale 1.5s forwards ease-out;
}
#fullscreenPopup .popupContent {
    width: 100%; height: 100%; display:flex; justify-content:center; align-items:center; flex-direction:column;
    background: rgba(0,0,0,0.9); box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
    transform: scale(0.6); opacity:0;
}
#fullscreenPopup h1 { font-size:4vw; margin:0; text-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }
#fullscreenPopup p { font-size:1.5vw; margin-top:20px; }
#fullscreenPopup .extraSiteHighlight { font-weight:bold; color: #ff00ff; text-shadow: 0 0 10px rgba(255, 0, 255, 0.6); }
#fullscreenPopup .closeBtn {
    position:absolute; top:15px; right:15px; border: 2px solid #00ffff; background: rgba(0, 255, 255, 0.1);
    font-size:28px; cursor:pointer; color:#00ffff; transition: all 0.3s ease;
    width: 40px; height: 40px; border-radius: 2px;
}
#fullscreenPopup .closeBtn:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }

/* Cinematic Animations */
@keyframes cinematicFade { 0% { opacity:0; } 100% { opacity:1; } }
@keyframes cinematicScale { 0% { transform: scale(0.6) translateY(-100px); opacity:0; } 60% { transform: scale(1.05) translateY(20px); opacity:1; } 100% { transform: scale(1) translateY(0); opacity:1; } }

/* Sparkles */
#sparkleCanvas {
    position: absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    pointer-events: none; /* <<< add this */
}

/* Chat Box */
#chatContainer {
    position: fixed;
    bottom: 10px;
    right: 10px;
    width: 300px;
    max-height: 400px;
    overflow-y: auto;
    background: rgba(15, 15, 30, 0.95);
    padding: 10px;
    border-radius: 2px;
    border: 1px solid #00ffff;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    font-size: 14px;
    color: #e0e0e0;
}
#chatContainer input {
    width: calc(100% - 20px);
    margin-top: 10px;
    padding: 5px 8px;
    border-radius: 2px;
    border: 1px solid #00ffff;
    background: rgba(0, 255, 255, 0.05);
    color: #00ffff;
}
#chatContainer header {
    font-weight: bold;
    margin-bottom: 5px;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
    color: #00ffff;
}
#changeNameBtn {
    font-size: 12px;
    cursor: pointer;
    color: #00ff88;
}

/* ================= new drawing modal styles ================= */
#drawingModal {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  z-index: 20000;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 24px;
}
#drawingModal .modalInner {
  width: min(1100px, 96%);
  max-height: 92%;
  overflow: auto;
  border-radius: 2px;
  background: #0f0f1e;
  border: 1px solid #00ffff;
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
  padding: 12px;
  position: relative;
  color: #e0e0e0;
}
#drawingModal .closeDrawing {
  position: absolute;
  top: 10px; right: 10px;
  border: none; background: transparent; font-size: 20px; cursor: pointer;
  color: #00ffff;
}
#sharedCanvasContainer {
  width: 100%;
  background: rgba(20, 20, 40, 0.95);
  border-radius: 2px;
  padding:10px;
  box-sizing:border-box;
}
#canvasArea { border: 1px solid #00ffff; border-radius: 2px; overflow:hidden; background: #0a0a15; display:block; box-shadow: 0 0 15px rgba(0, 255, 255, 0.2); }
#sharedCanvas { width:100%; height:500px; display:block; background: #0a0a15; touch-action:none; }
#toggleCanvasBtn { padding: 8px 14px; border-radius: 2px; cursor:pointer; border: 1px solid #00ffff; background: rgba(0, 255, 255, 0.1); color: #00ffff; font-weight: 600; transition: all 0.15s ease; }
#toggleCanvasBtn:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); }

/* small responsive tweaks */
@media (max-width:700px) {
  #sharedCanvas { height:360px; }
  .controls { gap:8px; }
}
</style>
</head>
<body>
<!-- Cool Intro Loading Screen -->
<div id="introScreen">
  <div class="introParticles"></div>
  <div class="introContent">
    <div class="logoBounce">
      <img src="logoshs.png" alt="Logo" />
    </div>
    <div class="introText">Welcome to gooner gamesite</div>
    <div class="typingDots"><span></span><span></span><span></span></div>
  </div>
</div>

<style>
/* Fullscreen intro */
#introScreen {
    position: fixed;
    top:0; left:0;
    width:100%; height:100%;
    background: linear-gradient(135deg, #0a0e27, #1a1a3e, #0f0f1e);
    display:flex; justify-content:center; align-items:center;
    z-index:99999; overflow:hidden;
    flex-direction: column;
}

.introContent {
    text-align:center;
    color:white;
    font-family:'Segoe UI', sans-serif;
}

.logoBounce img {
    width:120px;
    animation: bounce 1.5s infinite;
    filter: drop-shadow(0 0 20px #fff);
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
}

.introText {
    font-size: 2rem;
    margin-top:15px;
    animation: fadeIn 2s ease-in-out forwards;
    opacity:0;
    text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ff88;
    color: #00ffff;
}

.typingDots {
    margin-top:15px;
    display:flex; justify-content:center; gap:8px;
}

.typingDots span {
    width:10px; height:10px; border-radius: 2px;
    background: #00ffff; opacity:0.3;
    animation: blink 1.5s infinite;
    box-shadow: 0 0 5px #00ffff;
}

.typingDots span:nth-child(1){ animation-delay:0s; }
.typingDots span:nth-child(2){ animation-delay:0.3s; }
.typingDots span:nth-child(3){ animation-delay:0.6s; }

@keyframes blink {
    0%, 80%, 100% { opacity:0.3; }
    40% { opacity:1; }
}

@keyframes fadeIn { 0% {opacity:0;} 100% {opacity:1;} }

/* Particle effect background */
.introParticles {
    position:absolute; top:0; left:0; width:100%; height:100%;
    pointer-events:none;
}
</style>

<div id="visitorCounter">Visitors Online: 0 | Total Visitors: 0</div>

<header>
    <div class="headerText">
        SHS - Gooner Gamesite <br>
        <small>SPS-devices Wi-Fi Password: 7&UI0)jk</small>
    </div>
    <button id="replayTutorialBtn" title="Replay Tutorial">T</button>
</header>

<div class="controls">
    <button id="reloadBtn"><i class="fas fa-redo"></i> Reload</button>
    <button id="fullscreenBtn"><i class="fas fa-expand"></i> Fullscreen</button>
    <button id="zoomInBtn"><i class="fas fa-search-plus"></i> Zoom In</button>
    <button id="zoomOutBtn"><i class="fas fa-search-minus"></i> Zoom Out</button>
    <button id="hideIframeBtn"><i class="fas fa-eye-slash"></i> Hide</button>
    <button id="showIframeBtn"><i class="fas fa-eye"></i> Show</button>
    <button id="extraSiteBtn"><i class="fas fa-gamepad"></i> Extra Site</button>
    <button id="privacyBtn"><i class="fas fa-shield-alt"></i> Browser</button>
    <!-- NEW Drawing button (opens modal overlay) -->
    <button id="openDrawingBtn" style="background:#6a5acd;"><i class="fas fa-paint-brush"></i> Global Drawing</button>
    <button id="toggleChatBtn" title="Toggle Chat">ðŸ’¬ global chat</button>
</div>

<div id="iframeContainer">
    <iframe id="embeddedSite" src="https://slopegame.online"></iframe>
</div>

<div id="tutorialOverlay">
    <div class="tutorialBubble" id="tutorialBubble">Tutorial text here
        <br><button id="nextTutorialBtn">Next</button>
    </div>
</div>
<div id="tutorialArrow" style="display:none;"></div>

<div id="fullscreenPopup">
    <div class="popupContent" id="popupContent">
        <button class="closeBtn">&times;</button>
        <h1>Welcome to the gooner gamesite</h1>
        <p>Access games, browse the web unblocked, and explore our interactive portal.<br>Close to get started.</p>
        <canvas id="sparkleCanvas"></canvas>
    </div>
</div>

<div id="chatContainer" style="display:none;">
    <header>
        Chat <span id="changeNameBtn" style="color:#000000;">Change Name/Color</span>
        <span id="typingIndicator" style="font-size:12px;color:#555;float:right;"></span>
    </header>
    <div id="chatMessages" style="max-height:300px; overflow-y:auto; padding:5px;"></div>
    <input type="text" id="chatInput" placeholder="Type a message...">
</div>



<div id="chatNameColorPopup" style="display:none; position:fixed; bottom:80px; right:10px; width:280px; background:#0f0f1e; padding:15px; border-radius: 2px; border: 1px solid #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); z-index:10000; color: #e0e0e0;">
    <label style="font-weight:bold; color: #00ffff;">Name:</label>
    <input type="text" id="chatPopupUsername" style="width:100%; padding:5px; margin-bottom:10px; border-radius: 2px; border: 1px solid #00ffff; background: rgba(0, 255, 255, 0.05); color: #00ffff;" placeholder="Enter name">

    <label style="font-weight:bold; color: #00ffff;">Color:</label>
    <input type="color" id="chatPopupColor" value="#007bff" style="width:100%; padding:5px; border-radius: 2px; border: 1px solid #00ffff;">

    <button id="chatSaveNameColor" style="margin-top:10px; width:100%; padding:8px; background: rgba(0, 255, 255, 0.1); color:#00ffff; border: 1px solid #00ffff; border-radius: 2px; cursor:pointer; font-weight: 600; transition: all 0.15s ease;">Save</button>
</div>


<!-- ================ NEW: drawing modal (hidden by default) ================ -->
<div id="drawingModal" aria-hidden="true">
  <div class="modalInner" role="dialog" aria-modal="true" aria-label="Shared Drawing Canvas">
    <button class="closeDrawing" id="closeDrawingBtn" title="Close Drawing">&times;</button>

    <!-- Shared Drawing Canvas UI (drop-in) -->
    <div id="sharedCanvasContainer" style="position:relative;">
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;">
        <button id="toggleCanvasBtn">Open/Close Canvas</button>
        <label style="display:flex;align-items:center;gap:6px;">
          <input id="colorPicker" type="color" value="#007bff">
        </label>
        <label style="display:flex;align-items:center;gap:6px;">
          <input id="sizeSlider" type="range" min="1" max="30" value="4">
          <small id="sizeLabel">4</small>
        </label>
        <button id="clearCanvasBtn" style="padding:6px 8px;border-radius:8px;background:#ff4b4b;color:white;">Clear</button>
        <div style="margin-left:auto; font-size:12px; color:#555;">Shared canvas (Realtime)</div>
      </div>

      <div id="canvasArea" style="position:relative;">
        <canvas id="sharedCanvas" width="800" height="500" style="display:block; touch-action:none;"></canvas>
        <canvas id="cursorOverlay" width="800" height="500" style="position:absolute; top:0; left:0; cursor:crosshair; background:transparent;"></canvas>
        <div style="padding:8px; font-size:12px; color:#777;">Draw and everyone currently connected will see it. Cursors show where others are drawing.</div>
      </div>
    </div>
    <!-- end shared UI -->
  </div>
</div>
<!-- ====================================================================== -->

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
// ---------------- Firebase ----------------
const firebaseConfig = {
  apiKey: "YOUR_WEB_API_KEY",
  authDomain: "shsproject-d60d0.firebaseapp.com",
  databaseURL: "https://shsproject-d60d0-default-rtdb.firebaseio.com",
  projectId: "shsproject-d60d0",
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// Generate a unique visitor ID (per session)
const visitorId = 'visitor_' + Date.now();

// Online presence
const onlineRef = db.ref('online/' + visitorId);
onlineRef.set({online:true});
onlineRef.onDisconnect().remove();

// UI element
const visitorCounter = document.getElementById('visitorCounter');

// Increment total visitors only once per user (use localStorage to avoid duplicates)
if (!localStorage.getItem('visitorCounted')) {
    db.ref('totalVisitors').transaction(val => (val || 0) + 1);
    localStorage.setItem('visitorCounted', 'yes');
}

// Listen for online users and total visitors
const totalRef = db.ref('totalVisitors');
const onlineDbRef = db.ref('online');

function updateCounter() {
    onlineDbRef.once('value').then(snap => {
        const online = snap.numChildren();
        totalRef.once('value').then(snap2 => {
            const total = snap2.val() || 0;
            visitorCounter.innerText = `Visitors Online: ${online} | Total Visitors: ${total}`;
        });
    });
}

// Update counter live when online users change
onlineDbRef.on('value', updateCounter);
totalRef.on('value', updateCounter);

// ---------------- Chat ----------------
let username = 'Guest' + Math.floor(Math.random()*1000);
let userColor = ['#007bff','#ff4500','#32cd32','#ffa500','#9932cc'][Math.floor(Math.random()*5)];

const chatMessages = document.getElementById('chatMessages');
const chatInput = document.getElementById('chatInput');
const typingIndicator = document.getElementById('typingIndicator');

// Typing indicator
let typing = false;
chatInput.addEventListener('input', () => {
    if(!typing){
        typing = true;
        db.ref('chatTyping/'+visitorId).set(username);
        setTimeout(stopTyping, 2000);
    } else {
        clearTimeout(stopTyping.timeout);
        stopTyping.timeout = setTimeout(stopTyping, 2000);
    }
});
function stopTyping(){
    typing = false;
    db.ref('chatTyping/'+visitorId).remove();
}

// Send message
chatInput.addEventListener('keypress', e => {
    if(e.key === 'Enter' && chatInput.value.trim() !== ''){
        const msgData = {
            user: username,
            text: chatInput.value,
            color: userColor,
            time: Date.now(),
            uid: visitorId
        };
        db.ref('chat').push(msgData);
        chatInput.value='';
    }
});

// Listen to chat messages
db.ref('chat').limitToLast(100).on('child_added', snapshot => {
    const msg = snapshot.val();
    const msgDiv = document.createElement('div');
    msgDiv.style.marginBottom='6px';
    msgDiv.style.display='flex';
    msgDiv.style.justifyContent = 'space-between';
    
    const leftDiv = document.createElement('div');
    leftDiv.innerHTML = `<span style="color:${msg.color}; font-weight:bold;">${msg.user}</span>: ${msg.text} 
                         <small style="color:#888; font-size:11px;">${new Date(msg.time).toLocaleTimeString()}</small>`;
    leftDiv.style.maxWidth='85%';
    leftDiv.style.wordWrap='break-word';
    
    // Delete button if owner
    if(msg.uid === visitorId){
        const delBtn = document.createElement('button');
        delBtn.innerHTML='âœ–';
        delBtn.style.border='none';
        delBtn.style.background='transparent';
        delBtn.style.color='#888';
        delBtn.style.cursor='pointer';
        delBtn.title='Delete';
        delBtn.onclick = () => snapshot.ref.remove();
        leftDiv.appendChild(delBtn);
    }

    msgDiv.appendChild(leftDiv);
    chatMessages.appendChild(msgDiv);

    // Auto-scroll if near bottom
    if(chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight < 50){
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
});

// Typing indicators
db.ref('chatTyping').on('value', snap => {
    const typingUsers = Object.values(snap.val()||{}).filter(u => u!==username);
    if(typingUsers.length>0){
        typingIndicator.innerText = typingUsers.join(', ') + ' is typing...';
    } else {
        typingIndicator.innerText = '';
    }
});

// Change Name/Color popup
const changeNameBtn = document.getElementById('changeNameBtn');
const chatNameColorPopup = document.getElementById('chatNameColorPopup');
const chatPopupUsername = document.getElementById('chatPopupUsername');
const chatPopupColor = document.getElementById('chatPopupColor');
const chatSaveNameColor = document.getElementById('chatSaveNameColor');

// Open popup
changeNameBtn.addEventListener('click', () => {
    chatPopupUsername.value = username;
    chatPopupColor.value = userColor;
    chatNameColorPopup.style.display = 'block';
});

// Save changes
chatSaveNameColor.addEventListener('click', () => {
    if(chatPopupUsername.value.trim() !== '') username = chatPopupUsername.value.trim();
    userColor = chatPopupColor.value;
    chatNameColorPopup.style.display = 'none';
});

// ---------------- Buttons ----------------
const iframe = document.getElementById('embeddedSite');
let zoomLevel = 1;
let originalSrc = iframe.src;
const extraBtn = document.getElementById('extraSiteBtn');
const privacyBtn = document.getElementById('privacyBtn');
let onExtra = false;
let onPrivacy = false;

document.getElementById('reloadBtn').addEventListener('click', ()=>iframe.src = iframe.src);

document.getElementById("fullscreenBtn").addEventListener("click", () => {
    const frame = document.getElementById("embeddedSite");
    frame.requestFullscreen?.();
});

document.getElementById('zoomInBtn').addEventListener('click', ()=>{ zoomLevel += 0.1; iframe.style.transform = `scale(${zoomLevel})`; iframe.style.transformOrigin='top left'; });
document.getElementById('zoomOutBtn').addEventListener('click', ()=>{ zoomLevel = Math.max(0.5, zoomLevel - 0.1); iframe.style.transform = `scale(${zoomLevel})`; iframe.style.transformOrigin='top left'; });
document.getElementById('hideIframeBtn').addEventListener('click', ()=>iframe.style.display='none');
document.getElementById('showIframeBtn').addEventListener('click', ()=>iframe.style.display='block');

extraBtn.addEventListener('click', ()=>{ if(!onExtra){ iframe.src='https://funfrinew.neocities.org/'; extraBtn.innerHTML='<i class="fas fa-arrow-left"></i> Go Back'; onExtra=true; } else { iframe.src=originalSrc; extraBtn.innerHTML='<i class="fas fa-gamepad"></i> Extra Site'; onExtra=false; } });
privacyBtn.addEventListener('click', ()=>{ if(!onPrivacy){ iframe.src="https://webtoppings.bar/browse?url=https://wikipedia.org&region=us-west&mode=privacy"; privacyBtn.innerHTML='<i class="fas fa-arrow-left"></i> Go Back'; onPrivacy=true; } else { iframe.src=originalSrc; privacyBtn.innerHTML='<i class="fas fa-shield-alt"></i> Browser'; onPrivacy=false; } });

// ---------------- Tutorial ----------------
const steps = [
    {text:"Welcome! This tutorial guides you through the buttons.", target:null},
    {text:"Reload: Reloads the embedded site.", target:document.getElementById('reloadBtn')},
    {text:"Fullscreen: Make the site fullscreen.", target:document.getElementById('fullscreenBtn')},
    {text:"Zoom: Scale the site for better view.", target:document.getElementById('zoomInBtn')},
    {text:"Hide/Show: Hide or show the embedded site.", target:document.getElementById('hideIframeBtn')},
    {text:"Extra Site: Open a fun game site.", target:extraBtn},
    {text:"Browser: Browse UNBLOCKED!", target:privacyBtn}
];
let currentStep = 0;
const overlay = document.getElementById('tutorialOverlay');
const bubble = document.getElementById('tutorialBubble');
const arrow = document.getElementById('tutorialArrow');

function showStep(step){
    overlay.style.display='block';
    const s = steps[step];
    bubble.innerHTML = s.text + '<br>' +
        '<button id="nextTutorialBtn">Next</button> ' +
        '<button id="skipTutorialBtn">Skip</button>';

    // Next button
    document.getElementById('nextTutorialBtn').addEventListener('click', ()=>{
        currentStep++;
        if(currentStep >= steps.length){
            overlay.style.display='none';
            arrow.style.display='none';
            showPopup();
        } else showStep(currentStep);
    });

    // Skip button
    document.getElementById('skipTutorialBtn').addEventListener('click', ()=>{
        overlay.style.display='none';
        arrow.style.display='none';
        localStorage.setItem('tutorialShown','true'); // mark tutorial as seen
        showPopup();
    });

    if(s.target){
        const rect = s.target.getBoundingClientRect();
        bubble.style.top = (rect.bottom + 20 + window.scrollY) + 'px';
        bubble.style.left = (rect.left + rect.width/2) + 'px';
        arrow.style.display='block';
        arrow.style.top = (rect.bottom + window.scrollY) + 'px';
        arrow.style.left = (rect.left + rect.width/2 - 12) + 'px';
    } else {
        bubble.style.top='30%';
        bubble.style.left='50%';
        arrow.style.display='none';
    }

    setTimeout(()=>bubble.classList.add('show'),50);
}

function startTutorial(){ currentStep=0; showStep(currentStep); localStorage.setItem('tutorialShown','true'); }
document.getElementById('replayTutorialBtn').addEventListener('click', startTutorial);

// ---------------- Popup ----------------
const popup = document.getElementById('fullscreenPopup');
// Close when clicking the X button
popup.querySelector('.closeBtn').addEventListener('click', () => {
    popup.classList.remove('show');
});

// Close when clicking *anywhere* outside the popupContent
popup.addEventListener('click', (e) => {
        popup.classList.remove('show');
});

function showPopup(){ popup.classList.add('show'); }

// ---------------- Sparkles ----------------
const canvas = document.getElementById('sparkleCanvas');
const ctx = canvas.getContext('2d');
let sparkles=[];
function resizeCanvas(){ canvas.width=canvas.offsetWidth; canvas.height=canvas.offsetHeight; }
window.addEventListener('resize',resizeCanvas); resizeCanvas();
function createSparkle(){ return { x:Math.random()*canvas.width, y:Math.random()*canvas.height, r:Math.random()*3+1, vx:(Math.random()-0.5)*0.5, vy:(Math.random()-0.5)*0.5, alpha:Math.random(), color:['#007bff','#00bfff','#4682b4','#5f9ea0'][Math.floor(Math.random()*4)] }; }
for(let i=0;i<150;i++) sparkles.push(createSparkle());
function animateSparkles(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let s of sparkles){
        ctx.beginPath();
        ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
        ctx.fillStyle=`rgba(${parseInt(s.color.slice(1,3),16)},${parseInt(s.color.slice(3,5),16)},${parseInt(s.color.slice(5,7),16)},${s.alpha})`;
        ctx.fill();
        s.x+=s.vx; s.y+=s.vy;
        if(s.x<0||s.x>canvas.width)s.vx*=-1;
        if(s.y<0||s.y>canvas.height)s.vy*=-1;
    }
    requestAnimationFrame(animateSparkles);
}
animateSparkles();

// ---------------- Chat Toggle ----------------
const chatContainer = document.getElementById('chatContainer');
const toggleChatBtn = document.getElementById('toggleChatBtn');

toggleChatBtn.addEventListener('click', () => {
    if(chatContainer.style.display === 'none' || chatContainer.style.display === '') {
        chatContainer.style.display = 'block';
    } else {
        chatContainer.style.display = 'none';
    }
});

// ================= Drawing Modal =================
const drawingModal = document.getElementById('drawingModal');
const openDrawingBtn = document.getElementById('openDrawingBtn');
const closeDrawingBtn = document.getElementById('closeDrawingBtn');
openDrawingBtn.addEventListener('click', () => {
  drawingModal.style.display = 'flex';
  drawingModal.setAttribute('aria-hidden','false');
});
closeDrawingBtn.addEventListener('click', () => {
  drawingModal.style.display = 'none';
  drawingModal.setAttribute('aria-hidden','true');
});
// click outside to close
drawingModal.addEventListener('click', (e) => {
  if(e.target === drawingModal) {
    drawingModal.style.display = 'none';
    drawingModal.setAttribute('aria-hidden','true');
  }
});

// ================= Shared Drawing Canvas Script =================
(function(){
  const container = document.getElementById('sharedCanvasContainer');
  const toggleBtn = document.getElementById('toggleCanvasBtn');
  const canvasWrapper = document.getElementById('canvasArea');
  const canvasEl = document.getElementById('sharedCanvas');
  const ctx2 = canvasEl.getContext('2d');
  const colorPicker = document.getElementById('colorPicker');
  const sizeSlider = document.getElementById('sizeSlider');
  const sizeLabel = document.getElementById('sizeLabel');
  const clearBtn = document.getElementById('clearCanvasBtn');

  // Basic state
  let drawing = false;
  let currentStroke = [];
  let brushColor = colorPicker.value;
  let brushSize = parseInt(sizeSlider.value,10);
  const drawnIds = new Set(); // stroke IDs already rendered
  const strokesRef = db.ref('canvas/strokes');
  const metaRef = db.ref('canvas/meta');
  const strokesCache = {}; // local cache of strokes by id to allow redraw on resize

  // Resize helper
  function resizeCanvasToDisplay() {
    const ratio = window.devicePixelRatio || 1;
    const styleW = Math.min(window.innerWidth - 60, 1000);
    const styleH = Math.min(window.innerHeight * 0.7, 700);
    canvasEl.width = styleW * ratio;
    canvasEl.height = styleH * ratio;
    canvasEl.style.width = styleW + 'px';
    canvasEl.style.height = styleH + 'px';
    ctx2.setTransform(ratio, 0, 0, ratio, 0, 0);
    // After resizing the canvas (which clears its bitmap), redraw cached strokes
    redrawAllStrokes();
  }
  window.addEventListener('resize', resizeCanvasToDisplay);
  resizeCanvasToDisplay();

  // Show/hide canvas area toggle
  toggleBtn.addEventListener('click', () => {
    if (canvasWrapper.style.display === 'none' || canvasWrapper.style.display === '') {
      canvasWrapper.style.display = 'block';
      toggleBtn.textContent = 'Close Canvas';
      resizeCanvasToDisplay();
    } else {
      canvasWrapper.style.display = 'none';
      toggleBtn.textContent = 'Open Canvas';
    }
  });

  // UI bindings
  colorPicker.addEventListener('input', (e) => brushColor = e.target.value);
  sizeSlider.addEventListener('input', (e) => { brushSize = parseInt(e.target.value,10); sizeLabel.textContent = brushSize; });

  // Convert screen coords to canvas coords
  function getCanvasPoint(e) {
    const rect = canvasEl.getBoundingClientRect();
    const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX);
    const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY);
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    return { x: Math.round(x), y: Math.round(y) };
  }

  function drawStrokeLocally(stroke, opts={}) {
    if(!stroke || !stroke.points || stroke.points.length===0) return;
    ctx2.lineJoin = 'round';
    ctx2.lineCap = 'round';
    ctx2.strokeStyle = stroke.color;
    ctx2.lineWidth = stroke.size;
    ctx2.beginPath();
    const pts = stroke.points;
    ctx2.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++){
      ctx2.lineTo(pts[i].x, pts[i].y);
    }
    ctx2.stroke();
  }

  // Redraw all strokes from the in-memory cache (sorted by time)
  function redrawAllStrokes() {
    try {
      ctx2.clearRect(0,0,canvasEl.width,canvasEl.height);
      drawnIds.clear();
      // Sort strokes by timestamp so order is preserved
      const strokes = Object.keys(strokesCache).map(k => ({ id: k, s: strokesCache[k] }));
      strokes.sort((a,b) => (a.s.time || 0) - (b.s.time || 0));
      for(const item of strokes) {
        drawStrokeLocally(item.s);
        drawnIds.add(item.id);
      }
    } catch (err) {
      console.warn('redrawAllStrokes failed', err);
    }
  }

  // Pointer events
  canvasEl.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    canvasEl.setPointerCapture?.(e.pointerId);
    drawing = true;
    currentStroke = [];
    const p = getCanvasPoint(e);
    currentStroke.push(p);
    ctx2.fillStyle = brushColor;
    ctx2.beginPath();
    ctx2.arc(p.x, p.y, Math.max(1, brushSize/2), 0, Math.PI*2);
    ctx2.fill();
  });

  canvasEl.addEventListener('pointermove', (e) => {
    if(!drawing) return;
    e.preventDefault();
    const p = getCanvasPoint(e);
    const last = currentStroke[currentStroke.length-1];
    if(!last || last.x !== p.x || last.y !== p.y) {
      currentStroke.push(p);
      ctx2.lineJoin = 'round';
      ctx2.lineCap = 'round';
      ctx2.strokeStyle = brushColor;
      ctx2.lineWidth = brushSize;
      ctx2.beginPath();
      ctx2.moveTo(last.x, last.y);
      ctx2.lineTo(p.x, p.y);
      ctx2.stroke();
    }
  });

  canvasEl.addEventListener('pointerup', async (e) => {
    if(!drawing) return;
    drawing = false;
    if(currentStroke.length > 0) {
      const strokeObj = {
        user: visitorId || ('anon_'+Date.now()),
        color: brushColor,
        size: brushSize,
        points: currentStroke,
        time: Date.now()
      };
      try {
        const pushRef = await strokesRef.push(strokeObj);
        drawnIds.add(pushRef.key);
      } catch (err) {
        console.error('Failed to push stroke', err);
      }
    }
    currentStroke = [];
  });

  canvasEl.addEventListener('pointercancel', () => { drawing=false; currentStroke=[]; });

  // Listen for strokes added by anyone
  strokesRef.on('child_added', snapshot => {
    const strokeId = snapshot.key;
    const stroke = snapshot.val();
    if(!stroke) return;
    // Cache the stroke
    strokesCache[strokeId] = stroke;
    // If not already drawn on current canvas, draw it
    if(!drawnIds.has(strokeId)){
      drawStrokeLocally(stroke);
      drawnIds.add(strokeId);
    }
  });

  // When a stroke is removed (e.g., clear), update cache and redraw
  strokesRef.on('child_removed', snapshot => {
    const id = snapshot.key;
    if(id && strokesCache[id]) delete strokesCache[id];
    redrawAllStrokes();
  });

  // Listen for clear events
  metaRef.child('clear').on('value', snap => {
    const v = snap.val();
    if(v) {
      // Clear visible canvas and local caches so redraw won't restore cleared strokes
      ctx2.clearRect(0,0,canvasEl.width,canvasEl.height);
      drawnIds.clear();
      for(const k in strokesCache) delete strokesCache[k];
    }
  });

  // Clear button
  clearBtn.addEventListener('click', async () => {
    try {
      // Remove all strokes from DB so the clear persists across reloads
      await strokesRef.remove();
      // Notify other clients with a transient clear flag
      await metaRef.child('clear').set({ by: visitorId || 'anon', time: Date.now() });
      // Remove transient clear flag shortly after so new clients don't auto-clear forever
      setTimeout(() => { metaRef.child('clear').remove().catch(()=>{}); }, 1500);
    } catch (err) {
      console.warn('Failed to clear strokes', err);
    }
  });

  // Presence
  const userId = visitorId || ('anon_'+Date.now());
  const presenceRef = db.ref('canvas/presence/' + userId);
  presenceRef.set({online:true, color: colorPicker.value, lastSeen: Date.now()});
  presenceRef.onDisconnect().remove();

  // ================= Cursor Tracking =================
  const cursorOverlay = document.getElementById('cursorOverlay');
  const ctxCursor = cursorOverlay.getContext('2d');
  const cursorsRef = db.ref('canvas/cursors');
  let activeCursors = {}; // { userId: { x, y, color, username, timestamp } }
  
  // Sync cursor overlay to main canvas size
  function syncCursorOverlay() {
    // Match the overlay to the main canvas device pixel dimensions
    // canvasEl.width/height are in device pixels (after resize helper sets them)
    const ratio = window.devicePixelRatio || 1;
    cursorOverlay.width = canvasEl.width;    // device pixels
    cursorOverlay.height = canvasEl.height;  // device pixels
    // Keep CSS size the same as the visible canvas so boundingClientRect coords match
    cursorOverlay.style.width = canvasEl.style.width;
    cursorOverlay.style.height = canvasEl.style.height;
    // Reset transform and scale so we can draw using CSS pixel coordinates (same units as getCanvasPoint)
    ctxCursor.setTransform(1, 0, 0, 1, 0, 0);
    ctxCursor.scale(ratio, ratio);
    // Ensure overlay doesn't block pointer events on the main canvas
    cursorOverlay.style.pointerEvents = 'none';
  }
  window.addEventListener('resize', syncCursorOverlay);
  syncCursorOverlay();

  // Track mouse movement and broadcast cursor
  let lastCursorUpdate = 0;
  canvasEl.addEventListener('pointermove', (e) => {
    const now = Date.now();
    if(now - lastCursorUpdate > 100) { // Throttle to 100ms
      const p = getCanvasPoint(e);
      cursorsRef.child(userId).set({
        x: p.x,
        y: p.y,
        color: brushColor,
        username: username,
        timestamp: Date.now()
      }).catch(err => console.warn('Cursor update failed', err));
      lastCursorUpdate = now;
    }
  });

  // Listen for other users' cursors
  cursorsRef.on('value', snap => {
    const data = snap.val() || {};
    activeCursors = data;
  });

  // Draw cursors on overlay
  function drawCursorsFrame() {
    // Clear using device pixel dimensions â€” ctx transform is already scaled to device pixels
    ctxCursor.clearRect(0, 0, cursorOverlay.width, cursorOverlay.height);

    for(const uid in activeCursors) {
      if(uid === userId) continue; // Don't draw own cursor
      const cursor = activeCursors[uid];
      if(!cursor || (typeof cursor.x !== 'number') || (typeof cursor.y !== 'number')) continue;

      // Don't show stale cursors (older than 2 seconds)
      if(Date.now() - cursor.timestamp > 2000) continue;

      // cursor.x/y are stored in CSS pixels (getCanvasPoint uses boundingClientRect)
      // ctxCursor is scaled so drawing with CSS coordinates works correctly
      const x = cursor.x;
      const y = cursor.y;
      const color = cursor.color || '#00ffff';

      // Draw cursor dot
      ctxCursor.save();
      ctxCursor.fillStyle = color;
      ctxCursor.beginPath();
      ctxCursor.arc(x, y, 5, 0, Math.PI * 2);
      ctxCursor.fill();

      // Draw cursor glow
      ctxCursor.strokeStyle = color;
      ctxCursor.lineWidth = 2;
      ctxCursor.globalAlpha = 0.5;
      ctxCursor.beginPath();
      ctxCursor.arc(x, y, 8, 0, Math.PI * 2);
      ctxCursor.stroke();
      ctxCursor.globalAlpha = 1;

      // Draw username label
      ctxCursor.fillStyle = color;
      ctxCursor.font = 'bold 11px Arial';
      ctxCursor.textBaseline = 'top';
      ctxCursor.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctxCursor.shadowBlur = 3;
      ctxCursor.fillText(cursor.username, x + 12, y + 2);
      ctxCursor.restore();
    }

    requestAnimationFrame(drawCursorsFrame);
  }
  drawCursorsFrame();

  // Clean up own cursor on canvas exit
  canvasEl.addEventListener('pointerleave', () => {
    cursorsRef.child(userId).remove().catch(err => console.warn('Cursor cleanup failed', err));
  });

  canvasEl.addEventListener('pointerenter', () => {
    presenceRef.update({lastSeen: Date.now()});
  });

  // Ensure presence and cursor entries are removed when the connection disconnects
  try {
    presenceRef.onDisconnect().remove();
    cursorsRef.child(userId).onDisconnect().remove();
  } catch (err) {
    console.warn('onDisconnect setup failed', err);
  }

  // Update presence color when user changes brush color
  colorPicker.addEventListener('input', (e) => {
    brushColor = e.target.value;
    try { presenceRef.update({ color: brushColor }); } catch (err) { /* ignore */ }
  });

  // Initial load of existing strokes
  // Initial load of existing strokes: populate local cache then redraw
  strokesRef.limitToFirst(5000).once('value').then(snap => {
    const data = snap.val();
    if(!data) return;
    try {
      Object.keys(data).forEach(k => {
        strokesCache[k] = data[k];
      });
      // Draw cached strokes once (preserves order)
      redrawAllStrokes();
    } catch (err) {
      console.warn('initial strokes processing failed', err);
    }
  }).catch(err => console.warn('initial strokes load failed', err));
})();

// ================= Loading Screen Removal =================
// Remove loading screen after 3 seconds (don't wait for window load)
setTimeout(function() {
    const introScreen = document.getElementById('introScreen');
    if (introScreen) {
        console.log('Removing loading screen...');
        introScreen.style.transition = 'opacity 1s ease';
        introScreen.style.opacity = '0';
        setTimeout(function() {
            if (introScreen && introScreen.parentNode) {
                introScreen.remove();
                console.log('Loading screen removed');
            }
        }, 1000);
    }
}, 2000);

// Safety fallback - remove loading screen after max 5 seconds
setTimeout(function() {
    const introScreen = document.getElementById('introScreen');
    if (introScreen && introScreen.parentNode) {
        console.log('Safety fallback: Removing loading screen');
        introScreen.style.transition = 'opacity 0.5s ease';
        introScreen.style.opacity = '0';
        setTimeout(function() {
            if (introScreen && introScreen.parentNode) {
                introScreen.remove();
            }
        }, 500);
    }
}, 5000);

// ================= Page Initialization =================
// Initialize tutorial/popup when page loads
window.addEventListener('load', function() {
    console.log('Page fully loaded');
    if(!localStorage.getItem('tutorialShown')) {
        startTutorial();
    } else {
        showPopup();
    }
});

// ================= Intro Screen Particles =================
const particleCanvas = document.createElement('canvas');
particleCanvas.width = window.innerWidth;
particleCanvas.height = window.innerHeight;
document.querySelector('.introParticles').appendChild(particleCanvas);
const particleCtx = particleCanvas.getContext('2d');

let particles = [];
for(let i=0;i<100;i++){
    particles.push({
        x:Math.random()*particleCanvas.width,
        y:Math.random()*particleCanvas.height,
        r:Math.random()*3+1,
        vx:(Math.random()-0.5)*0.5,
        vy:(Math.random()-0.5)*0.5,
        color:['#fff','#00f','#0ff','#ff0'][Math.floor(Math.random()*4)]
    });
}

function animateParticles(){
    particleCtx.clearRect(0,0,particleCanvas.width,particleCanvas.height);
    for(let p of particles){
        particleCtx.beginPath();
        particleCtx.arc(p.x,p.y,p.r,0,Math.PI*2);
        particleCtx.fillStyle=p.color;
        particleCtx.fill();
        p.x += p.vx; p.y += p.vy;
        if(p.x<0||p.x>particleCanvas.width)p.vx*=-1;
        if(p.y<0||p.y>particleCanvas.height)p.vy*=-1;
    }
    requestAnimationFrame(animateParticles);
}
animateParticles();

window.addEventListener('resize', ()=>{
    particleCanvas.width = window.innerWidth;
    particleCanvas.height = window.innerHeight;
});
</script>

</body>
</html>
