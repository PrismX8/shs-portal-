<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Global Chat - NautilusOS</title>
  <meta name="description" content="NautilusOS Global Chat - Connect and chat with the community.">
  <meta name="keywords" content="chat, community, NautilusOS">
  <meta name="author" content="NautilusOS">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link rel="stylesheet" href="https://unpkg.com/open-props">
  <link rel="stylesheet" href="https://unpkg.com/open-props/normalize.min.css">
  <link rel="stylesheet" href="https://unpkg.com/open-props/buttons.min.css">

  <style>
    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --accent: #7dd3c0;
      --accent-hover: #5bb98c;
      --border: rgba(255, 255, 255, 0.1);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --info: #3b82f6;
      --owner-text: #2b1b05;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--bg-primary);
    }

    .chat-header {
      background: rgba(30, 35, 48, 0.9);
      border-bottom: 1px solid var(--border);
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .chat-title {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1rem;
    }

    .online-count {
      background: rgba(125, 211, 192, 0.2);
      color: var(--accent);
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
      min-width: 24px;
      text-align: center;
    }

    .chat-title i { color: var(--accent); font-size: 1.1rem; }
    .chat-actions { display: flex; gap: 5px; }

    .chat-action-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 32px;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .chat-action-btn:hover {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border-color: var(--accent);
    }

    .chat-content { flex: 1; display: block; overflow: hidden; height: 100%; }

    .messages-area {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: rgba(15, 18, 25, 0.6);
    }

    .messages-container {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 100%;
    }

    .message { display: flex; margin-bottom: 8px; }

    /* Center messages (system + moderation) */
    .message.system { justify-content: center; }

    /* Default center message look (normal system/info) */
    .message.system .message-content {
      background: rgba(125, 211, 192, 0.1);
      border: 1px solid rgba(125, 211, 192, 0.2);
      border-radius: 12px;
      padding: 8px 12px;
      text-align: center;
      font-size: 0.85rem;
      color: var(--accent);
      max-width: 70%;
    }

    /* Moderation center message look (red blurred background) */
    .message.system.mod .message-content {
      background: rgba(239, 68, 68, 0.18);
      border: 1px solid rgba(239, 68, 68, 0.35);
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow:
        0 0 0 1px rgba(239, 68, 68, 0.15),
        0 10px 30px rgba(239, 68, 68, 0.12);
    }

    .message.user { justify-content: flex-end; }
    .message.other { justify-content: flex-start; }

    .message-content {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 0.9rem;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .message.user .message-content {
      background: var(--accent);
      color: var(--bg-primary);
      border-bottom-right-radius: 4px;
    }

    .message.other .message-content {
      background: rgba(30, 35, 48, 0.8);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
    }

    /* Moderation normal chat bubble (NOT centered, NOT system) */
    .message.moderation .message-content {
      background: rgba(239, 68, 68, 0.22);
      border: 1px solid rgba(239, 68, 68, 0.45);
      color: #fff;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 0 18px rgba(239, 68, 68, 0.35);
    }

    .message.moderation .message-username {
      color: #fecaca;
    }

    .message.owner .message-content {
      background: linear-gradient(135deg, #f7dc8b, #f0b64b);
      color: var(--owner-text);
      border: 1px solid rgba(255, 222, 138, 0.9);
      box-shadow: 0 0 0 1px rgba(255, 215, 120, 0.6);
      position: relative;
      isolation: isolate;
    }

    .message.owner .message-content::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 18px;
      border: 1px solid rgba(255, 236, 170, 0.7);
      pointer-events: none;
      z-index: 0;
    }

    .message.owner .message-content > * { position: relative; z-index: 1; }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }

    .message.user .message-header { justify-content: flex-end; }
    .message.other .message-header { justify-content: flex-start; }

    .message-username { font-weight: 600; color: var(--accent); }
    .message.user .message-username { color: var(--bg-primary); }
    .message.owner .message-username { color: #111; }

    .message-timestamp { color: var(--text-secondary); font-size: 0.75rem; }
    .message.user .message-timestamp { color: rgba(15, 23, 42, 0.7); }
    .message.owner .message-timestamp { color: rgba(66, 45, 8, 0.75); }

    .message.sending .message-content {
      opacity: 0.85;
      border: 1px solid rgba(251, 191, 36, 0.3);
    }

    .message.failed .message-content {
      opacity: 0.75;
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.1);
    }

    .sending-indicator, .failed-indicator {
      margin-left: 8px;
      font-size: 0.8rem;
      opacity: 0.9;
      white-space: nowrap;
    }

    .sending-indicator { color: #f59e0b; }
    .failed-indicator { color: #ef4444; }
    .sending-indicator i { margin-right: 4px; }

    .input-area {
      background: rgba(21, 25, 35, 0.9);
      border-top: 1px solid var(--border);
      padding: 16px;
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .message-input {
      flex: 1;
      padding: 12px 16px;
      background: rgba(30, 35, 48, 0.8);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.9rem;
      resize: none;
      min-height: 44px;
      max-height: 120px;
      transition: all 0.2s ease;
    }

    .message-input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(30, 35, 48, 0.95);
    }

    .message-input::placeholder { color: var(--text-muted); }

    .send-button {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      border: none;
      border-radius: 12px;
      color: var(--bg-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    .send-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(125, 211, 192, 0.3);
    }

    .send-button:active { transform: translateY(0); }

    .messages-container::-webkit-scrollbar { width: 6px; }
    .messages-container::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 3px; }
    .messages-container::-webkit-scrollbar-thumb { background: rgba(125, 211, 192, 0.3); border-radius: 3px; }
    .messages-container::-webkit-scrollbar-thumb:hover { background: rgba(125, 211, 192, 0.5); }

    @media (max-width: 768px) {
      .message-content { max-width: 85%; }
    }
  </style>
</head>

<body>
  <div class="chat-container">
    <div class="chat-header">
      <div class="chat-title">
        <i class="fas fa-comments"></i>
        <span class="online-count">12</span> online
      </div>
      <div class="chat-actions">
        <button class="chat-action-btn" onclick="toggleSound()" title="Toggle Sound">
          <i class="fas fa-volume-up" id="soundIcon"></i>
        </button>
        <button class="chat-action-btn" onclick="clearMessages()" title="Clear Chat">
          <i class="fas fa-trash"></i>
        </button>
      </div>
    </div>

    <div class="chat-content">
      <div class="messages-area">
        <div class="messages-container" id="messagesContainer"></div>
      </div>
    </div>

    <div class="input-area">
      <textarea
        class="message-input"
        id="messageInput"
        placeholder="Type your message..."
        onkeydown="handleKeyPress(event)"
        maxlength="750"
      ></textarea>
      <button class="send-button" onclick="sendMessage()">
        <i class="fas fa-paper-plane"></i>
      </button>
    </div>
  </div>

  <!-- Supabase client library (defines window.supabase). -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    // =====================================================
    // GLOBAL CHAT - CLOUDFLARE (PRIMARY) + SUPABASE (FALLBACK)
    // - Fixes: "mod is not defined"
    // - Fixes: undefined rawUsername in send moderation
    // - Supabase fallback reliably used when Cloudflare 429/5xx/etc
    // - Removed hard-coded bad-words lists (place comments where to add)
    // =====================================================

    // Cloudflare Worker base (set by parent window or URL param)
    let CHAT_API_BASE = null;

    // Supabase (browser-safe anon/publishable key)
    const SUPABASE_URL = "https://bvhigzazfcsoqeivnmxe.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_DMZNbwUB_8qvQRTtl5xS5g_OMdvEZdQ";
    const SUPABASE_TABLE = "chat_messages";

    // IMPORTANT: do NOT name this "supabase" (Nebulo likely already has a global)
    const sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Cloudflare circuit breaker (rate-limit backoff)
    let cfBackoffUntil = 0;
    const CF_BACKOFF_MS = 10 * 60 * 1000; // 10 minutes

    // Chat state
    let currentUsername = 'User';
    let messages = [];
    let soundEnabled = true;
    let notificationsEnabled = true;
    let globalChatSending = false;

    // Unread / window state
    let unreadMessageCount = 0;
    let isChatWindowOpen = false;

    // Bootstrap / UI flags
    let chatBootstrapInFlight = false;
    let periodicNotificationsStarted = false;
    let onlineCountIntervalStarted = false;
    let chatHistoryBootstrapped = false;
    let shouldAutoScroll = true;
    let lastScrollTop = 0;

    // Backend mode tracking
    let backendMode = "unknown"; // "cloudflare" | "supabase" | "unknown"
    let lastGlobalChatMessageSig = "";

    // Dedup + DOM tracking
    const seenSigs = new Set();
    const messageNodeIndex = new Map();

    // Pending "sending" reconciliation (prevents duplicate popups)
    const pendingOutbox = []; // [{tempId, name, text, createdAtMs}]
    const PENDING_MATCH_WINDOW_MS = 60 * 1000;

    const OWNER_USERNAME = 'shs12lord';
    const OWNER_DISPLAY_NAME = 'Owner';

    // ------------------------------
    // MODERATION (PLACEHOLDERS ONLY)
    // Add your patterns/words in the commented spots below.
    // ------------------------------
    function buildWordRegex(words) {
      const escaped = (words || []).map(w => String(w).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
      if (!escaped.length) return null;
      return new RegExp(`\\b(${escaped.join("|")})\\b`, "i");
    }

    const MOD = {
      enabled: true,

      hatePatterns: [
        /\b(white\s*power|heil\s*hitler|ku\s*klux\s*klan|kkk|1488|14\/88|nigger|nigga)\b/i,
        /\b(go\s+back\s+to\s+your\s+country)\b/i,
        /\b(kill|exterminate|lynch|gas)\s+(all|every)\s+(black|white|asian|mexican|latino|jewish|muslim|christian|immigrant)s?\b/i,
        /\b(all|every)\s+(black|white|asian|mexican|latino|jewish|muslim|christian|immigrant)s?\s+(should|must)\s+(die|be\s+killed|be\s+gone)\b/i
      ],

      sexualPatterns: [],
      selfHarmPatterns: [],
      violencePatterns: [],
      hackingPatterns: [],
      illegalPatterns: []
    };

    MOD.sexualPatterns.push(buildWordRegex([
      "porn", "xxx", "hentai", "fetish", "erotic", "milf", "bdsm", "cam", "webcam",
      "nude", "nudity", "boobs", "tits", "pussy", "anal", "cum", "blowjob", "jav",
      "incest", "amateur", "softcore","goon","daddy","diddy","gooner","ballsack",
      "oil","gay","lesbian","shemale","trans","balls", "gaping","creampie","threesome",
      "o!l","mom","dad","freaky","nsfw","nsfwchat","bdsm","bondage","spanking",
      "roast","harder","tickling","watersports","swing","stupid",

      "pornhub.com", "xvideos.com", "redtube.com", "youporn.com", "xhamster.com", "xnxx.com",
      "spankbang.com", "tube8.com", "tnaflix.com", "porndig.com", "efukt.com", "empflix.com",
      "javhub.com", "faproulette.com", "sex.com", "cam4.com", "chaturbate.com", "livejasmin.com",

      "4chan.org", "8kun.top", "kiwifarms.net", "reddit.com/r/nsfw", "reddit.com/r/gonewild",

      "write porn story", "erotic roleplay", "roleplay as my girlfriend", "be my sexbot",
      "generate nude", "make nsfw image", "make porn", "draw hentai", "make me a sex story",
      "write erotic novel", "write smut", "dirty story", "make nsfw picture", "make nude picture",
      "simulate sex", "roleplay nsfw", "pretend to be my lover", "dirty talk", "make hentai"
    ]));

    MOD.selfHarmPatterns.push(buildWordRegex([
      "help me kill myself", "tell me how to die", "help me suicide", "write suicide note",
      "make me self harm", "ways to kill myself", "how to commit suicide", "how to overdose",
      "whatâ€™s the best way to die", "help me harm myself", "tell me how to hang myself"
    ]));

    MOD.violencePatterns.push(buildWordRegex([
      "how to make a bomb", "how to make explosives", "build a gun", "how to stab",
      "how to poison", "how to kill someone", "murder plan", "terrorist guide",
      "shooting guide", "assassin instructions", "step by step bomb", "terror attack"
    ]));

    MOD.hackingPatterns.push(buildWordRegex([
      "how to hack facebook", "hack instagram", "hack gmail", "steal password",
      "crack wifi", "bypass paywall", "bypass filter", "how to ddos", "how to hack website",
      "prompt injection", "jailbreak ai", "bypass moderation", "ignore your rules", "act as unrestricted ai"
    ]));

    MOD.illegalPatterns.push(buildWordRegex([
      "pirated movies", "torrent site", "warez", "crack download", "serial key generator",
      "download paid content free", "illegal software", "piracy site", "dark web drugs",
      "buy cocaine", "buy heroin", "order weed online", "illegal marketplace",

      "deepfake celebrity", "make fake nude", "deepfake generator", "fake porn",
      "ai nsfw generator", "make porn ai", "deepfake video"
    ]));

    function classifyModeration(text) {
      if (!MOD.enabled) return { ok: true };
      const t = (text || "").trim();
      if (!t) return { ok: false, kind: "empty" };

      for (const r of (MOD.hatePatterns || [])) if (r && r.test && r.test(t)) return { ok: false, kind: "hate" };
      for (const r of (MOD.sexualPatterns || [])) if (r && r.test && r.test(t)) return { ok: false, kind: "sexual" };
      for (const r of (MOD.selfHarmPatterns || [])) if (r && r.test && r.test(t)) return { ok: false, kind: "selfharm" };
      for (const r of (MOD.violencePatterns || [])) if (r && r.test && r.test(t)) return { ok: false, kind: "violence" };
      for (const r of (MOD.hackingPatterns || [])) if (r && r.test && r.test(t)) return { ok: false, kind: "hacking" };
      for (const r of (MOD.illegalPatterns || [])) if (r && r.test && r.test(t)) return { ok: false, kind: "illegal" };

      return { ok: true };
    }

    function normalizeUsername(name) { return (name || '').trim(); }
    function isOwnerUser(name) { return normalizeUsername(name).toLowerCase() === OWNER_USERNAME; }
    function getDisplayUsername(name) {
      const normalized = normalizeUsername(name);
      return isOwnerUser(normalized) ? OWNER_DISPLAY_NAME : (normalized || 'Unknown');
    }

    // Center-of-chat text helper with variant: "info" or "mod"
    function addCenterText(content, variant = "info") {
      const message = {
        id: Date.now() + "_center",
        content,
        type: 'system',
        variant,
        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
      };
      messages.push(message);
      renderMessage(message);
      scrollToBottom();
    }

    function addSystemMessage(content) {
      addCenterText(content, "info");
    }

    // Moderation center text (red blurred style)
    function postModerationCenter(kind, whoDisplay) {
      const who = whoDisplay || "Someone";
      let msg = "ðŸš« Message blocked by moderation.";
      if (kind === "hate") msg = `ðŸš« ${who} tried to post blocked content.`;
      else if (kind === "sexual") msg = `ðŸš« ${who} tried to post blocked content.`;
      else if (kind === "selfharm") msg = `ðŸš« ${who} tried to post blocked content.`;
      else if (kind === "violence") msg = `ðŸš« ${who} tried to post blocked content.`;
      else if (kind === "hacking") msg = `ðŸš« ${who} tried to post blocked content.`;
      else if (kind === "illegal") msg = `ðŸš« ${who} tried to post blocked content.`;
      addCenterText(msg, "mod");
    }

    // Broadcast a SAFE moderation event so EVERYONE sees it (no original content)
    async function broadcastModerationEvent(kind, offenderName) {
      const who = getDisplayUsername(offenderName);
      const safeName = "Moderation";
      const safeText = `ðŸš« ${who} tried to post blocked content.`;

      try {
        await sbInsertMessage(safeName, safeText);
      } catch (e) {
        console.warn("Failed to broadcast moderation event:", e);
      }
    }


    // ------------------------------
    // Supabase helpers (load last 50 + realtime inserts)
    // ------------------------------
    async function sbInsertMessage(username, message) {
      const payload = {
        username: String(username || "").trim(),
        message: String(message || "").trim()
      };
      if (!payload.username || !payload.message) return;

      const { data, error } = await sbClient
        .from("chat_messages")
        .insert(payload)
        .select("*")
        .single();

      if (error) throw error;
      return data;
    }

    async function sbFetchRecent50() {
      const { data, error } = await sbClient
        .from("chat_messages")
        .select("*")
        .order("created_at", { ascending: false })
        .limit(50);

      if (error) throw error;
      return (data || []).reverse(); // oldest -> newest for display
    }

    function sbSubscribeRealtime(onRow) {
      const channel = sbClient
        .channel("chat_messages_stream")
        .on(
          "postgres_changes",
          { event: "INSERT", schema: "public", table: "chat_messages" },
          (payload) => {
            if (payload?.new) onRow(payload.new);
          }
        )
        .subscribe((status) => {
          console.log("Realtime status:", status);
        });

      return () => sbClient.removeChannel(channel);
    }

    // ------------------------------
    // Cloudflare helpers
    // ------------------------------
    async function cfInsertMessage(username, message) {
      if (!CHAT_API_BASE) throw new Error("Cloudflare API base not set");
      const resp = await fetch(`${CHAT_API_BASE}/chat/send`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: username, text: message })
      });
      if (resp.status === 429) {
        const errorData = await resp.json();
        throw { status: 429, message: errorData.error || "Rate limit exceeded" };
      }
      if (!resp.ok) throw new Error(`Cloudflare error: ${resp.status}`);
      const data = await resp.json();
      return data.message;
    }

    async function cfFetchRecent(limit = 50) {
      if (!CHAT_API_BASE) return [];
      try {
        const resp = await fetch(`${CHAT_API_BASE}/chat/recent?limit=${limit}`);
        if (!resp.ok) return [];
        return await resp.json();
      } catch (e) {
        // Only log if not a standard fetch failure (to reduce console noise during outages)
        if (e.name !== 'TypeError') {
          console.error("cfFetchRecent failed:", e);
        }
        throw e; // Throw so caller can detect failure
      }
    }

    function appendRowAsMessage(row) {
      appendIncomingMessage(
        {
          username: row.username,
          message: row.message,
          created_at: row.created_at,
          id: row.id
        },
        "supabase"
      );

      // Keep UI to 50 too (matches DB behavior)
      if (messages.length > 60) {
        // trim a bit above 50 to account for system messages etc
        messages = messages.slice(-60);
        renderAllMessages();
      }
    }


    // ------------------------------
    // Rendering
    // ------------------------------
    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function makeSig(name, text, id = null) {
      if (id) return `ID|${id}`;
      const n = (name || '').trim().toLowerCase();
      const x = (text || '').trim().replace(/\s+/g, ' ').toLowerCase();
      return `${n}|${x}`;
    }

    function renderMessageElement(message) {
      const messageDiv = document.createElement('div');
      messageDiv.dataset.messageId = String(message.id);

      // SYSTEM (centered)
      if (message.type === 'system') {
        messageDiv.className = 'message system' + (message.variant === "mod" ? ' mod' : '');
        messageDiv.innerHTML = `<div class="message-content">${escapeHtml(message.content)}</div>`;
        return messageDiv;
      }

      const isOwner = message.isOwner || isOwnerUser(message.username);
      const isModeration = message.username === "Moderation";
      const displayUsername = message.displayUsername || getDisplayUsername(message.username);

      messageDiv.className =
        `message ${message.isCurrentUser ? 'user' : 'other'} ` +
        `${message.isSending ? 'sending' : ''} ${message.isFailed ? 'failed' : ''} ` +
        `${isOwner ? 'owner' : ''} ${isModeration ? 'moderation' : ''}`;

      messageDiv.innerHTML = `
        <div class="message-content">
          <div class="message-header">
            <span class="message-username">${escapeHtml(displayUsername)}</span>
            <span class="message-timestamp">${escapeHtml(message.timestamp || '')}</span>
            ${message.isSending ? '<span class="sending-indicator"><i class="fas fa-circle-notch fa-spin"></i> Sending...</span>' : ''}
            ${message.isFailed ? '<span class="failed-indicator"><i class="fas fa-exclamation-triangle"></i> Failed</span>' : ''}
          </div>
          <div>${escapeHtml(message.content || '')}</div>
        </div>
      `;

      return messageDiv;
    }

    function renderMessage(message) {
      const container = document.getElementById('messagesContainer');
      const node = renderMessageElement(message);
      container.appendChild(node);
      messageNodeIndex.set(String(message.id), node);
    }

    function renderAllMessages() {
      const container = document.getElementById('messagesContainer');
      container.innerHTML = '';
      messageNodeIndex.clear();
      for (const m of messages) renderMessage(m);
    }

    function replaceRenderedMessage(oldId, newMessageObj) {
      const oldKey = String(oldId);
      const existingNode = messageNodeIndex.get(oldKey);

      const newNode = renderMessageElement(newMessageObj);
      messageNodeIndex.set(String(newMessageObj.id), newNode);

      if (existingNode && existingNode.parentNode) {
        existingNode.parentNode.replaceChild(newNode, existingNode);
        messageNodeIndex.delete(oldKey);
      } else {
        renderAllMessages();
      }
    }

    function markMessageFailed(tempId) {
      const idx = messages.findIndex(m => String(m.id) === String(tempId));
      if (idx === -1) return;
      messages[idx].isSending = false;
      messages[idx].isFailed = true;
      messages[idx].timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      replaceRenderedMessage(tempId, messages[idx]);
    }

    function markMessageSent(tempId, serverIdMaybe = null, serverTsIsoMaybe = null) {
      const idx = messages.findIndex(m => String(m.id) === String(tempId));
      if (idx === -1) return;

      const msg = messages[idx];
      msg.isSending = false;
      msg.isFailed = false;

      if (serverIdMaybe !== null && serverIdMaybe !== undefined) msg.id = serverIdMaybe;

      const ts = serverTsIsoMaybe ? new Date(serverTsIsoMaybe) : new Date();
      msg.timestamp = ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      seenSigs.add(makeSig(msg.username, msg.content, serverIdMaybe));
      replaceRenderedMessage(tempId, msg);
    }

    // ------------------------------
    // Pending/outbox reconciliation
    // ------------------------------
    function addPending(tempId, name, text) {
      pendingOutbox.push({ tempId, name, text, createdAtMs: Date.now() });
      prunePending();
    }

    function prunePending() {
      const cutoff = Date.now() - PENDING_MATCH_WINDOW_MS;
      for (let i = pendingOutbox.length - 1; i >= 0; i--) {
        if (pendingOutbox[i].createdAtMs < cutoff) pendingOutbox.splice(i, 1);
      }
    }

    function findPendingMatch(name, text) {
      prunePending();
      const n = (name || '').trim();
      const t = (text || '').trim();
      for (let i = pendingOutbox.length - 1; i >= 0; i--) {
        const p = pendingOutbox[i];
        if (p.name === n && p.text === t) return { index: i, tempId: p.tempId };
      }
      return null;
    }

    function removePendingAt(index) {
      if (index >= 0 && index < pendingOutbox.length) pendingOutbox.splice(index, 1);
    }

    // ------------------------------
    // Message ingestion (normalize CF + SB formats)
    // Includes moderation on incoming messages too
    // ------------------------------
    function appendIncomingMessage(raw, source) {
      const rawUsername = raw.name || raw.username || 'Unknown';
      const content = raw.text || raw.content || raw.message || '';
      const tsIso = raw.t || raw.created_at || null;

      // Incoming moderation: hide bad content and show mod center text
      const mod = classifyModeration(content);
      if (!mod.ok && mod.kind !== "empty") {
        const alertSig = `MOD|${mod.kind}|${rawUsername}|${makeSig(rawUsername, content, raw.id)}`;
        if (!seenSigs.has(alertSig)) {
          seenSigs.add(alertSig);
          postModerationCenter(mod.kind, getDisplayUsername(rawUsername));
        }
        return;
      }

      // If this is our own message and it matches pending, confirm instead of duplicating
      if ((rawUsername || '') === (currentUsername || '')) {
        const pending = findPendingMatch(rawUsername, content);
        if (pending) {
          const serverId = raw.id ?? null;
          markMessageSent(pending.tempId, serverId, tsIso);
          removePendingAt(pending.index);
          return;
        }
      }

      // Dedup normal messages
      const sig = makeSig(rawUsername, content, raw.id);
      if (seenSigs.has(sig)) return;
      seenSigs.add(sig);

      const displayTime = tsIso
        ? new Date(tsIso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        : new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      const msg = {
        id: raw.id || `${source}_${Date.now()}_${Math.random().toString(16).slice(2)}`,
        content,
        username: rawUsername,
        displayUsername: getDisplayUsername(rawUsername),
        isOwner: isOwnerUser(rawUsername),
        timestamp: displayTime,
        isCurrentUser: rawUsername === currentUsername,
        _source: source
      };

      messages.push(msg);
      renderMessage(msg);

      if (!msg.isCurrentUser && chatHistoryBootstrapped) {
        if (!isChatWindowOpen) {
          unreadMessageCount++;
          updateUnreadBadge();
        }
        if (notificationsEnabled) showChatNotification(msg);
      }

      scrollToBottom();
    }

    // ------------------------------
    // Bootstrap + Realtime
    // ------------------------------
    async function requestInitialSnapshot() {
      // Load last 50 on startup
      try {
        setBackendMode("cloudflare");

        const [sbMsgs, cfMsgs] = await Promise.all([
          sbFetchRecent50().catch(() => []),
          cfFetchRecent().catch(() => {
            // If CF initial fetch fails, trigger backoff immediately
            cfBackoffUntil = Date.now() + (5 * 60 * 1000); 
            console.warn("Cloudflare unavailable at startup, using Supabase fallback.");
            return [];
          })
        ]);

        const normalize = (m) => {
          const t = m.t || (m.created_at ? new Date(m.created_at).getTime() : Date.now());
          return { ...m, _t: t };
        };

        const all = [
          ...sbMsgs.map(m => ({ ...normalize(m), _src: 'supabase' })),
          ...cfMsgs.map(m => ({ ...normalize(m), _src: 'cloudflare' }))
        ];

        // Sort ascending by time
        all.sort((a, b) => a._t - b._t);

        if (all.length === 0) {
          addSystemMessage("â„¹ï¸ No recent messages found.");
        } else {
          all.forEach(m => appendIncomingMessage(m, m._src));
          addSystemMessage(`âœ… Loaded ${all.length} recent messages.`);
        }
      } catch (err) {
        console.error("requestInitialSnapshot failed:", err);
        throw err;
      }
    }

    function bootstrapChatExperience() {
      if (chatBootstrapInFlight || chatHistoryBootstrapped) return;
      chatBootstrapInFlight = true;

      addSystemMessage("ðŸ”„ Connecting to chat service...");

      requestInitialSnapshot()
        .then(() => {
          chatHistoryBootstrapped = true;
          
          // Subscribe to realtime inserts (no polling needed for Supabase)
          sbSubscribeRealtime(appendRowAsMessage);

          // Start polling for Cloudflare since it lacks realtime
          startCloudflarePolling();

          startPeriodicNotifications();
          chatBootstrapInFlight = false;
        })
        .catch(err => {
          console.error("Bootstrap failed:", err);
          addSystemMessage("âŒ Chat connection failed.");
          chatHistoryBootstrapped = true;
          startPeriodicNotifications();
          chatBootstrapInFlight = false;
        });
    }

    let cfPollingInterval = null;
    function startCloudflarePolling() {
      if (cfPollingInterval) return;
      cfPollingInterval = setInterval(async () => {
        // Skip polling if in backoff
        if (Date.now() < cfBackoffUntil) return;

        try {
          const recent = await cfFetchRecent(20);
          if (recent && Array.isArray(recent)) {
            recent.forEach(m => appendIncomingMessage(m, "cloudflare"));
          }
        } catch (e) {
          console.warn("Cloudflare poll failed:", e);
          // If polling fails, trigger a short backoff (2 minutes) to avoid spamming errors
          cfBackoffUntil = Date.now() + (2 * 60 * 1000);
        }
      }, 10000); // Poll every 10 seconds
    }

    // ------------------------------
    // Sending (CF first, SB fallback)
    // Includes moderation BEFORE sending (and broadcasts safe mod event)
    // ------------------------------
    function setBackendMode(mode) {
      if (backendMode !== mode) {
        backendMode = mode;
        console.log("ðŸ” Backend mode:", backendMode);
      }
    }

    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = (input.value || '').trim();
      if (!text || globalChatSending) return;

      const mod = classifyModeration(text);
      if (!mod.ok && mod.kind !== "empty") {
        postModerationCenter(mod.kind, getDisplayUsername(currentUsername));
        broadcastModerationEvent(mod.kind, currentUsername);
        input.value = '';
        return;
      }

      if (text.length > 750) {
        addSystemMessage('âŒ Message too long. Maximum 750 characters.');
        return;
      }

      const dedupSig = text.replace(/\s+/g, ' ').toLowerCase();
      if (dedupSig === lastGlobalChatMessageSig) {
        addSystemMessage('âŒ Duplicate message blocked.');
        return;
      }
      lastGlobalChatMessageSig = dedupSig;

      const sendButtonIcon = document.querySelector('.send-button i');
      if (!sendButtonIcon) return;

      globalChatSending = true;

      const tempMessageId = 'temp_' + Date.now();

      // clear input
      input.value = '';
      input.style.height = '44px';

      // spinner on send button
      const originalIcon = sendButtonIcon.className;
      sendButtonIcon.className = 'fas fa-spinner fa-spin';

      // optimistic bubble
      const sendingMessage = {
        id: tempMessageId,
        content: text,
        username: currentUsername,
        displayUsername: getDisplayUsername(currentUsername),
        isOwner: isOwnerUser(currentUsername),
        timestamp: 'Sending...',
        isCurrentUser: true,
        isSending: true,
        isFailed: false
      };

      messages.push(sendingMessage);
      renderMessage(sendingMessage);
      scrollToBottom();

      // track as pending so echo confirms (no duplicate)
      addPending(tempMessageId, currentUsername, text);

      try {
        let row = null;

        // Try Cloudflare first unless in backoff
        if (Date.now() > cfBackoffUntil) {
          try {
            setBackendMode("cloudflare");
            row = await cfInsertMessage(currentUsername, text);
          } catch (cfErr) {
            console.warn("Cloudflare send failed:", cfErr);
            // Switch to backoff for ANY error (429 or network failure) to avoid repeated hangs
            cfBackoffUntil = Date.now() + CF_BACKOFF_MS;
            if (cfErr.status === 429) {
              addSystemMessage("âš ï¸ Cloudflare limit reached. Switching to Supabase backup...");
            } else {
              addSystemMessage("âš ï¸ Cloudflare connection failed. Switching to Supabase backup...");
            }
          }
        }

        // Fallback to Supabase if CF failed or in backoff
        if (!row) {
          setBackendMode("supabase");
          row = await sbInsertMessage(currentUsername, text);
        }

        const serverId = row && row.id ? row.id : null;
        const serverTs = (row && (row.t || row.created_at)) ? (row.t || row.created_at) : null;

        markMessageSent(tempMessageId, serverId, serverTs);
        
        // Safety fallback: if realtime echo never arrives, remove from outbox anyway
        setTimeout(() => {
          const p = pendingOutbox.findIndex(x => x.tempId === tempMessageId);
          if (p !== -1) removePendingAt(p);
        }, 5000);
      } catch (err) {
        console.error("Send failed:", err);
        markMessageFailed(tempMessageId);

        const p = pendingOutbox.findIndex(x => x.tempId === tempMessageId);
        if (p !== -1) removePendingAt(p);

        addSystemMessage('âŒ Failed to send message.');
      } finally {
        sendButtonIcon.className = originalIcon;
        globalChatSending = false;
      }
    }

    // ------------------------------
    // UX utilities
    // ------------------------------
    function scrollToBottom() {
      if (shouldAutoScroll) {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
      }
    }

    function handleScroll() {
      const container = document.getElementById('messagesContainer');
      if (!container) return;

      const currentScrollTop = container.scrollTop;
      const maxScrollTop = container.scrollHeight - container.clientHeight;

      if (currentScrollTop >= maxScrollTop - 50) {
        shouldAutoScroll = true;
      } else if (lastScrollTop > currentScrollTop && currentScrollTop < maxScrollTop - 100) {
        shouldAutoScroll = false;
      }

      lastScrollTop = currentScrollTop;
    }

    function handleKeyPress(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
      const textarea = event.target;
      textarea.style.height = '44px';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      const icon = document.getElementById('soundIcon');
      if (soundEnabled) {
        icon.className = 'fas fa-volume-up';
        addSystemMessage('ðŸ”Š Sound notifications enabled');
      } else {
        icon.className = 'fas fa-volume-mute';
        addSystemMessage('ðŸ”‡ Sound notifications disabled');
      }
    }

    function clearMessages() {
      if (confirm('Clear all messages?')) {
        messages = [];
        seenSigs.clear();
        pendingOutbox.length = 0;
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';
        messageNodeIndex.clear();
        addSystemMessage('ðŸ§¹ Chat cleared');
      }
    }

    function updateUnreadBadge() {
      try {
        window.parent.postMessage({
          type: 'updateChatBadge',
          count: unreadMessageCount,
          show: unreadMessageCount > 0
        }, '*');
      } catch {}
    }

    function showChatNotification(message) {
      if (notificationsEnabled && !isChatWindowOpen) {
        try {
          window.parent.postMessage({
            type: 'showChatNotification',
            username: message.displayUsername || getDisplayUsername(message.username),
            content: (message.content || '').substring(0, 50) + ((message.content || '').length > 50 ? '...' : '')
          }, '*');
        } catch {}
      }
    }

    function resetUnreadCount() {
      unreadMessageCount = 0;
      updateUnreadBadge();
    }

    function startPeriodicNotifications() {
      if (periodicNotificationsStarted) return;
      periodicNotificationsStarted = true;

      setInterval(() => {
        if (notificationsEnabled && !isChatWindowOpen) {
          try {
            window.parent.postMessage({
              type: 'showChatNotification',
              username: 'System',
              content: 'There are new messages in Global Chat!'
            }, '*');
          } catch {}
        }
      }, 300000);
    }

    function updateOnlineCount() {
      const fakeCount = Math.floor(Math.random() * 18) + 8;
      const onlineCountElement = document.querySelector('.online-count');
      if (onlineCountElement) onlineCountElement.textContent = fakeCount;
    }

    function getApiBaseFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      const urlApiBase = urlParams.get('apiBase');
      const urlUsername = urlParams.get('username');
      if (urlApiBase) CHAT_API_BASE = urlApiBase;
      if (urlUsername) currentUsername = urlUsername;
    }

    function initChat() {
      getApiBaseFromUrl();

      window.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'initChat') {
          currentUsername = event.data.username || currentUsername || 'User';
          if (event.data.chatApiBase) CHAT_API_BASE = event.data.chatApiBase;
          bootstrapChatExperience();
        } else if (event.data && event.data.type === 'chatOpened') {
          resetUnreadCount();
          isChatWindowOpen = true;

          if (!onlineCountIntervalStarted) {
            onlineCountIntervalStarted = true;
            updateOnlineCount();
            setInterval(updateOnlineCount, 30000);
          }
        } else if (event.data && event.data.type === 'chatClosed') {
          isChatWindowOpen = false;
        } else if (event.data && event.data.type === 'toggleNotifications') {
          notificationsEnabled = !!event.data.enabled;
          console.log('Chat notifications ' + (notificationsEnabled ? 'enabled' : 'disabled'));
        }
      });

      setTimeout(() => {
        bootstrapChatExperience();
      }, 500);
    }

    document.addEventListener('DOMContentLoaded', function() {
      console.log('Chat iframe DOM loaded, initializing...');
      initChat();

      const messagesContainer = document.getElementById('messagesContainer');
      if (messagesContainer) {
        messagesContainer.addEventListener('scroll', handleScroll);
        lastScrollTop = messagesContainer.scrollTop;
        setTimeout(scrollToBottom, 500);
      }

      setTimeout(updateUnreadBadge, 1000);
    });
  </script>
</body>
</html>
