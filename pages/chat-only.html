<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Global Chat - NautilusOS</title>
  <meta name="description" content="NautilusOS Global Chat - Connect and chat with the community.">
  <meta name="keywords" content="chat, community, NautilusOS">
  <meta name="author" content="NautilusOS">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link rel="stylesheet" href="https://unpkg.com/open-props">
  <link rel="stylesheet" href="https://unpkg.com/open-props/normalize.min.css">
  <link rel="stylesheet" href="https://unpkg.com/open-props/buttons.min.css">

  <style>
    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --accent: #7dd3c0;
      --accent-hover: #5bb98c;
      --border: rgba(255, 255, 255, 0.1);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --info: #3b82f6;
      --owner-text: #2b1b05;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--bg-primary);
    }

    .chat-header {
      background: rgba(30, 35, 48, 0.9);
      border-bottom: 1px solid var(--border);
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .chat-title {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1rem;
    }

    .online-count {
      background: rgba(125, 211, 192, 0.2);
      color: var(--accent);
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
      min-width: 24px;
      text-align: center;
    }

    .chat-title i { color: var(--accent); font-size: 1.1rem; }
    .chat-actions { display: flex; gap: 5px; }

    .chat-action-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 32px;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .chat-action-btn:hover {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border-color: var(--accent);
    }

    .chat-content { flex: 1; display: block; overflow: hidden; height: 100%; }

    .messages-area {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: rgba(15, 18, 25, 0.6);
    }

    .messages-container {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 100%;
    }

    .message { display: flex; margin-bottom: 8px; }

    /* Center messages (we use this for moderation notices too) */
    .message.system { justify-content: center; }
    .message.system .message-content {
      background: rgba(125, 211, 192, 0.1);
      border: 1px solid rgba(125, 211, 192, 0.2);
      border-radius: 12px;
      padding: 8px 12px;
      text-align: center;
      font-size: 0.85rem;
      color: var(--accent);
      max-width: 70%;
    }

    .message.user { justify-content: flex-end; }
    .message.other { justify-content: flex-start; }

    .message-content {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 0.9rem;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .message.user .message-content {
      background: var(--accent);
      color: var(--bg-primary);
      border-bottom-right-radius: 4px;
    }

    .message.other .message-content {
      background: rgba(30, 35, 48, 0.8);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
    }

    .message.owner .message-content {
      background: linear-gradient(135deg, #f7dc8b, #f0b64b);
      color: var(--owner-text);
      border: 1px solid rgba(255, 222, 138, 0.9);
      box-shadow: 0 0 0 1px rgba(255, 215, 120, 0.6);
      position: relative;
      isolation: isolate;
    }

    .message.owner .message-content::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 18px;
      border: 1px solid rgba(255, 236, 170, 0.7);
      pointer-events: none;
      z-index: 0;
    }

    .message.owner .message-content > * { position: relative; z-index: 1; }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }

    .message.user .message-header { justify-content: flex-end; }
    .message.other .message-header { justify-content: flex-start; }

    .message-username { font-weight: 600; color: var(--accent); }
    .message.user .message-username { color: var(--bg-primary); }
    .message.owner .message-username { color: #111; }

    .message-timestamp { color: var(--text-secondary); font-size: 0.75rem; }
    .message.user .message-timestamp { color: rgba(15, 23, 42, 0.7); }
    .message.owner .message-timestamp { color: rgba(66, 45, 8, 0.75); }

    .message.sending .message-content {
      opacity: 0.85;
      border: 1px solid rgba(251, 191, 36, 0.3);
    }

    .message.failed .message-content {
      opacity: 0.75;
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.1);
    }

    .sending-indicator, .failed-indicator {
      margin-left: 8px;
      font-size: 0.8rem;
      opacity: 0.9;
      white-space: nowrap;
    }

    .sending-indicator { color: #f59e0b; }
    .failed-indicator { color: #ef4444; }
    .sending-indicator i { margin-right: 4px; }

    .input-area {
      background: rgba(21, 25, 35, 0.9);
      border-top: 1px solid var(--border);
      padding: 16px;
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .message-input {
      flex: 1;
      padding: 12px 16px;
      background: rgba(30, 35, 48, 0.8);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.9rem;
      resize: none;
      min-height: 44px;
      max-height: 120px;
      transition: all 0.2s ease;
    }

    .message-input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(30, 35, 48, 0.95);
    }

    .message-input::placeholder { color: var(--text-muted); }

    .send-button {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      border: none;
      border-radius: 12px;
      color: var(--bg-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    .send-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(125, 211, 192, 0.3);
    }

    .send-button:active { transform: translateY(0); }

    .messages-container::-webkit-scrollbar { width: 6px; }
    .messages-container::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 3px; }
    .messages-container::-webkit-scrollbar-thumb { background: rgba(125, 211, 192, 0.3); border-radius: 3px; }
    .messages-container::-webkit-scrollbar-thumb:hover { background: rgba(125, 211, 192, 0.5); }

    @media (max-width: 768px) {
      .message-content { max-width: 85%; }
    }
  </style>
</head>

<body>
  <div class="chat-container">
    <div class="chat-header">
      <div class="chat-title">
        <i class="fas fa-comments"></i>
        <span class="online-count">12</span> online
      </div>
      <div class="chat-actions">
        <button class="chat-action-btn" onclick="toggleSound()" title="Toggle Sound">
          <i class="fas fa-volume-up" id="soundIcon"></i>
        </button>
        <button class="chat-action-btn" onclick="clearMessages()" title="Clear Chat">
          <i class="fas fa-trash"></i>
        </button>
      </div>
    </div>

    <div class="chat-content">
      <div class="messages-area">
        <div class="messages-container" id="messagesContainer"></div>
      </div>
    </div>

    <div class="input-area">
      <textarea
        class="message-input"
        id="messageInput"
        placeholder="Type your message..."
        onkeydown="handleKeyPress(event)"
        maxlength="750"
      ></textarea>
      <button class="send-button" onclick="sendMessage()">
        <i class="fas fa-paper-plane"></i>
      </button>
    </div>
  </div>

  <!-- Supabase client library (defines window.supabase). -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    // =====================================================
    // GLOBAL CHAT - CLOUDFLARE (PRIMARY) + SUPABASE (FALLBACK)
    // + Moderation (center-of-chat text only, NO OS-style notifications)
    // + Sending animation + reconcile (no double messages)
    // =====================================================

    // Cloudflare Worker base (set by parent window or URL param)
    let CHAT_API_BASE = null;

    // Supabase (browser-safe anon/publishable key)
    const SUPABASE_URL = "https://bvhigzazfcsoqeivnmxe.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_DMZNbwUB_8qvQRTtl5xS5g_OMdvEZdQ";
    const SUPABASE_TABLE = "chat_messages";

    // IMPORTANT: do NOT name this "supabase" (Nebulo likely already has a global)
    const sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Cloudflare circuit breaker (rate-limit backoff)
    let cfBackoffUntil = 0;
    const CF_BACKOFF_MS = 10 * 60 * 1000; // 10 minutes

    // Chat state
    let currentUsername = 'User';
    let messages = [];
    let soundEnabled = true;
    let notificationsEnabled = true; // kept for your normal chat notifications (not used for moderation)
    let globalChatSending = false;

    // Unread / window state
    let unreadMessageCount = 0;
    let isChatWindowOpen = false;

    // Bootstrap / UI flags
    let chatBootstrapInFlight = false;
    let periodicNotificationsStarted = false;
    let onlineCountIntervalStarted = false;
    let chatHistoryBootstrapped = false;
    let shouldAutoScroll = true;
    let lastScrollTop = 0;

    // Backend mode tracking
    let backendMode = "unknown"; // "cloudflare" | "supabase" | "unknown"
    let lastGlobalChatMessageSig = "";

    // Dedup + DOM tracking
    const seenSigs = new Set();         // dedupe of rendered messages (signature)
    const messageNodeIndex = new Map(); // messageId -> DOM node

    // Pending "sending" reconciliation (prevents duplicate popups)
    const pendingOutbox = []; // [{tempId, name, text, createdAtMs}]
    const PENDING_MATCH_WINDOW_MS = 60 * 1000; // confirm within 60s

    const OWNER_USERNAME = 'shs12lord';
    const OWNER_DISPLAY_NAME = 'Owner';

    // ------------------------------
    // MODERATION
    //  - Works on SEND (blocks message)
    //  - Works on RECEIVE (hides message + shows centered notice)
    //  - IMPORTANT: moderation notices are NOT OS notifications, only centered chat text.
    // ------------------------------

    // Helper: safely make a regex that matches any of these words/phrases (word-boundary based).
    function buildWordRegex(words) {
      const escaped = (words || []).map(w => String(w).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
      return new RegExp(`\\b(${escaped.join("|")})\\b`, "i");
    }

    const MOD = {
      enabled: true,

      // Hate/racism patterns (keep yours)
      hatePatterns: [
        /\b(white\s*power|heil\s*hitler|ku\s*klux\s*klan|kkk|1488|14\/88|nigger|nigga)\b/i,
        /\b(go\s+back\s+to\s+your\s+country)\b/i,
        /\b(kill|exterminate|lynch|gas)\s+(all|every)\s+(black|white|asian|mexican|latino|jewish|muslim|christian|immigrant)s?\b/i,
        /\b(all|every)\s+(black|white|asian|mexican|latino|jewish|muslim|christian|immigrant)s?\s+(should|must)\s+(die|be\s+killed|be\s+gone)\b/i
      ],

      // Everything else built from lists
      sexualPatterns: [],
      selfHarmPatterns: [],
      violencePatterns: [],
      hackingPatterns: [],
      illegalPatterns: []
    };

    // Add your provided list into the right buckets
    MOD.sexualPatterns.push(buildWordRegex([
      "porn", "xxx", "hentai", "fetish", "erotic", "milf", "bdsm", "cam", "webcam",
      "nude", "nudity", "boobs", "tits", "pussy", "anal", "cum", "blowjob", "jav",
      "incest", "amateur", "softcore", "goon", "daddy", "diddy", "gooner", "ballsack",
      "oil", "gay", "lesbian", "shemale", "trans", "balls", "gaping", "creampie", "threesome",
      "o!l", "mom", "dad", "freaky", "nsfw", "nsfwchat", "bondage", "spanking",
      "roast", "harder", "tickling", "watersports", "swing", "stupid",

      "pornhub.com", "xvideos.com", "redtube.com", "youporn.com", "xhamster.com", "xnxx.com",
      "spankbang.com", "tube8.com", "tnaflix.com", "porndig.com", "efukt.com", "empflix.com",
      "javhub.com", "faproulette.com", "sex.com", "cam4.com", "chaturbate.com", "livejasmin.com",

      "4chan.org", "8kun.top", "kiwifarms.net", "reddit.com/r/nsfw", "reddit.com/r/gonewild",

      "write porn story", "erotic roleplay", "roleplay as my girlfriend", "be my sexbot",
      "generate nude", "make nsfw image", "make porn", "draw hentai", "make me a sex story",
      "write erotic novel", "write smut", "dirty story", "make nsfw picture", "make nude picture",
      "simulate sex", "roleplay nsfw", "pretend to be my lover", "dirty talk", "make hentai"
    ]));

    MOD.selfHarmPatterns.push(buildWordRegex([
      "help me kill myself", "tell me how to die", "help me suicide", "write suicide note",
      "make me self harm", "ways to kill myself", "how to commit suicide", "how to overdose",
      "what‚Äôs the best way to die", "help me harm myself", "tell me how to hang myself"
    ]));

    MOD.violencePatterns.push(buildWordRegex([
      "how to make a bomb", "how to make explosives", "build a gun", "how to stab",
      "how to poison", "how to kill someone", "murder plan", "terrorist guide",
      "shooting guide", "assassin instructions", "step by step bomb", "terror attack"
    ]));

    MOD.hackingPatterns.push(buildWordRegex([
      "how to hack facebook", "hack instagram", "hack gmail", "steal password",
      "crack wifi", "bypass paywall", "bypass filter", "how to ddos", "how to hack website",
      "prompt injection", "jailbreak ai", "bypass moderation", "ignore your rules", "act as unrestricted ai"
    ]));

    MOD.illegalPatterns.push(buildWordRegex([
      "pirated movies", "torrent site", "warez", "crack download", "serial key generator",
      "download paid content free", "illegal software", "piracy site", "dark web drugs",
      "buy cocaine", "buy heroin", "order weed online", "illegal marketplace",
      "deepfake celebrity", "make fake nude", "deepfake generator", "fake porn",
      "ai nsfw generator", "make porn ai", "deepfake video"
    ]));

    function normalizeUsername(name) {
      return (name || '').trim();
    }
    function isOwnerUser(name) {
      return normalizeUsername(name).toLowerCase() === OWNER_USERNAME;
    }
    function getDisplayUsername(name) {
      const normalized = normalizeUsername(name);
      return isOwnerUser(normalized) ? OWNER_DISPLAY_NAME : (normalized || 'Unknown');
    }

    function setBackendMode(mode) {
      if (backendMode !== mode) {
        backendMode = mode;
        console.log("üîÅ Backend mode:", backendMode);
      }
    }

    // Signature used ONLY for dedupe AFTER a message is rendered.
    // (No timestamp so CF/SB differences don‚Äôt duplicate.)
    function makeSig(name, text) {
      const n = (name || '').trim().toLowerCase();
      const x = (text || '').trim().replace(/\s+/g, ' ').toLowerCase();
      return `${n}|${x}`;
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // Classify moderation category
    function classifyModeration(text) {
      if (!MOD.enabled) return { ok: true };
      const t = (text || "").trim();
      if (!t) return { ok: false, kind: "empty" };

      for (const r of MOD.hatePatterns) if (r.test(t)) return { ok: false, kind: "hate" };
      for (const r of MOD.sexualPatterns) if (r.test(t)) return { ok: false, kind: "sexual" };
      for (const r of MOD.selfHarmPatterns) if (r.test(t)) return { ok: false, kind: "selfharm" };
      for (const r of MOD.violencePatterns) if (r.test(t)) return { ok: false, kind: "violence" };
      for (const r of MOD.hackingPatterns) if (r.test(t)) return { ok: false, kind: "hacking" };
      for (const r of MOD.illegalPatterns) if (r.test(t)) return { ok: false, kind: "illegal" };

      return { ok: true };
    }

    // Center-of-chat moderation text (NOT an OS notification)
    function postModerationCenter(kind, whoDisplay) {
      const who = whoDisplay || "Someone";
      let msg = "üö´ Message blocked by moderation.";

      if (kind === "hate") msg = `üò° ${who} tried to be racist.`;
      else if (kind === "sexual") msg = `üö´ ${who} tried to post sexual content.`;
      else if (kind === "selfharm") msg = `üö´ ${who} tried to post self-harm content.`;
      else if (kind === "violence") msg = `üö´ ${who} tried to post violent instructions.`;
      else if (kind === "hacking") msg = `üö´ ${who} tried to post hacking content.`;
      else if (kind === "illegal") msg = `üö´ ${who} tried to post illegal content.`;

      addCenterText(msg);
    }

    // Center-of-chat text helper (uses same centered style as system messages,
    // but we keep it separate so it‚Äôs not tied to any "notification" behavior)
    function addCenterText(content) {
      const message = {
        id: Date.now() + "_center",
        content,
        type: 'system',
        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
      };
      messages.push(message);
      renderMessage(message);
      scrollToBottom();
    }

    // ------------------------------
    // Cloudflare helpers (with backoff on rate limits)
    // ------------------------------
    async function cfFetchRecent(limit = 10) {
      if (!CHAT_API_BASE) throw new Error("CHAT_API_BASE not set");

      const res = await fetch(`${CHAT_API_BASE}/chat/recent?limit=${limit}&images=1`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        mode: 'cors'
      });

      if (res.status === 429 || res.status === 503 || res.status === 520 || res.status === 522 || res.status === 403) {
        cfBackoffUntil = Date.now() + CF_BACKOFF_MS;
        throw new Error(`Cloudflare rate-limited/unavailable (HTTP ${res.status})`);
      }

      if (!res.ok) throw new Error(`CF recent HTTP ${res.status}`);
      return await res.json();
    }

    async function cfSendMessage(name, text) {
      if (!CHAT_API_BASE) throw new Error("CHAT_API_BASE not set");

      const res = await fetch(`${CHAT_API_BASE}/chat/send`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        mode: 'cors',
        body: JSON.stringify({ name, text })
      });

      if (res.status === 429 || res.status === 503 || res.status === 520 || res.status === 522 || res.status === 403) {
        cfBackoffUntil = Date.now() + CF_BACKOFF_MS;
        throw new Error(`Cloudflare rate-limited/unavailable (HTTP ${res.status})`);
      }

      if (!res.ok) throw new Error(`CF send HTTP ${res.status}`);
      return true;
    }

    async function checkCloudflareHealthy() {
      if (!CHAT_API_BASE) return false;
      if (Date.now() < cfBackoffUntil) return false;

      try {
        await cfFetchRecent(1);
        return true;
      } catch {
        return false;
      }
    }

    // ------------------------------
    // Supabase helpers (robust ordering: try t, then created_at)
    // ------------------------------
    async function sbInsertMessage(name, text) {
      const payload = { name, text };
      const { data, error } = await sbClient
        .from(SUPABASE_TABLE)
        .insert(payload)
        .select()
        .limit(1);

      if (error) throw error;
      return data && data[0] ? data[0] : null;
    }

    async function sbFetchRecent(limit = 10) {
      let { data, error } = await sbClient
        .from(SUPABASE_TABLE)
        .select("*")
        .order("t", { ascending: false })
        .limit(limit);

      if (error) {
        ({ data, error } = await sbClient
          .from(SUPABASE_TABLE)
          .select("*")
          .order("created_at", { ascending: false })
          .limit(limit));
      }

      if (error) throw error;
      return (data || []).reverse();
    }

    // ------------------------------
    // Rendering
    // ------------------------------
    function renderMessageElement(message) {
      const messageDiv = document.createElement('div');
      messageDiv.dataset.messageId = String(message.id);

      if (message.type === 'system') {
        messageDiv.className = 'message system';
        messageDiv.innerHTML = `<div class="message-content">${message.content}</div>`;
        return messageDiv;
      }

      const isOwner = message.isOwner || isOwnerUser(message.username);
      const displayUsername = message.displayUsername || getDisplayUsername(message.username);

      messageDiv.className =
        `message ${message.isCurrentUser ? 'user' : 'other'} ` +
        `${message.isSending ? 'sending' : ''} ${message.isFailed ? 'failed' : ''} ` +
        `${isOwner ? 'owner' : ''}`;

      messageDiv.innerHTML = `
        <div class="message-content">
          <div class="message-header">
            <span class="message-username">${escapeHtml(displayUsername)}</span>
            <span class="message-timestamp">${escapeHtml(message.timestamp || '')}</span>
            ${message.isSending ? '<span class="sending-indicator"><i class="fas fa-circle-notch fa-spin"></i> Sending...</span>' : ''}
            ${message.isFailed ? '<span class="failed-indicator"><i class="fas fa-exclamation-triangle"></i> Failed</span>' : ''}
          </div>
          <div>${escapeHtml(message.content || '')}</div>
        </div>
      `;

      return messageDiv;
    }

    function renderMessage(message) {
      const container = document.getElementById('messagesContainer');
      const node = renderMessageElement(message);
      container.appendChild(node);
      messageNodeIndex.set(String(message.id), node);
    }

    function replaceRenderedMessage(oldId, newMessageObj) {
      const oldKey = String(oldId);
      const existingNode = messageNodeIndex.get(oldKey);

      const newNode = renderMessageElement(newMessageObj);
      messageNodeIndex.set(String(newMessageObj.id), newNode);

      if (existingNode && existingNode.parentNode) {
        existingNode.parentNode.replaceChild(newNode, existingNode);
        messageNodeIndex.delete(oldKey);
      } else {
        renderAllMessages();
      }
    }

    function renderAllMessages() {
      const container = document.getElementById('messagesContainer');
      container.innerHTML = '';
      messageNodeIndex.clear();
      for (const m of messages) renderMessage(m);
    }

    function addSystemMessage(content) {
      // Used for non-moderation system info ("Connected", etc.)
      addCenterText(content);
    }

    function markMessageFailed(tempId) {
      const idx = messages.findIndex(m => String(m.id) === String(tempId));
      if (idx === -1) return;
      messages[idx].isSending = false;
      messages[idx].isFailed = true;
      messages[idx].timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      replaceRenderedMessage(tempId, messages[idx]);
    }

    function markMessageSent(tempId, serverIdMaybe = null, serverTsIsoMaybe = null) {
      const idx = messages.findIndex(m => String(m.id) === String(tempId));
      if (idx === -1) return;

      const msg = messages[idx];
      msg.isSending = false;
      msg.isFailed = false;

      if (serverIdMaybe !== null && serverIdMaybe !== undefined) msg.id = serverIdMaybe;

      const ts = serverTsIsoMaybe ? new Date(serverTsIsoMaybe) : new Date();
      msg.timestamp = ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      seenSigs.add(makeSig(msg.username, msg.content));
      replaceRenderedMessage(tempId, msg);
    }

    // ------------------------------
    // Pending/outbox reconciliation
    // ------------------------------
    function addPending(tempId, name, text) {
      pendingOutbox.push({ tempId, name, text, createdAtMs: Date.now() });
      prunePending();
    }

    function prunePending() {
      const cutoff = Date.now() - PENDING_MATCH_WINDOW_MS;
      for (let i = pendingOutbox.length - 1; i >= 0; i--) {
        if (pendingOutbox[i].createdAtMs < cutoff) pendingOutbox.splice(i, 1);
      }
    }

    function findPendingMatch(name, text) {
      prunePending();
      const n = (name || '').trim();
      const t = (text || '').trim();
      for (let i = pendingOutbox.length - 1; i >= 0; i--) {
        const p = pendingOutbox[i];
        if (p.name === n && p.text === t) return { index: i, tempId: p.tempId };
      }
      return null;
    }

    function removePendingAt(index) {
      if (index >= 0 && index < pendingOutbox.length) pendingOutbox.splice(index, 1);
    }

    // ------------------------------
    // Message ingestion (normalize CF + SB formats)
    // Includes moderation on incoming messages too
    // ------------------------------
    function appendIncomingMessage(raw, source) {
      const rawUsername = raw.name || raw.username || 'Unknown';
      const content = raw.text || raw.content || '';
      const tsIso = raw.t || raw.created_at || null;

      // Incoming moderation: hide bad content and show center text
      const mod = classifyModeration(content);
      if (!mod.ok && mod.kind !== "empty") {
        const alertSig = `MOD|${mod.kind}|${rawUsername}|${makeSig(rawUsername, content)}`;
        if (!seenSigs.has(alertSig)) {
          seenSigs.add(alertSig);
          postModerationCenter(mod.kind, getDisplayUsername(rawUsername));
        }
        return;
      }

      // If this is our own message and it matches pending, confirm instead of duplicating
      if ((rawUsername || '') === (currentUsername || '')) {
        const pending = findPendingMatch(rawUsername, content);
        if (pending) {
          const serverId = raw.id ?? null;
          markMessageSent(pending.tempId, serverId, tsIso);
          removePendingAt(pending.index);
          return;
        }
      }

      // Dedup normal messages
      const sig = makeSig(rawUsername, content);
      if (seenSigs.has(sig)) return;
      seenSigs.add(sig);

      const displayTime = tsIso
        ? new Date(tsIso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        : new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      const msg = {
        id: raw.id || `${source}_${Date.now()}_${Math.random().toString(16).slice(2)}`,
        content,
        username: rawUsername,
        displayUsername: getDisplayUsername(rawUsername),
        isOwner: isOwnerUser(rawUsername),
        timestamp: displayTime,
        isCurrentUser: rawUsername === currentUsername,
        _source: source
      };

      messages.push(msg);
      renderMessage(msg);

      if (!msg.isCurrentUser && chatHistoryBootstrapped) {
        if (!isChatWindowOpen) {
          unreadMessageCount++;
          updateUnreadBadge();
        }
        // Normal notifications still allowed (NOT moderation notices)
        if (notificationsEnabled) showChatNotification(msg);
      }

      scrollToBottom();
    }

    // ------------------------------
    // Bootstrap + polling
    // ------------------------------
    async function requestInitialSnapshot() {
      const cfOk = await checkCloudflareHealthy();
      if (cfOk) {
        setBackendMode("cloudflare");
        addSystemMessage("‚úÖ Connected (Cloudflare).");
        const cfMsgs = await cfFetchRecent(50);
        (cfMsgs || []).forEach(m => appendIncomingMessage(m, "cloudflare"));
        return;
      }

      setBackendMode("supabase");
      addSystemMessage("‚ö†Ô∏è Cloudflare unavailable/rate-limited. Using Supabase backup.");
      const sbMsgs = await sbFetchRecent(50);
      (sbMsgs || []).forEach(m => appendIncomingMessage(m, "supabase"));
    }

    function startPolling() {
      setInterval(async () => {
        try {
          const cfOk = await checkCloudflareHealthy();
          if (cfOk) {
            setBackendMode("cloudflare");
            const cfMsgs = await cfFetchRecent(10);
            (cfMsgs || []).forEach(m => appendIncomingMessage(m, "cloudflare"));
          } else {
            setBackendMode("supabase");
            const sbMsgs = await sbFetchRecent(10);
            (sbMsgs || []).forEach(m => appendIncomingMessage(m, "supabase"));
          }
        } catch (err) {
          console.error("Polling error:", err);
        }
      }, 5000);
    }

    function bootstrapChatExperience() {
      if (chatBootstrapInFlight || chatHistoryBootstrapped) return;
      chatBootstrapInFlight = true;

      addSystemMessage("üîÑ Connecting to chat service...");

      requestInitialSnapshot()
        .then(() => {
          chatHistoryBootstrapped = true;
          startPolling();
          startPeriodicNotifications();
          chatBootstrapInFlight = false;
        })
        .catch(err => {
          console.error("Bootstrap failed:", err);
          addSystemMessage("‚ùå Chat connection failed (both backends).");
          chatHistoryBootstrapped = true;
          startPeriodicNotifications();
          chatBootstrapInFlight = false;
        });
    }

    // ------------------------------
    // Sending (CF first, SB fallback)
    // Includes moderation BEFORE sending
    // Moderation result is only a centered chat line (no popup notifications)
    // ------------------------------
    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = (input.value || '').trim();
      if (!text || globalChatSending) return;

      // MODERATION CHECK (on send)
      const mod = classifyModeration(text);
      if (!mod.ok && mod.kind !== "empty") {
        // Center text saying they tried to post something bad
        postModerationCenter(mod.kind, getDisplayUsername(currentUsername));
        // Also give the sender a centered hint (not a popup)
        addCenterText("üö´ Your message was blocked by moderation.");
        input.focus();
        return;
      }

      if (text.length > 750) {
        addSystemMessage('‚ùå Message too long. Maximum 750 characters.');
        return;
      }

      const dedupSig = text.replace(/\s+/g, ' ').toLowerCase();
      if (dedupSig === lastGlobalChatMessageSig) {
        addSystemMessage('‚ùå Duplicate message blocked.');
        return;
      }
      lastGlobalChatMessageSig = dedupSig;

      const sendButtonIcon = document.querySelector('.send-button i');
      if (!sendButtonIcon) return;

      globalChatSending = true;

      const tempMessageId = 'temp_' + Date.now();

      // clear input
      input.value = '';
      input.style.height = '44px';

      // spinner on send button
      const originalIcon = sendButtonIcon.className;
      sendButtonIcon.className = 'fas fa-spinner fa-spin';

      // optimistic message bubble (shows sending animation)
      const sendingMessage = {
        id: tempMessageId,
        content: text,
        username: currentUsername,
        displayUsername: getDisplayUsername(currentUsername),
        isOwner: isOwnerUser(currentUsername),
        timestamp: 'Sending...',
        isCurrentUser: true,
        isSending: true,
        isFailed: false
      };

      messages.push(sendingMessage);
      renderMessage(sendingMessage);
      scrollToBottom();

      // track as pending so CF/SB echo confirms (no duplicate bubble)
      addPending(tempMessageId, currentUsername, text);

      try {
        const cfOk = await checkCloudflareHealthy();

        if (cfOk) {
          setBackendMode("cloudflare");
          await cfSendMessage(currentUsername, text);

          // Stop spinner ONLY when echoed back via polling.
          // Safety: if echo doesn't arrive fast, mark as sent locally after 8s.
          setTimeout(() => {
            const idx = messages.findIndex(m => String(m.id) === String(tempMessageId));
            if (idx !== -1 && messages[idx].isSending) {
              markMessageSent(tempMessageId, null, null);
              const p = pendingOutbox.findIndex(x => x.tempId === tempMessageId);
              if (p !== -1) removePendingAt(p);
            }
          }, 8000);

        } else {
          setBackendMode("supabase");
          const row = await sbInsertMessage(currentUsername, text);

          const serverId = row && row.id ? row.id : null;
          const serverTs = (row && (row.t || row.created_at)) ? (row.t || row.created_at) : null;

          markMessageSent(tempMessageId, serverId, serverTs);

          const p = pendingOutbox.findIndex(x => x.tempId === tempMessageId);
          if (p !== -1) removePendingAt(p);

          addSystemMessage('‚ö†Ô∏è Sent via Supabase backup (Cloudflare rate-limited/down).');
        }

      } catch (err) {
        console.error("Send failed:", err);

        try {
          setBackendMode("supabase");
          const row = await sbInsertMessage(currentUsername, text);

          const serverId = row && row.id ? row.id : null;
          const serverTs = (row && (row.t || row.created_at)) ? (row.t || row.created_at) : null;

          markMessageSent(tempMessageId, serverId, serverTs);

          const p = pendingOutbox.findIndex(x => x.tempId === tempMessageId);
          if (p !== -1) removePendingAt(p);

          addSystemMessage('‚ö†Ô∏è Cloudflare send failed. Saved to Supabase backup.');
        } catch (err2) {
          console.error("Supabase fallback send failed:", err2);

          markMessageFailed(tempMessageId);

          const p = pendingOutbox.findIndex(x => x.tempId === tempMessageId);
          if (p !== -1) removePendingAt(p);

          addSystemMessage('‚ùå Failed to send message (both backends).');
        }
      } finally {
        sendButtonIcon.className = originalIcon;
        globalChatSending = false;
      }
    }

    // ------------------------------
    // UX utilities
    // ------------------------------
    function scrollToBottom() {
      if (shouldAutoScroll) {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
      }
    }

    function handleScroll() {
      const container = document.getElementById('messagesContainer');
      if (!container) return;

      const currentScrollTop = container.scrollTop;
      const maxScrollTop = container.scrollHeight - container.clientHeight;

      if (currentScrollTop >= maxScrollTop - 50) {
        shouldAutoScroll = true;
      } else if (lastScrollTop > currentScrollTop && currentScrollTop < maxScrollTop - 100) {
        shouldAutoScroll = false;
      }

      lastScrollTop = currentScrollTop;
    }

    function handleKeyPress(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
      const textarea = event.target;
      textarea.style.height = '44px';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      const icon = document.getElementById('soundIcon');
      if (soundEnabled) {
        icon.className = 'fas fa-volume-up';
        addSystemMessage('üîä Sound notifications enabled');
      } else {
        icon.className = 'fas fa-volume-mute';
        addSystemMessage('üîá Sound notifications disabled');
      }
    }

    function clearMessages() {
      if (confirm('Clear all messages?')) {
        messages = [];
        seenSigs.clear();
        pendingOutbox.length = 0;
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';
        messageNodeIndex.clear();
        addSystemMessage('üßπ Chat cleared');
      }
    }

    function updateUnreadBadge() {
      try {
        window.parent.postMessage({
          type: 'updateChatBadge',
          count: unreadMessageCount,
          show: unreadMessageCount > 0
        }, '*');
      } catch {}
    }

    // Normal chat notifications (NOT used for moderation notices)
    function showChatNotification(message) {
      if (notificationsEnabled && !isChatWindowOpen) {
        try {
          window.parent.postMessage({
            type: 'showChatNotification',
            username: message.displayUsername || getDisplayUsername(message.username),
            content: (message.content || '').substring(0, 50) + ((message.content || '').length > 50 ? '...' : '')
          }, '*');
        } catch {}
      }
    }

    function resetUnreadCount() {
      unreadMessageCount = 0;
      updateUnreadBadge();
    }

    function startPeriodicNotifications() {
      if (periodicNotificationsStarted) return;
      periodicNotificationsStarted = true;

      setInterval(() => {
        if (notificationsEnabled && !isChatWindowOpen) {
          try {
            window.parent.postMessage({
              type: 'showChatNotification',
              username: 'System',
              content: 'There are new messages in Global Chat!'
            }, '*');
          } catch {}
        }
      }, 300000);
    }

    function updateOnlineCount() {
      const fakeCount = Math.floor(Math.random() * 18) + 8;
      const onlineCountElement = document.querySelector('.online-count');
      if (onlineCountElement) onlineCountElement.textContent = fakeCount;
    }

    function getApiBaseFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      const urlApiBase = urlParams.get('apiBase');
      const urlUsername = urlParams.get('username');
      if (urlApiBase) CHAT_API_BASE = urlApiBase;
      if (urlUsername) currentUsername = urlUsername;
    }

    function initChat() {
      getApiBaseFromUrl();

      window.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'initChat') {
          currentUsername = event.data.username || currentUsername || 'User';
          if (event.data.chatApiBase) CHAT_API_BASE = event.data.chatApiBase;
          bootstrapChatExperience();
        } else if (event.data && event.data.type === 'chatOpened') {
          resetUnreadCount();
          isChatWindowOpen = true;

          if (!onlineCountIntervalStarted) {
            onlineCountIntervalStarted = true;
            updateOnlineCount();
            setInterval(updateOnlineCount, 30000);
          }
        } else if (event.data && event.data.type === 'chatClosed') {
          isChatWindowOpen = false;
        } else if (event.data && event.data.type === 'toggleNotifications') {
          notificationsEnabled = !!event.data.enabled;
          console.log('Chat notifications ' + (notificationsEnabled ? 'enabled' : 'disabled'));
        }
      });

      setTimeout(() => {
        bootstrapChatExperience();
      }, 500);
    }

    document.addEventListener('DOMContentLoaded', function() {
      console.log('Chat iframe DOM loaded, initializing...');
      initChat();

      const messagesContainer = document.getElementById('messagesContainer');
      if (messagesContainer) {
        messagesContainer.addEventListener('scroll', handleScroll);
        lastScrollTop = messagesContainer.scrollTop;
        setTimeout(scrollToBottom, 500);
      }

      setTimeout(updateUnreadBadge, 1000);
    });
  </script>
</body>
</html>
