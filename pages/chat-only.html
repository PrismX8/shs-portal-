<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Global Chat - NautilusOS</title>
  <meta name="description" content="NautilusOS Global Chat - Connect and chat with the community.">
  <meta name="keywords" content="chat, community, NautilusOS">
  <meta name="author" content="NautilusOS">

  <!-- Import Nautilus OS styles -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link rel="stylesheet" href="https://unpkg.com/open-props">
  <link rel="stylesheet" href="https://unpkg.com/open-props/normalize.min.css">
  <link rel="stylesheet" href="https://unpkg.com/open-props/buttons.min.css">

  <style>
    /* Import Nautilus OS theme variables */
    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --accent: #7dd3c0;
      --accent-hover: #5bb98c;
      --border: rgba(255, 255, 255, 0.1);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --info: #3b82f6;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Chat container */
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--bg-primary);
    }

    /* Chat header */
    .chat-header {
      background: rgba(30, 35, 48, 0.9);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .chat-title {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1rem;
    }

    .online-count {
      background: rgba(125, 211, 192, 0.2);
      color: var(--accent);
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
      min-width: 24px;
      text-align: center;
    }

    .chat-title i {
      color: var(--accent);
      font-size: 1.1rem;
    }


    .chat-actions {
      display: flex;
      gap: 5px;
    }

    .chat-action-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      width: 32px;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .chat-action-btn:hover {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border-color: var(--accent);
    }

    /* Chat content - full width now */
    .chat-content {
      flex: 1;
      display: block;
      overflow: hidden;
      height: 100%;
    }

    /* Messages area - full width */
    .messages-area {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: rgba(15, 18, 25, 0.6);
    }

    .messages-container {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 100%;
    }

    /* Message styles */
    .message {
      display: flex;
      margin-bottom: 8px;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message.system {
      justify-content: center;
    }

    .message.system .message-content {
      background: rgba(125, 211, 192, 0.1);
      border: 1px solid rgba(125, 211, 192, 0.2);
      border-radius: 12px;
      padding: 8px 12px;
      text-align: center;
      font-size: 0.85rem;
      color: var(--accent);
      max-width: 70%;
    }

    .message.user {
      justify-content: flex-end;
    }

    .message.other {
      justify-content: flex-start;
    }

    .message-content {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 0.9rem;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .message.user .message-content {
      background: var(--accent);
      color: var(--bg-primary);
      border-bottom-right-radius: 4px;
    }

    .message.other .message-content {
      background: rgba(30, 35, 48, 0.8);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 0.8rem;
    }

    .message.user .message-header {
      justify-content: flex-end;
    }

    .message.other .message-header {
      justify-content: flex-start;
    }

    .message-username {
      font-weight: 600;
      color: var(--accent);
    }

    .message.user .message-username {
      color: var(--bg-primary);
    }

    .message-timestamp {
      color: var(--text-secondary);
      font-size: 0.75rem;
    }

    .message.user .message-timestamp {
      color: rgba(15, 23, 42, 0.7);
    }

    /* Sending and failed message states */
    .message.sending .message-content {
      opacity: 0.8;
      border: 1px solid rgba(251, 191, 36, 0.3);
    }

    .message.failed .message-content {
      opacity: 0.7;
      border: 1px solid rgba(239, 68, 68, 0.3);
      background: rgba(239, 68, 68, 0.1);
    }

    .sending-indicator, .failed-indicator {
      margin-left: 8px;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .sending-indicator {
      color: #f59e0b;
    }

    .failed-indicator {
      color: #ef4444;
    }

    .sending-indicator i {
      margin-right: 4px;
    }

    /* Input area */
    .input-area {
      background: rgba(21, 25, 35, 0.9);
      backdrop-filter: blur(10px);
      border-top: 1px solid var(--border);
      padding: 16px;
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .message-input {
      flex: 1;
      padding: 12px 16px;
      background: rgba(30, 35, 48, 0.8);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.9rem;
      resize: none;
      min-height: 44px;
      max-height: 120px;
      transition: all 0.2s ease;
    }

    .message-input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(30, 35, 48, 0.95);
    }

    .message-input::placeholder {
      color: var(--text-muted);
    }

    .send-button {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      border: none;
      border-radius: 12px;
      color: var(--bg-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    .send-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(125, 211, 192, 0.3);
    }

    .send-button:active {
      transform: translateY(0);
    }


    .user-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .user-status {
      font-size: 0.6rem;
    }

    .user-status.online {
      color: #10b981;
    }

    .user-status.away {
      color: #f59e0b;
    }

    .user-status.offline {
      color: #64748b;
    }

    .user-name {
      flex: 1;
      color: var(--text-primary);
    }

    .current-user .user-name {
      font-weight: 600;
      color: var(--accent);
    }

    /* Loading state */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-secondary);
    }

    .loading i {
      animation: spin 1s linear infinite;
      margin-right: 8px;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Scrollbar styling */
    .messages-container::-webkit-scrollbar,
    .users-list::-webkit-scrollbar {
      width: 6px;
    }

    .messages-container::-webkit-scrollbar-track,
    .users-list::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb,
    .users-list::-webkit-scrollbar-thumb {
      background: rgba(125, 211, 192, 0.3);
      border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover,
    .users-list::-webkit-scrollbar-thumb:hover {
      background: rgba(125, 211, 192, 0.5);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .message-content {
        max-width: 85%;
      }
    }
  </style>
</head>

<body>
  <div class="chat-container">
    <!-- Chat Header -->
    <div class="chat-header">
      <div class="chat-title">
        <i class="fas fa-comments"></i>
        <span class="online-count">12</span> online
      </div>
      <div class="chat-actions">
        <button class="chat-action-btn" onclick="toggleSound()" title="Toggle Sound">
          <i class="fas fa-volume-up" id="soundIcon"></i>
        </button>
        <button class="chat-action-btn" onclick="clearMessages()" title="Clear Chat">
          <i class="fas fa-trash"></i>
        </button>
      </div>
    </div>

    <!-- Chat Content -->
    <div class="chat-content">
      <!-- Messages Area -->
      <div class="messages-area">
        <div class="messages-container" id="messagesContainer">
          <div class="message system">
            <div class="message-content">
              Welcome to NautilusOS Global Chat! ðŸ‘‹
            </div>
          </div>
        </div>
      </div>

    </div>

    <!-- Input Area -->
    <div class="input-area">
      <textarea
        class="message-input"
        id="messageInput"
        placeholder="Type your message..."
        onkeydown="handleKeyPress(event)"
        maxlength="500"
      ></textarea>
      <button class="send-button" onclick="sendMessage()">
        <i class="fas fa-paper-plane"></i>
      </button>
    </div>
  </div>

  <script>
    // =====================================================
    // NEBULO CHAT FUNCTIONALITY - INTEGRATED FOR NAUTILUS OS
    // =====================================================

// Configuration - Set this to your Cloudflare Worker endpoint
let CHAT_API_BASE = null; // Will be set by parent window message

    // Chat state
    let currentUsername = 'User';
    let messages = [];
    let users = [];
    let soundEnabled = true;
    let globalChatSending = false;
    let seenMessageIds = new Set(); // Track seen message IDs to prevent duplicates
    let unreadMessageCount = 0; // Track unread messages
    let isChatInitialized = false; // Track if chat has been initialized
    let isChatWindowOpen = false; // Track if chat window is currently open
    let chatBootstrapInFlight = false;
    let periodicNotificationsStarted = false;
    let onlineCountIntervalStarted = false;
    let lastGlobalChatMessageSig = '';
    let chatHistoryBootstrapped = false;
    let shouldAutoScroll = true; // Track if we should autoscroll to bottom
    let lastScrollTop = 0; // Track last scroll position
    let workerHistoryLoaded = false;
    let globalChatSeen = new Set();
    let messageNodeIndex = new Map();

    // Initialize chat
    function initChat() {
      // First try to get config from URL parameters (more reliable)
      const urlParams = new URLSearchParams(window.location.search);
      const urlApiBase = urlParams.get('apiBase');
      const urlUsername = urlParams.get('username');

      if (urlApiBase) {
        CHAT_API_BASE = urlApiBase;
        console.log('Got CHAT_API_BASE from URL:', CHAT_API_BASE);
      }

      if (urlUsername) {
        currentUsername = urlUsername;
      }

      // Listen for messages from parent window (merged handler)
      window.addEventListener('message', function(event) {
        if (event.data.type === 'initChat') {
          currentUsername = event.data.username || currentUsername || 'User';
          if (event.data.chatApiBase) {
            CHAT_API_BASE = event.data.chatApiBase; // Override if provided
          }

          bootstrapChatExperience();
        } else if (event.data.type === 'chatOpened') {
          resetUnreadCount();
          isChatInitialized = true;
          isChatWindowOpen = true;

          if (!onlineCountIntervalStarted) {
            onlineCountIntervalStarted = true;
            // Start fake online count updates immediately
            updateOnlineCount();
            // Update every 30 seconds
            setInterval(() => {
              updateOnlineCount();
            }, 30000);
          }
        } else if (event.data.type === 'chatClosed') {
          isChatWindowOpen = false;
        }
      });

      // Auto-connect after a short delay
      setTimeout(() => {
        if (CHAT_API_BASE) {
          bootstrapChatExperience();
        } else {
          addSystemMessage('âŒ Chat backend not configured. Please set CHAT_API_BASE.');
        }
      }, 500);
    }

    // Bootstrap chat experience (adapted from NEBULO)
    function bootstrapChatExperience() {
      if (chatBootstrapInFlight || chatHistoryBootstrapped) {
        return;
      }
      chatBootstrapInFlight = true;
      if (!CHAT_API_BASE) {
        addSystemMessage('âŒ Chat backend not configured.');
        // Mark as bootstrapped to prevent notification issues
        chatHistoryBootstrapped = true;
        chatBootstrapInFlight = false;
        // Start periodic notifications
        startPeriodicNotifications();
        return;
      }

      addSystemMessage('ðŸ”„ Connecting to chat service...');

      // Initialize with NEBULO chat system
      initGlobalChatClient().then(() => {
        addSystemMessage('âœ… Connected to Global Chat! ðŸŽ‰');
        // Start periodic notifications even when connected
        startPeriodicNotifications();
        chatBootstrapInFlight = false;
      }).catch(err => {
        console.error('Chat initialization failed:', err);
        addSystemMessage('âŒ Chat connection failed.');
        // Mark as bootstrapped and start periodic notifications
        chatHistoryBootstrapped = true;
        startPeriodicNotifications();
        chatBootstrapInFlight = false;
      });
    }

    // Start periodic notifications every 5 minutes
    function startPeriodicNotifications() {
      if (periodicNotificationsStarted) {
        return;
      }
      periodicNotificationsStarted = true;
      setInterval(() => {
        if (!isChatWindowOpen) {
          showChatNotification({
            username: 'System',
            content: 'There are new messages in Global Chat!'
          });
        }
      }, 300000); // Every 5 minutes
    }

    // Initialize global chat client (adapted from NEBULO)
    async function initGlobalChatClient() {
      if (!CHAT_API_BASE) {
        throw new Error('CHAT_API_BASE not configured');
      }

      console.log(`âœ… Chat initialized with Cloudflare Worker: ${CHAT_API_BASE}`);

      try {
        // Load initial messages from server
        if (!workerHistoryLoaded && !chatHistoryBootstrapped) {
          const serverMessages = await requestServerSnapshot();

          if (serverMessages && serverMessages.length > 0) {
            serverMessages.forEach(m => {
              appendGlobalChatMessage(m);
            });
            console.log(`âœ… Loaded ${serverMessages.length} messages from server`);
            workerHistoryLoaded = true;
          }
        }

        chatHistoryBootstrapped = true;

        // Start polling for new messages
        startChatPolling();

      } catch (error) {
        console.error('Failed to initialize chat client:', error);
        throw error;
      }
    }

    // Request server snapshot (adapted from NEBULO)
    async function requestServerSnapshot() {
      if (!CHAT_API_BASE) return null;

      try {
        const response = await fetch(`${CHAT_API_BASE}/chat/recent?limit=50&images=1`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
          mode: 'cors'
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        console.error('Failed to fetch server snapshot:', error);
        return null;
      }
    }

    // Start polling for new messages
    function startChatPolling() {
      setInterval(async () => {
        if (!CHAT_API_BASE) return;

        try {
          const response = await fetch(`${CHAT_API_BASE}/chat/recent?limit=10&images=1`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
            },
            mode: 'cors'
          });

          if (response.ok) {
            const newMessages = await response.json();
            newMessages.forEach(m => {
              if (!globalChatSeen.has(m.id)) {
                appendGlobalChatMessage(m);
                globalChatSeen.add(m.id);
              }
            });
          }
        } catch (error) {
          console.error('Failed to poll messages:', error);
        }
      }, 5000); // Poll every 5 seconds
    }

    // Send message (adapted from NEBULO)
    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();

      if (!text || globalChatSending) return;

      // Ensure send button exists
      const sendButtonIcon = document.querySelector('.send-button i');
      if (!sendButtonIcon) {
        console.error('Send button not found');
        return;
      }

      globalChatSending = true;

      // Check message length
      if (text.length > 750) {
        addSystemMessage('âŒ Message too long. Maximum 750 characters.');
        globalChatSending = false;
        return;
      }

      // Deduplication check
      const dedupSig = text.replace(/\s+/g, ' ').toLowerCase();
      if (dedupSig === lastGlobalChatMessageSig) {
        addSystemMessage('âŒ Duplicate message blocked.');
        globalChatSending = false;
        return;
      }

      lastGlobalChatMessageSig = dedupSig;

      // Generate a temporary ID for this message
      const tempMessageId = 'temp_' + Date.now();

      // Clear input immediately for better UX
      input.value = '';
      input.style.height = '44px';

      // Show sending indicator
      const originalIcon = sendButtonIcon.className;
      sendButtonIcon.className = 'fas fa-spinner fa-spin';

      // Add message immediately with "sending" state
      const sendingMessage = {
        id: tempMessageId,
        content: text,
        username: currentUsername,
        timestamp: 'Sending...',
        isCurrentUser: true,
        isSending: true // Mark as sending
      };

      messages.push(sendingMessage);
      renderMessage(sendingMessage);
      scrollToBottom();

      try {
        // Send to server
        if (CHAT_API_BASE) {
          const messageData = {
            name: currentUsername,
            text: text
          };

          const response = await fetch(`${CHAT_API_BASE}/chat/send`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            mode: 'cors',
            body: JSON.stringify(messageData)
          });

          if (!response.ok) {
            console.error('Server response not ok:', response.status);
            throw new Error(`Server error: ${response.status}`);
          }

        } else {
          // No server configured - just mark as sent locally
          updateMessageStatus(tempMessageId, false);
        }
      } catch (error) {
        console.error('Failed to send message:', error);

        // Mark message as failed
        updateMessageStatus(tempMessageId, false, true);

        // Show error notification
        addSystemMessage('âŒ Failed to send message');
      } finally {
        // Always restore send button icon
        if (sendButtonIcon) {
          sendButtonIcon.className = originalIcon;
        }
      }

      globalChatSending = false;
    }

    // Append global chat message (adapted for your worker)
    function appendGlobalChatMessage(message) {
      // Check for duplicate messages
      const messageId = message.id;
      if (messageId && seenMessageIds.has(messageId)) {
        return; // Skip duplicate
      }

      // Convert worker message format to our format
      const formattedMessage = {
        id: messageId || Date.now(),
        content: message.text || message.content || '',
        username: message.name || message.username || 'Unknown',
        timestamp: message.t ?
          new Date(message.t).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) :
          new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        isCurrentUser: (message.name || message.username) === currentUsername
      };

      // Check if this is a confirmation of our own message
      const tempMessageIndex = messages.findIndex(m =>
        m.isCurrentUser &&
        m.isSending &&
        m.content === formattedMessage.content &&
        m.username === formattedMessage.username
      );

      if (tempMessageIndex !== -1) {
        // This is a confirmation of our sent message - update the existing one
        updateMessageStatus(messages[tempMessageIndex].id, false);
        // Replace the temporary message with the server-confirmed one
        messages[tempMessageIndex] = formattedMessage;
        // Re-render the message list to show the updated message
        renderAllMessages();
        seenMessageIds.add(messageId);
        return; // Don't add duplicate
      }

      // Mark as seen
      if (messageId) {
        seenMessageIds.add(messageId);
      }

      messages.push(formattedMessage);
      renderMessage(formattedMessage);

      // Only increment unread count and show notifications for NEW messages from other users
      // Don't count historical messages when initially loading history
      if (!formattedMessage.isCurrentUser && chatHistoryBootstrapped && !isChatWindowOpen) {
        unreadMessageCount++;
        updateUnreadBadge();
        showChatNotification(formattedMessage);
      }

      // Scroll to bottom
      scrollToBottom();
    }

    // Add user message
    function addUserMessage(content, username, isCurrentUser = false) {
      const message = {
        id: Date.now(),
        content: content,
        username: username,
        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        isCurrentUser: isCurrentUser
      };

      messages.push(message);
      renderMessage(message);
      scrollToBottom();
    }

    // Add system message
    function addSystemMessage(content) {
      const message = {
        id: Date.now(),
        content: content,
        type: 'system',
        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
      };

      messages.push(message);
      renderMessage(message);
      scrollToBottom();
    }

    // Update message status (for sending states)
    function updateMessageStatus(tempId, isSending = false, isFailed = false) {
      const messageIndex = messages.findIndex(m => m.id === tempId);
      if (messageIndex === -1) return;

      const message = messages[messageIndex];
      message.isSending = isSending;
      message.isFailed = isFailed;

      // Update timestamp
      if (!isSending) {
        message.timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      // Re-render this message
      const container = document.getElementById('messagesContainer');
      const messageElements = container.querySelectorAll('.message');
      if (messageElements[messageIndex]) {
        const updatedElement = renderMessageElement(message);
        messageElements[messageIndex].replaceWith(updatedElement);
      }
    }

    // Render message element
    function renderMessageElement(message) {
      const messageDiv = document.createElement('div');

      if (message.type === 'system') {
        messageDiv.className = 'message system';
        messageDiv.innerHTML = `
          <div class="message-content">${message.content}</div>
        `;
      } else {
        messageDiv.className = `message ${message.isCurrentUser ? 'user' : 'other'} ${message.isSending ? 'sending' : ''} ${message.isFailed ? 'failed' : ''}`;
        messageDiv.innerHTML = `
          <div class="message-content">
            <div class="message-header">
              <span class="message-username">${message.username}</span>
              <span class="message-timestamp">${message.timestamp}</span>
              ${message.isSending ? '<span class="sending-indicator"><i class="fas fa-circle-notch fa-spin"></i> Sending...</span>' : ''}
              ${message.isFailed ? '<span class="failed-indicator"><i class="fas fa-exclamation-triangle"></i> Failed</span>' : ''}
            </div>
            <div>${message.content}</div>
          </div>
        `;
      }

      return messageDiv;
    }

    // Render all messages (used when updating existing messages)
    function renderAllMessages() {
      const container = document.getElementById('messagesContainer');
      container.innerHTML = '';
      messages.forEach(message => {
        renderMessage(message);
      });
    }

    // Render message
    function renderMessage(message) {
      const container = document.getElementById('messagesContainer');
      const messageElement = renderMessageElement(message);
      container.appendChild(messageElement);
    }


    // Update online count with fake numbers (random 8-25, changes every 30 seconds)
    function updateOnlineCount() {
      // Generate fake online count: minimum 8, maximum 25
      const fakeCount = Math.floor(Math.random() * 18) + 8; // 8-25 range
      const onlineCountElement = document.querySelector('.online-count');
      if (onlineCountElement) {
        onlineCountElement.textContent = fakeCount;
      }
    }




    // Scroll to bottom (only if shouldAutoScroll is true)
    function scrollToBottom() {
      if (shouldAutoScroll) {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
      }
    }

    // Handle scroll events to detect user scrolling
    function handleScroll() {
      const container = document.getElementById('messagesContainer');
      if (!container) return;

      const currentScrollTop = container.scrollTop;
      const maxScrollTop = container.scrollHeight - container.clientHeight;

      // If user is near the bottom (within 50px), enable autoscroll
      if (currentScrollTop >= maxScrollTop - 50) {
        shouldAutoScroll = true;
      }
      // If user scrolled up significantly, disable autoscroll
      else if (lastScrollTop > currentScrollTop && currentScrollTop < maxScrollTop - 100) {
        shouldAutoScroll = false;
      }

      lastScrollTop = currentScrollTop;
    }

    // Handle key press
    function handleKeyPress(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }

      // Auto-resize textarea
      const textarea = event.target;
      textarea.style.height = '44px';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    // Toggle sound
    function toggleSound() {
      soundEnabled = !soundEnabled;
      const icon = document.getElementById('soundIcon');

      if (soundEnabled) {
        icon.className = 'fas fa-volume-up';
        addSystemMessage('ðŸ”Š Sound notifications enabled');
      } else {
        icon.className = 'fas fa-volume-mute';
        addSystemMessage('ðŸ”‡ Sound notifications disabled');
      }
    }

    // Clear messages
    function clearMessages() {
      if (confirm('Clear all messages?')) {
        messages = [];
        document.getElementById('messagesContainer').innerHTML = '';
        addSystemMessage('ðŸ§¹ Chat cleared');
      }
    }

    // Update unread message badge (always show pulsing indicator)
    function updateUnreadBadge() {
      // Notify parent window to show the pulsing badge
      try {
        window.parent.postMessage({
          type: 'updateChatBadge',
          show: true
        }, '*');
      } catch (error) {
        // Silently fail
      }
    }

    // Show chat notification using Nautilus OS notification system
    function showChatNotification(message) {
      // Always show notifications for new messages from other users
      // The parent window will handle whether to show them based on chat state
      try {
        window.parent.postMessage({
          type: 'showChatNotification',
          username: message.username,
          content: message.content.substring(0, 50) + (message.content.length > 50 ? '...' : '')
        }, '*');
      } catch (error) {
        // Silently fail
      }
    }

    // Reset unread count (called when chat is opened)
    function resetUnreadCount() {
      unreadMessageCount = 0;
      updateUnreadBadge();
    }




    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Chat iframe DOM loaded, initializing...');
      initChat();

      // Add scroll event listener for autoscroll detection
      const messagesContainer = document.getElementById('messagesContainer');
      if (messagesContainer) {
        messagesContainer.addEventListener('scroll', handleScroll);

        // Initialize scroll position tracking
        lastScrollTop = messagesContainer.scrollTop;

        // Scroll to bottom initially
        setTimeout(() => {
          scrollToBottom();
        }, 500);
      }

      // Show the pulsing badge indicator
      setTimeout(() => {
        updateUnreadBadge();
      }, 1000);
    });
  </script>
</body>
</html>
