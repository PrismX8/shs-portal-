  console.time('scriptExecution');
  // Check if this is the chat-only page to avoid loading heavy features
  const IS_CHAT_ONLY = window.location.pathname.includes('chat-only.html');
  const CHAT_AGE_KEY = 'chatAgeGateStatus';
  window.CHAT_AGE_KEY = CHAT_AGE_KEY;

  function isChatAgeVerified() {
      try {
          return localStorage.getItem(CHAT_AGE_KEY) === 'over13';
      } catch (_) {
          return false;
      }
  }

  function setChatAgeStatus(status) {
      try {
          localStorage.setItem(CHAT_AGE_KEY, status);
      } catch (_) {}
  }

  let chatBootstrapDone = false;
  function bootstrapChatExperienceForPage() {
      if (chatBootstrapDone) return;
      chatBootstrapDone = true;
      ensureChatToast();
      ensureChatBadge();
      updateChatBadge();
      initGlobalChatClient();
      try { updateOwnerReportsButtonVisibility(); } catch (_) {}
      try { ensureVoiceUi(); } catch (_) {}
      // Initialize voice activity banner on all pages (for join/leave messages)
      ensureVoiceActivityBanner();
      // Initialize Cloudflare discovery observer on all pages (for notifications only)
      // Supabase is still used for participant discovery and voice chat controls
      // Note: Firebase listener is initialized globally below, not just in bootstrapChatExperienceForPage
      // Optional: Cloudflare for notifications only (if enabled)
      if (VOICE_DISCOVERY_ENABLED) {
          try { ensureVoiceDiscoveryObserver(); } catch (_) {}
      }
      if (IS_CHAT_ONLY) {
          globalChatIsOpen = true;
          markChatSeen();
      }
  }

  // Suppress noisy syntax errors when the Clarity tag is blocked/rewritten by filters
  window.addEventListener('error', (e) => {
      const src = e.filename || '';
      if (src.includes('uh0lyeydcq') || src.includes('clarity.ms/tag/uh0lyeydcq')) {
          e.preventDefault();
          return true;
      }
  }, true);
  // Global popup guard: block known malicious popups and lock down movies page
  (function hardenPopups() {
      const nativeOpen = window.open;
      const isMoviesPage = window.location.pathname.endsWith('movies.html') ||
                           window.location.pathname.includes('/pages/movies.html');

      const maliciousHosts = new Set([
          '9dnoxy.sulaterobests.com',
          'sulaterobests.com',
          'emotomalf.com',
          // Reported random click popups
          'nexornero.co.in'
      ]);

      const allowedHostsMovies = new Set([
          window.location.hostname,
          'www.fmovies.gd',
          'ww22.0123movie.net',
          'movies4ufree.net',
          'sflix.ps',
          'fmoviesto.ru',
          'fullmovies4k.info',
          'https://fmoviesto.ru/home',
          'discord.gg',
          'www.youtube.com',
          'youtube.com',
          'youtu.be',
          'www.yout-ube.com',
          'yout-ube.com'
      ]);

      function isBlocked(url) {
          try {
              const u = new URL(url, window.location.href);
              const host = (u.hostname || '').toLowerCase();
              for (const blocked of maliciousHosts) {
                  const b = String(blocked || '').toLowerCase();
                  if (!b) continue;
                  if (host === b || host.endsWith('.' + b)) return true;
              }
              return false;
          } catch (_) {
              return false;
          }
      }

      function isAllowedForMovies(url) {
          try {
              const u = new URL(url, window.location.href);
              return allowedHostsMovies.has(u.hostname) || u.protocol === 'about:';
          } catch (_) {
              return false;
          }
      }

      window.open = function(url, target, features) {
          if (url && isBlocked(url)) {
              console.warn('Blocked malicious popup/tab:', url);
              return null;
          }
          if (isMoviesPage && url && !isAllowedForMovies(url)) {
              console.warn('Blocked popup/tab on movies page:', url);
              return null;
          }
          return nativeOpen.call(window, url, target, features);
      };

      // Intercept anchor clicks with target _blank to disallow bad domains
      document.addEventListener('click', (e) => {
          const link = e.target?.closest && e.target.closest('a[target="_blank"][href]');
          if (!link) return;
          const href = link.getAttribute('href');
          if (!href) return;
          if (isBlocked(href) || (isMoviesPage && !isAllowedForMovies(href))) {
              e.preventDefault();
              e.stopPropagation();
              console.warn('Blocked new-tab navigation:', href);
          }
      }, true);
  })();
  const firebaseConfig = {
    apiKey: "AIzaSyBn1apVsFafY2-2a2QPeslX17XR0gWE9qs",
    authDomain: "shsproject-d60d0.firebaseapp.com",
    databaseURL: "https://shsproject-d60d0-default-rtdb.firebaseio.com",
    projectId: "shsproject-d60d0",
  };
  const IS_LOCAL = location.hostname === "localhost" || location.hostname === "127.0.0.1";

  const BACKEND_API_URL =
    window.BACKEND_API_URL ||
    (IS_LOCAL
      ? "http://localhost:3000/api"
      : "https://shs-portal-backend.vercel.app/api");

  const BACKEND_WS_URL =
    window.BACKEND_WS_URL ||
    (IS_LOCAL
      ? "ws://localhost:3000"
      : "wss://shs-portal-backend.vercel.app");

  const SOCIAL_FEATURES_ENABLED = false; // Friends/profile/leaderboard backend disabled
  const backendApiAvailable = typeof BackendAPI !== 'undefined' && SOCIAL_FEATURES_ENABLED;
  let backendApi = backendApiAvailable ? new BackendAPI({ apiUrl: BACKEND_API_URL, wsUrl: BACKEND_WS_URL }) : null;
  if (!backendApi && typeof window.markBackendReady === 'function') {
    window.markBackendReady();
  }
  function disableBackend(reason = '') {
      console.warn('Disabling backend API usage', reason);
      backendApi = null;
      backendFriendsDisabled = true;
      if (friendsPollInterval) {
          clearInterval(friendsPollInterval);
          friendsPollInterval = null;
      }
  }

  // Minimal Firebase shim mapped to backend
  if (typeof window.firebase === 'undefined') {
    window.firebase = {
      apps: [{}],
      initializeApp: () => window.firebase,
      database: () => {
        if (!backendApi && typeof BackendAPI !== 'undefined') {
          backendApi = new BackendAPI({ apiUrl: BACKEND_API_URL, wsUrl: BACKEND_WS_URL });
        }
        if (backendApi) {
          db = backendApi.database();
          return db;
        }
        return null;
      }
    };
  }

  // Helper: open a path in a fresh about:blank tab with an iframe wrapper (falls back to same tab)
  function openGameInBlank(path) {
      if (!path) return false;
      const absolute = new URL(path, window.location.href).href;

      // If we're already in an about:blank wrapper context, update the existing iframe instead of opening new tab
      if (window.location.protocol === 'about:' && window.location.href === 'about:blank') {
          // Find the iframe in the current about:blank page and update its src
          const iframe = document.querySelector('iframe');
          if (iframe) {
              iframe.src = absolute;
              return true;
          }
      }

      const html = `<!doctype html>
<html>
<head>
  <title>Loading game...</title>
  <style>html,body{margin:0;height:100%;background:#0b0c12;}iframe{border:0;width:100%;height:100%;display:block;}</style>
</head>
<body>
  <script>
    (() => {
      const allowedOrigin = '${new URL(absolute).origin}';
      window.addEventListener('message', (event) => {
        const data = event?.data;
        // Only honor messages from the same origin or about:blank (sandboxed may appear as null)
        if (event.origin && event.origin !== 'null' && event.origin !== allowedOrigin) return;
        if (data === 'close-chat-tab' || (data && data.type === 'close-chat-tab')) {
          window.close();
        }
      });
    })();
  </script>
  <iframe src="${absolute}"
          style="border:0;width:100%;height:100%;display:block;"
          allowfullscreen
          allow="fullscreen; autoplay; clipboard-write; accelerometer; gyroscope; picture-in-picture; magnetometer"
          sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-downloads allow-top-navigation-by-user-activation">
  </iframe>
</body>
</html>`;
      const win = window.open('about:blank', '_blank');
      if (win && !win.closed) {
          win.document.open();
          win.document.write(html);
          win.document.close();
          return true;
      }
      // Fallback if popups are blocked: navigate current tab
      window.location.href = absolute;
      return false;
  }

  // Lightweight single-page navigation: load internal pages in an overlay iframe without changing URL
  const spaFrame = document.createElement('iframe');
  spaFrame.id = 'spaFrameOverlay';
  Object.assign(spaFrame.style, {
      position: 'fixed',
      inset: '0',
      width: '100vw',
      height: '100vh',
      border: '0',
      display: 'none',
      zIndex: '20000',
      background: '#05060b'
  });
  const spaSpinner = document.createElement('div');
  spaSpinner.id = 'spaFrameSpinner';
  Object.assign(spaSpinner.style, {
      position: 'fixed',
      inset: '0',
      display: 'none',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: '20001',
      background: 'rgba(0,0,0,0.45)',
      backdropFilter: 'blur(6px)'
  });
  spaSpinner.innerHTML = '<div style="width:64px;height:64px;border:6px solid rgba(255,255,255,0.12);border-top-color:#ffd700;border-radius:50%;animation:spaSpin 0.8s linear infinite;"></div>';
  const spaCloseBtn = document.createElement('button');
  spaCloseBtn.id = 'spaFrameClose';
  spaCloseBtn.textContent = 'Back to Home';
  Object.assign(spaCloseBtn.style, {
      position: 'fixed',
      top: '14px',
      left: '14px',
      padding: '10px 14px',
      borderRadius: '12px',
      border: '1px solid rgba(255,255,255,0.2)',
      background: 'rgba(0,0,0,0.6)',
      color: '#fff',
      fontSize: '14px',
      cursor: 'pointer',
      zIndex: '20002',
      display: 'none',
      boxShadow: '0 10px 30px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.12)',
      backdropFilter: 'blur(6px)'
  });
  const styleSpa = document.createElement('style');
  styleSpa.textContent = '@keyframes spaSpin{to{transform:rotate(360deg);}}';
  document.head.appendChild(styleSpa);
  document.body.appendChild(spaFrame);
  document.body.appendChild(spaSpinner);
  document.body.appendChild(spaCloseBtn);
  function showSpaSpinner(show) {
      spaSpinner.style.display = show ? 'flex' : 'none';
  }
  function hideSpaFrame() {
      spaFrame.style.display = 'none';
      spaFrame.removeAttribute('src');
      showSpaSpinner(false);
      spaCloseBtn.style.display = 'none';
  }
  spaFrame.addEventListener('load', () => showSpaSpinner(false));
  spaFrame.addEventListener('load', () => {
      showSpaSpinner(false);
      try {
          const loc = spaFrame.contentWindow?.location;
          if (loc && (loc.pathname === '/' || loc.pathname.endsWith('/index.html') || loc.pathname === '/index.html')) {
              hideSpaFrame();
          }
      } catch (_) {
          // ignore cross-frame errors
      }
  });
  spaCloseBtn.addEventListener('click', hideSpaFrame);
  document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') hideSpaFrame();
  });

  function navigateInternally(url) {
      // Heavy pages: open in about:blank wrapper instead of overlay
      if (url.pathname.includes('all-games.html') || url.pathname.includes('/blog')) {
          openGameInBlank(url.href);
          return;
      }
      const path = url.pathname;
      // Treat home/index as exit back to base content
      const isHome = path.endsWith('/') || path.endsWith('/index.html') || path === '/index.html';
      if (isHome) {
          hideSpaFrame();
          return;
      }
      showSpaSpinner(true);
      spaFrame.src = url.href;
      spaFrame.style.display = 'block';
      spaCloseBtn.style.display = 'block';
  }

  // Global link interceptor: internal pages load in overlay iframe; external still open with wrapper
  document.addEventListener('click', (e) => {
      const link = e.target.closest('a');
      if (!link) return;
      // Respect explicit new-tab links (e.g., Terms/Privacy from voice gate modal)
      if ((link.getAttribute('target') || '').toLowerCase() === '_blank') return;
      const href = link.getAttribute('href');
      if (!href || href.startsWith('#') || href.startsWith('javascript:')) return;
      try {
          const url = new URL(href, window.location.href);
          // Allow same-page anchors
          if (url.origin === window.location.origin && url.hash && url.pathname === window.location.pathname) return;
          const isInternal = url.origin === window.location.origin;
          // Home links: open via about:blank wrapper and close overlay
          if (isInternal && url.pathname.endsWith('/index.html')) {
              e.preventDefault();
              openGameInBlank(url.href);
              hideSpaFrame();
              return;
          }
          // Sidebar home: force return to base
          if (isInternal && (url.pathname.endsWith('/index.html') || url.pathname === '/')) {
              e.preventDefault();
              hideSpaFrame();
              return;
          }
          // Heavy pages: open in about:blank wrapper and keep base tab untouched
          if (isInternal && (url.pathname.includes('all-games.html') || url.pathname.includes('/blog'))) {
              e.preventDefault();
              openGameInBlank(url.href);
              return;
          }
          if (!isInternal) {
              e.preventDefault();
              openGameInBlank(url.href) || window.open(url.href, '_blank');
              return;
          }
          // Internal: load in overlay frame and keep base URL the same
          e.preventDefault();
          navigateInternally(url);
      } catch (_) {
          // If URL parsing fails, let default happen
      }
  }, true);

  // Ensure live visitor counter appears at top of every page
  function ensureVisitorCounter() {
      if (document.getElementById('globalVisitorCounter')) return;
      const bar = document.createElement('div');
      bar.id = 'globalVisitorCounter';
      bar.className = 'visitor-counter-bar';
      const title = document.createElement('div');
      title.className = 'visitor-counter-title';
      title.textContent = 'Live Visitor Counter';
      const widget = document.createElement('div');
      widget.className = 'visitor-counter-widget';
      const link = document.createElement('a');
      link.href = 'http://www.freevisitorcounters.com';
      link.target = '_blank';
      link.rel = 'noopener noreferrer';
      link.className = 'counter-link';
      link.textContent = 'www.Freevisitorcounters.com';
      widget.appendChild(link);
      const authScript = document.createElement('script');
      authScript.src = 'https://www.freevisitorcounters.com/auth.php?id=703fb8b77a23aa0ebf8aa16a6f5a414854af9f97';
      widget.appendChild(authScript);
      const counterScript = document.createElement('script');
      counterScript.src = 'https://www.freevisitorcounters.com/en/home/counter/1454457/t/1';
      widget.appendChild(counterScript);
      bar.appendChild(title);
      bar.appendChild(widget);
      document.body.insertBefore(bar, document.body.firstChild || null);
  }

  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', ensureVisitorCounter, { once: true });
  } else {
      ensureVisitorCounter();
  }

  // Global guard: warn before opening Clash Royale from any cube/link
  // Removed alert for Clash Royale game cube clicks

  // -------- Global Chat (Supabase) --------
  const globalChatToggle = document.getElementById('globalChatToggle');
  const globalChatModal = document.getElementById('globalChatModal');
  const globalChatPanel = document.getElementById('globalChatPanel');
  const closeGlobalChat = document.getElementById('closeGlobalChat');
  const globalChatBox = document.getElementById('globalChatBox');
  const globalChatInput = document.getElementById('globalChatInput');
  const globalChatSendBtn = document.getElementById('globalChatSendBtn');
  const globalChatEmojiBtn = document.getElementById('globalChatEmojiBtn');
  const globalChatEmojiPicker = document.getElementById('globalChatEmojiPicker');
  const globalChatStatus = document.getElementById('globalChatStatus');
  const globalChatTypingEl = document.getElementById('globalChatTyping');
  const globalChatNameInput = document.getElementById('globalChatNameInput');
  const globalChatNameSave = document.getElementById('globalChatNameSave');
  const globalChatLocationValue = document.getElementById('globalChatLocationValue');
  const globalChatSettingsBtn = document.getElementById('globalChatSettingsBtn');
  const globalChatSettingsModal = document.getElementById('globalChatSettingsModal');
  const closeGlobalChatSettings = document.getElementById('closeGlobalChatSettings');
  const globalChatThemeButtons = document.querySelectorAll('.globalChatThemeBtn');
  const globalChatMyBubbleColorInput = document.getElementById('globalChatMyBubbleColor');
  const globalChatSeen = new Set();
  let globalChatSending = false;
  let lastGlobalChatMessageSig = '';
  let lastOptimisticTempId = null; // Track last optimistic message for reliable replacement
  
  // Message counter (client-side only, persists in localStorage)
  const MESSAGE_COUNTER_KEY = 'globalChatMessageCount';
  const MESSAGE_COUNTER_START = 763956;
  let globalChatMessageCount = 0;
  
  // Initialize message counter from localStorage
  function initMessageCounter() {
      try {
          const stored = localStorage.getItem(MESSAGE_COUNTER_KEY);
          if (stored !== null) {
              globalChatMessageCount = parseInt(stored, 10) || MESSAGE_COUNTER_START;
          } else {
              globalChatMessageCount = MESSAGE_COUNTER_START;
              localStorage.setItem(MESSAGE_COUNTER_KEY, String(globalChatMessageCount));
          }
          updateMessageCounterDisplay();
      } catch (err) {
          console.warn('Failed to initialize message counter:', err);
          globalChatMessageCount = MESSAGE_COUNTER_START;
      }
  }
  
  // Update the counter display
  function updateMessageCounterDisplay() {
      const counterEl = document.getElementById('globalChatMessageCount');
      if (counterEl) {
          counterEl.textContent = globalChatMessageCount.toLocaleString();
      }
  }
  
  // Increment message counter (only for confirmed messages, not optimistic)
  function incrementMessageCounter() {
      globalChatMessageCount++;
      try {
          localStorage.setItem(MESSAGE_COUNTER_KEY, String(globalChatMessageCount));
      } catch (err) {
          console.warn('Failed to save message counter:', err);
      }
      updateMessageCounterDisplay();
  }
  
  // Initialize counter on page load
  initMessageCounter();
  if (globalChatEmojiPicker) {
      globalChatEmojiPicker.style.display = 'none';
  }
  const BLOCKED_TERMS = [
      'nigger','nigga','nig','kike','spic','chink','gook','fag','faggot','tranny','retard'
  ];
  const BLOCKED_PATTERNS = [
      /n+i+g+[aeouy]*r*/i,
      /k+i+k+e*/i,
      /s+p+i+c+/i,
      /c+h+i+n+k+/i,
      /g+o+o+k+/i,
      /f+a+g+/i,
      /t+r+a+n+n*y+/i,
      /r+e+t+a+r+d+/i,
      // Very loose catch for n*g* constructs
      /n+[^a-z0-9]*i+[^a-z0-9]*g+[^a-z0-9]*g+[^a-z0-9]*e*r*/i
  ];
  const BLOCKED_VIOLENCE = [
      'killyourself','killyou','kys','kms','hangyourself','shootyourself','slityourwrists',
      'godie','justdie','neckyourself','blowyourselfup'
  ];
  const BLOCKED_VIOLENCE_PATTERNS = [
      /k+i+l+l+y+o+u+r+s+e+l+f+/i,
      /k+i+l+l+y+o+u+/i,
      /k+y+s+/i,
      /k+m+s+/i,
      /h+a+n+g+y+o+u+r+s+e+l+f+/i,
      /s+h+o+o+t+y+o+u+r+s+e+l+f+/i,
      /s+l+i+t+y+o+u+r+w+r+i+s+t+s*/i,
      /g+o+d+i+e+/i,
      /j+u+s+t+d+i+e+/i
  ];
  const AI_MODERATE_ENDPOINT = 'https://chat-moderation-final.netlify.app/.netlify/functions/moderate';
  let globalChatDetectedState = '';
  
  // Reserved words that cannot be used in names (case-insensitive)
  // Must be declared before globalChatUsername initialization
  const RESERVED_NAME_WORDS = ['owner', 'admin', 'mod', 'moderator', 'administrator'];
  
  function containsReservedName(name) {
      if (!name) return false;
      const lowerName = name.toLowerCase().trim();
      // Check if name contains any reserved word anywhere (case-insensitive)
      // This will block "Owner", "MyOwner", "Owner123", etc.
      return RESERVED_NAME_WORDS.some(word => {
          // Check if the reserved word appears anywhere in the name (not just as whole word)
          return lowerName.includes(word.toLowerCase());
      });
  }
  
  let globalChatUsername = (() => {
      const stored = localStorage.getItem('globalChatUsername');
      if (stored && isValidChatName(stored) && !isNameBlocked(stored)) {
          // Check for reserved names (but allow %Owner% as special case)
          if (stored === '%Owner%' || !containsReservedName(stored)) {
              return stored;
          }
          // If stored name contains reserved words, clear it and notify user
          localStorage.removeItem('globalChatUsername');
          // Show notification after a short delay to ensure UI is ready
          setTimeout(() => {
              showChatNotice('Your saved name contains reserved words. Please choose a new name.', true);
          }, 1000);
      }
      // If stored name is bad, clear it and force user to set one
      if (stored) localStorage.removeItem('globalChatUsername');
      return '';
  })();
  let globalChatState = (() => {
      const stored = localStorage.getItem('globalChatState');
      return stored || '';
  })();
  let customMyBubbleColor = localStorage.getItem('globalChatMyBubbleColor') || '';
  let reactionsById = {};
  const reactionListNodes = new Map();

  function isValidChatName(name) {
      const n = (name || '').trim();
      if (n.length < 3) return false;
      if (/^user\d{3,}$/i.test(n)) return false;
      return true;
  }

  function isNameBlocked(name) {
      return isBlockedMessage(name || '');
  }
  
  function getDisplayName(name) {
      if (!name) return 'User';
      // If name is %Owner%, display as Owner
      if (name.trim() === '%Owner%') return 'Owner';
      // Otherwise return the name as-is
      return name;
  }

  function parseChatContentJson(rawContent) {
      try {
          const parsed = JSON.parse(rawContent);
          if (parsed && typeof parsed === 'object') return parsed;
      } catch (_) {}
      return null;
  }

  // -------- Voice Chat (PeerJS + Supabase Realtime Presence) --------
  // NOTE: Voice traffic is peer-to-peer (WebRTC). Supabase is used only for presence + moderation/report events.
  const VOICE_ROOM_ID = 'global';
  const VOICE_REPORT_TYPE = 'voice_report';
  const VOICE_MOD_TYPE = 'voice_mod';

  // Voice moderation state (client-enforced, driven by %Owner% events)
  const VOICE_MOD_STATE_KEY = 'voice_mod_state_v1';
  function loadVoiceModState() {
      try {
          const raw = localStorage.getItem(VOICE_MOD_STATE_KEY);
          const parsed = JSON.parse(raw || '{}');
          const bans = parsed?.bans && typeof parsed.bans === 'object' ? parsed.bans : {};
          const timeouts = parsed?.timeouts && typeof parsed.timeouts === 'object' ? parsed.timeouts : {};
          return { bans, timeouts };
      } catch (_) {
          return { bans: {}, timeouts: {} };
      }
  }
  function saveVoiceModState(state) {
      try { localStorage.setItem(VOICE_MOD_STATE_KEY, JSON.stringify(state || { bans: {}, timeouts: {} })); } catch (_) {}
  }
  function pruneVoiceModState(state) {
      const now = Date.now();
      const next = state || { bans: {}, timeouts: {} };
      const timeouts = next.timeouts || {};
      Object.keys(timeouts).forEach((k) => {
          const until = Number(timeouts[k] || 0);
          if (!until || until <= now) delete timeouts[k];
      });
      next.timeouts = timeouts;
      return next;
  }
  function getVoiceBlockReason(userId) {
      const uid = String(userId || '');
      if (!uid) return { blocked: false };
      const state = pruneVoiceModState(loadVoiceModState());
      saveVoiceModState(state);
      if (state.bans && state.bans[uid]) return { blocked: true, type: 'ban' };
      const until = state.timeouts ? Number(state.timeouts[uid] || 0) : 0;
      if (until && until > Date.now()) return { blocked: true, type: 'timeout', until };
      return { blocked: false };
  }

  // Report UI (works even when you're not in voice)
  let voiceReportModalEl = null;
  let voiceReportsInboxEl = null;

  function ensureVoiceReportModal() {
      if (voiceReportModalEl) return voiceReportModalEl;
      const overlay = document.createElement('div');
      overlay.id = 'voiceReportModal';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.zIndex = '999997';
      overlay.style.display = 'none';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.padding = '16px';
      overlay.style.background = 'rgba(0,0,0,0.62)';
      overlay.style.backdropFilter = 'blur(6px)';
      overlay.innerHTML = `
        <div style="width:min(560px, 96vw); border-radius:16px; border:1px solid rgba(255,255,255,0.14); background:linear-gradient(180deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98)); box-shadow:0 24px 80px rgba(0,0,0,0.55); padding:14px 14px 12px;">
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:10px;">
            <div>
              <div style="font-weight:950; font-size:15px; color:#e2e8f0;">Report user</div>
              <div data-report-target="1" style="margin-top:6px; font-size:12px; color:rgba(226,232,240,0.78); line-height:1.35;"></div>
            </div>
            <button data-report-close="1" style="border:none; background:rgba(255,255,255,0.06); color:rgba(226,232,240,0.9); font-weight:900; border-radius:10px; padding:8px 10px; cursor:pointer;">Close</button>
          </div>

          <div style="margin-top:12px;">
            <div style="font-size:12px; font-weight:900; color:rgba(226,232,240,0.85); margin-bottom:6px;">Reason (required)</div>
            <textarea data-report-reason="1" rows="4" placeholder="Explain what happened…" style="width:100%; box-sizing:border-box; resize:vertical; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.05); color:#e5e7eb; padding:10px 10px; font-size:13px; outline:none;"></textarea>
            <div data-report-hint="1" style="margin-top:8px; font-size:12px; color:rgba(226,232,240,0.70);"></div>
          </div>

          <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;">
            <button data-report-timeout="1" style="display:none; padding:10px 12px; border:none; border-radius:12px; background:rgba(251,191,36,0.16); color:#fde68a; font-weight:950; cursor:pointer;">Timeout</button>
            <button data-report-ban="1" style="display:none; padding:10px 12px; border:none; border-radius:12px; background:rgba(239,68,68,0.18); color:#fecaca; font-weight:950; cursor:pointer;">Ban</button>
            <button data-report-submit="1" style="padding:10px 12px; border:none; border-radius:12px; background:linear-gradient(135deg, rgba(59,130,246,0.95), rgba(37,99,235,0.92)); color:#07121a; font-weight:950; cursor:pointer;">Submit report</button>
          </div>
        </div>
      `;
      overlay.addEventListener('click', (e) => {
          if (e.target === overlay) overlay.style.display = 'none';
      });
      document.body.appendChild(overlay);
      voiceReportModalEl = overlay;
      return overlay;
  }

  async function submitVoiceReport(reportedUserId, reason) {
      const payload = {
          type: VOICE_REPORT_TYPE,
          room: VOICE_ROOM_ID,
          reportedUserId: String(reportedUserId || ''),
          reporterUserId: String(globalChatUsername || ''),
          reason: String(reason || ''),
          ts: Date.now()
      };
      // Send via Worker WebSocket
      if (chatWorkerWs && chatWorkerWs.readyState === WebSocket.OPEN) {
          try {
              chatWorkerWs.send(JSON.stringify({
                  type: 'chat',
                  name: globalChatUsername || 'User',
                  text: '', // Empty text for moderation events
                  payload: payload
              }));
              return true;
          } catch (err) {
              console.warn('Report send failed', err);
              return false;
          }
      } else {
          console.warn('Worker WebSocket not connected for voice report');
          return false;
      }
  }

  async function sendVoiceModAction(action, targetUserId, opts = {}) {
      if (globalChatUsername !== '%Owner%') {
          showChatNotice('Only the owner can do that.', true);
          return false;
      }
      const payload = {
          type: VOICE_MOD_TYPE,
          room: VOICE_ROOM_ID,
          action: String(action || ''),
          targetUserId: String(targetUserId || ''),
          untilTs: opts?.untilTs ? Number(opts.untilTs) : 0,
          reason: String(opts?.reason || ''),
          ts: Date.now()
      };
      // Send via Worker WebSocket
      if (chatWorkerWs && chatWorkerWs.readyState === WebSocket.OPEN) {
          try {
              chatWorkerWs.send(JSON.stringify({
                  type: 'chat',
                  name: '%Owner%',
                  text: '', // Empty text for moderation events
                  payload: payload
              }));
              return true;
          } catch (err) {
              console.warn('Voice mod send failed', err);
              return false;
          }
      } else {
          console.warn('Worker WebSocket not connected for voice mod action');
          return false;
      }
  }

  async function openVoiceReportModal(reportedUserId, prefillReason = '') {
      ensureVoiceReportModal();
      const el = voiceReportModalEl;
      const closeBtn = el.querySelector('[data-report-close="1"]');
      const submitBtn = el.querySelector('[data-report-submit="1"]');
      const timeoutBtn = el.querySelector('[data-report-timeout="1"]');
      const banBtn = el.querySelector('[data-report-ban="1"]');
      const targetEl = el.querySelector('[data-report-target="1"]');
      const reasonEl = el.querySelector('[data-report-reason="1"]');
      const hint = el.querySelector('[data-report-hint="1"]');
      const targetUserId = String(reportedUserId || '');
      const name = getDisplayName(targetUserId || 'User');
      if (targetEl) targetEl.textContent = `Reporting: ${name}`;
      if (hint) hint.textContent = '';
      if (reasonEl) reasonEl.value = String(prefillReason || '');
      el.style.display = 'flex';

      const isOwner = globalChatUsername === '%Owner%';
      if (timeoutBtn) timeoutBtn.style.display = isOwner ? 'inline-block' : 'none';
      if (banBtn) banBtn.style.display = isOwner ? 'inline-block' : 'none';

      const cleanup = () => {
          closeBtn?.removeEventListener('click', onClose);
          submitBtn?.removeEventListener('click', onSubmit);
          timeoutBtn?.removeEventListener('click', onTimeout);
          banBtn?.removeEventListener('click', onBan);
      };
      const onClose = () => {
          el.style.display = 'none';
          cleanup();
      };
      const onSubmit = async () => {
          const reason = String(reasonEl?.value || '').trim();
          if (!reason) {
              if (hint) hint.textContent = 'Reason is required.';
              return;
          }
          if (hint) hint.textContent = 'Submitting…';
          const ok = await submitVoiceReport(targetUserId, reason);
          if (!ok) {
              if (hint) hint.textContent = 'Failed to submit report. Try again.';
              return;
          }
          el.style.display = 'none';
          cleanup();
          showChatNotice('Report submitted.', false);
      };
      const onTimeout = async () => {
          const minsStr = prompt(`Timeout ${name} for how many minutes?`, '10');
          const mins = Number(minsStr || 0);
          if (!isFinite(mins) || mins <= 0) return;
          const clamped = Math.max(1, Math.min(24 * 60, Math.floor(mins)));
          await sendVoiceModAction('timeout', targetUserId, { untilTs: Date.now() + clamped * 60 * 1000, reason: 'From report' });
          showChatNotice(`Timed out ${name} (${clamped}m).`, false);
      };
      const onBan = async () => {
          const ok = confirm(`Ban ${name} from voice chat?`);
          if (!ok) return;
          await sendVoiceModAction('ban', targetUserId, { reason: 'From report' });
          showChatNotice(`Banned ${name} from voice.`, false);
      };

      closeBtn?.addEventListener('click', onClose);
      submitBtn?.addEventListener('click', onSubmit);
      timeoutBtn?.addEventListener('click', onTimeout);
      banBtn?.addEventListener('click', onBan);
  }

  function ensureVoiceReportsInboxModal() {
      if (voiceReportsInboxEl) return voiceReportsInboxEl;
      const overlay = document.createElement('div');
      overlay.id = 'voiceReportsInbox';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.zIndex = '999996';
      overlay.style.display = 'none';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.padding = '16px';
      overlay.style.background = 'rgba(0,0,0,0.62)';
      overlay.style.backdropFilter = 'blur(6px)';
      overlay.innerHTML = `
        <div style="width:min(760px, 96vw); max-height:82vh; overflow:auto; border-radius:16px; border:1px solid rgba(255,255,255,0.14); background:linear-gradient(180deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98)); box-shadow:0 24px 80px rgba(0,0,0,0.55); padding:14px 14px 12px;">
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:10px;">
            <div>
              <div style="font-weight:950; font-size:15px; color:#e2e8f0;">Voice Reports</div>
              <div style="margin-top:6px; font-size:12px; color:rgba(226,232,240,0.78); line-height:1.35;">Owner-only. Ban/timeout directly from a report.</div>
            </div>
            <button data-reports-close="1" style="border:none; background:rgba(255,255,255,0.06); color:rgba(226,232,240,0.9); font-weight:900; border-radius:10px; padding:8px 10px; cursor:pointer;">Close</button>
          </div>
          <div data-reports-list="1" style="margin-top:12px; display:flex; flex-direction:column; gap:10px;"></div>
          <div style="margin-top:12px; display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap;">
            <button data-reports-clear="1" style="border:none; background:rgba(239,68,68,0.14); color:#fecaca; font-weight:950; border-radius:12px; padding:10px 12px; cursor:pointer;">Clear</button>
          </div>
        </div>
      `;
      overlay.addEventListener('click', (e) => {
          if (e.target === overlay) overlay.style.display = 'none';
      });
      document.body.appendChild(overlay);
      voiceReportsInboxEl = overlay;
      return overlay;
  }

  function renderVoiceReportsInbox() {
      if (!voiceReportsInboxEl) return;
      const listEl = voiceReportsInboxEl.querySelector('[data-reports-list="1"]');
      if (!listEl) return;
      const list = loadVoiceReportsInbox();
      listEl.innerHTML = '';
      if (list.length === 0) {
          const empty = document.createElement('div');
          empty.textContent = 'No reports yet.';
          empty.style.color = 'rgba(226,232,240,0.75)';
          empty.style.fontSize = '13px';
          empty.style.fontWeight = '800';
          listEl.appendChild(empty);
          return;
      }
      list.forEach((r) => {
          const card = document.createElement('div');
          card.style.border = '1px solid rgba(255,255,255,0.12)';
          card.style.borderRadius = '14px';
          card.style.background = 'rgba(255,255,255,0.04)';
          card.style.padding = '12px';
          card.style.display = 'flex';
          card.style.flexDirection = 'column';
          card.style.gap = '8px';

          const header = document.createElement('div');
          header.style.display = 'flex';
          header.style.justifyContent = 'space-between';
          header.style.gap = '10px';
          header.style.flexWrap = 'wrap';
          const who = document.createElement('div');
          who.style.fontWeight = '950';
          who.style.color = '#e2e8f0';
          who.style.fontSize = '13px';
          who.textContent = `${getDisplayName(r.reportedUserId)} (reported by ${getDisplayName(r.reporterUserId)})`;
          const when = document.createElement('div');
          when.style.color = 'rgba(226,232,240,0.65)';
          when.style.fontSize = '12px';
          when.style.fontWeight = '800';
          when.textContent = formatChatTime(r.ts || Date.now());
          header.appendChild(who);
          header.appendChild(when);

          const reason = document.createElement('div');
          reason.style.color = 'rgba(226,232,240,0.82)';
          reason.style.fontSize = '13px';
          reason.textContent = String(r.reason || '');

          const actions = document.createElement('div');
          actions.style.display = 'flex';
          actions.style.gap = '10px';
          actions.style.flexWrap = 'wrap';
          actions.style.justifyContent = 'flex-end';
          const open = document.createElement('button');
          open.textContent = 'Open';
          open.style.border = 'none';
          open.style.background = 'rgba(59,130,246,0.18)';
          open.style.color = '#bfdbfe';
          open.style.fontWeight = '950';
          open.style.borderRadius = '12px';
          open.style.padding = '8px 10px';
          open.style.cursor = 'pointer';
          open.addEventListener('click', (e) => {
              e.preventDefault();
              openVoiceReportModal(String(r.reportedUserId || ''), String(r.reason || ''));
          });
          const timeout = document.createElement('button');
          timeout.textContent = 'Timeout';
          timeout.style.border = 'none';
          timeout.style.background = 'rgba(251,191,36,0.16)';
          timeout.style.color = '#fde68a';
          timeout.style.fontWeight = '950';
          timeout.style.borderRadius = '12px';
          timeout.style.padding = '8px 10px';
          timeout.style.cursor = 'pointer';
          timeout.addEventListener('click', async (e) => {
              e.preventDefault();
              const minsStr = prompt(`Timeout ${getDisplayName(r.reportedUserId)} for how many minutes?`, '10');
              const mins = Number(minsStr || 0);
              if (!isFinite(mins) || mins <= 0) return;
              const clamped = Math.max(1, Math.min(24 * 60, Math.floor(mins)));
              await sendVoiceModAction('timeout', r.reportedUserId, { untilTs: Date.now() + clamped * 60 * 1000, reason: 'From report inbox' });
          });
          const ban = document.createElement('button');
          ban.textContent = 'Ban';
          ban.style.border = 'none';
          ban.style.background = 'rgba(239,68,68,0.18)';
          ban.style.color = '#fecaca';
          ban.style.fontWeight = '950';
          ban.style.borderRadius = '12px';
          ban.style.padding = '8px 10px';
          ban.style.cursor = 'pointer';
          ban.addEventListener('click', async (e) => {
              e.preventDefault();
              const ok = confirm(`Ban ${getDisplayName(r.reportedUserId)} from voice chat?`);
              if (!ok) return;
              await sendVoiceModAction('ban', r.reportedUserId, { reason: 'From report inbox' });
          });
          actions.appendChild(open);
          actions.appendChild(timeout);
          actions.appendChild(ban);

          card.appendChild(header);
          card.appendChild(reason);
          card.appendChild(actions);
          listEl.appendChild(card);
      });
  }

  function openVoiceReportsInbox() {
      if (globalChatUsername !== '%Owner%') return;
      ensureVoiceReportsInboxModal();
      renderVoiceReportsInbox();
      voiceReportsInboxEl.style.display = 'flex';
      const closeBtn = voiceReportsInboxEl.querySelector('[data-reports-close="1"]');
      const clearBtn = voiceReportsInboxEl.querySelector('[data-reports-clear="1"]');
      const onClose = () => {
          voiceReportsInboxEl.style.display = 'none';
          closeBtn?.removeEventListener('click', onClose);
          clearBtn?.removeEventListener('click', onClear);
      };
      const onClear = () => {
          const ok = confirm('Clear all saved reports on this device?');
          if (!ok) return;
          saveVoiceReportsInbox([]);
          renderVoiceReportsInbox();
      };
      closeBtn?.addEventListener('click', onClose);
      clearBtn?.addEventListener('click', onClear);
  }

  // Owner-only Reports button (lets you ban/timeout directly from incoming reports)
  let ownerReportsBtnEl = null;
  function ensureOwnerReportsButton() {
      if (ownerReportsBtnEl) return ownerReportsBtnEl;
      if (!globalChatSettingsBtn || !globalChatSettingsBtn.parentElement) return null;
      const btn = document.createElement('button');
      btn.id = 'ownerReportsBtn';
      btn.type = 'button';
      btn.textContent = 'Reports';
      btn.style.padding = '10px 12px';
      btn.style.border = 'none';
      btn.style.borderRadius = '10px';
      btn.style.background = 'rgba(59,130,246,0.18)';
      btn.style.color = '#bfdbfe';
      btn.style.fontWeight = '900';
      btn.style.cursor = 'pointer';
      btn.style.display = 'none';
      btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          openVoiceReportsInbox();
      });
      globalChatSettingsBtn.parentElement.insertBefore(btn, globalChatSettingsBtn);
      ownerReportsBtnEl = btn;
      return btn;
  }
  function updateOwnerReportsButtonVisibility() {
      ensureOwnerReportsButton();
      if (!ownerReportsBtnEl) return;
      ownerReportsBtnEl.style.display = (globalChatUsername === '%Owner%') ? 'inline-flex' : 'none';
  }

  // -------- Voice runtime (full) --------
  // PeerJS docs: https://peerjs.com/
  // Level/speaking sync now uses PeerJS data channels (P2P), not Supabase broadcasts.
  const VOICE_SPEAKING_RMS_THRESHOLD = 0.008;
  const VOICE_SPEAKING_LEVEL_THRESHOLD = 0.02;
  const VOICE_SPEAKING_HOLD_MS = 260;
  const VOICE_LEVEL_SEND_INTERVAL_MS = 120;
  let peerJsLoadPromise = null;
  let voicePeer = null;
  let voicePeerId = '';
  let voiceJoined = false;
  let voiceLocalStream = null;
  let voiceMuted = false;
  let voiceRtChannel = null;
  let voiceRtSubscribed = false;
  // Observer channel: lets users see current voice participants before joining
  let voiceObserverChannel = null;
  let voiceObserverKey = '';
  const voiceCalls = new Map(); // peerId -> call
  const voiceDataConns = new Map(); // peerId -> PeerJS DataConnection
  const voiceParticipants = new Map(); // peerId -> { userId, lastSeen, lastSpokeTs, speaking, connected, lastBroadcastTs, level, lastLevelTs, muted }
  let voiceParticipantsLoading = false;

  function cleanupVoiceDataConn(peerId) {
      const dc = voiceDataConns.get(peerId);
      if (dc) {
          try { dc.close(); } catch (_) {}
      }
      voiceDataConns.delete(peerId);
  }

  function handleVoiceDataMessage(fromPeerId, msg) {
      try {
          if (!fromPeerId || !msg || typeof msg !== 'object') return;
          const type = String(msg.type || '');
          const now = Date.now();
          const info = voiceParticipants.get(fromPeerId) || { userId: '', lastSeen: now, lastSpokeTs: 0, speaking: false, connected: false, lastBroadcastTs: 0, level: 0, lastLevelTs: 0, muted: false };
          if (type === 'level') {
              const lvl = Math.max(0, Math.min(1, Number(msg.level) || 0));
              const muted = !!msg.muted;
              const next = { ...info, lastSeen: now, level: muted ? 0 : lvl, lastLevelTs: now, muted: muted };
              voiceParticipants.set(fromPeerId, next);
              setParticipantLevel(fromPeerId, muted ? 0 : lvl, now);
              if (muted) setParticipantSpeaking(fromPeerId, false);
              return;
          }
          if (type === 'speaking') {
              const speaking = !!msg.speaking;
              const next = {
                  ...info,
                  lastSeen: now,
                  lastBroadcastTs: now,
                  lastSpokeTs: speaking ? now : (info.lastSpokeTs || 0),
                  speaking: speaking && !info.muted
              };
              voiceParticipants.set(fromPeerId, next);
              setParticipantSpeaking(fromPeerId, next.speaking);
              return;
          }
      } catch (_) {}
  }

  function setupVoiceDataConn(conn) {
      if (!conn) return;
      const remoteId = String(conn.peer || '');
      if (!remoteId) return;
      const existing = voiceDataConns.get(remoteId);
      if (existing && existing !== conn) {
          try { existing.close(); } catch (_) {}
      }
      voiceDataConns.set(remoteId, conn);
      try {
          conn.on('data', (data) => handleVoiceDataMessage(remoteId, data));
          conn.on('close', () => cleanupVoiceDataConn(remoteId));
          conn.on('error', () => cleanupVoiceDataConn(remoteId));
      } catch (_) {}
  }

  function maybeEnsureVoiceDataConn(remotePeerId) {
      if (!voiceJoined || !voicePeer || !voicePeerId) return;
      if (!remotePeerId || remotePeerId === voicePeerId) return;
      const existing = voiceDataConns.get(remotePeerId);
      if (existing && existing.open) return;
      // Avoid double-connecting: only initiate when our peerId sorts lower
      if (String(voicePeerId) > String(remotePeerId)) return;
      try {
          const conn = voicePeer.connect(remotePeerId, { reliable: false, metadata: { room: VOICE_ROOM_ID } });
          setupVoiceDataConn(conn);
      } catch (_) {}
  }

  function broadcastVoiceData(msg) {
      try {
          voiceDataConns.forEach((conn) => {
              try {
                  if (!conn || !conn.open) return;
                  conn.send(msg);
              } catch (_) {}
          });
      } catch (_) {}
  }

  // --- Firebase Realtime Database for Voice Chat Presence ---
  // Firebase is now the primary system for participant discovery
  // Cloudflare is optional for notifications only
  const VOICE_DISCOVERY_WS_URL = String(window.__VOICE_DISCOVERY_WS_URL__ || '').trim();
  const VOICE_DISCOVERY_ENABLED = !!VOICE_DISCOVERY_WS_URL;
  
  // Firebase Realtime Database references for voice chat
  let voiceFirebaseRef = null;
  let voiceFirebasePresenceRef = null;
  let voiceFirebaseListeners = [];
  let voiceDiscoveryWs = null;
  let voiceDiscoveryMode = 'off'; // 'observer' | 'joined' | 'off'
  let voiceDiscoveryConnectPromise = null;
  let voiceDiscoveryPingTimer = null;
  let voiceDiscoveryReconnectTimer = null;

  function buildVoiceDiscoveryUrl() {
      try {
          const u = new URL(VOICE_DISCOVERY_WS_URL);
          u.searchParams.set('room', VOICE_ROOM_ID);
          return u.toString();
      } catch (_) {
          return VOICE_DISCOVERY_WS_URL;
      }
  }

  function stopVoiceDiscoverySocket() {
      if (voiceDiscoveryReconnectTimer) {
          try { clearTimeout(voiceDiscoveryReconnectTimer); } catch (_) {}
          voiceDiscoveryReconnectTimer = null;
      }
      if (voiceDiscoveryPingTimer) {
          try { clearInterval(voiceDiscoveryPingTimer); } catch (_) {}
          voiceDiscoveryPingTimer = null;
      }
      const ws = voiceDiscoveryWs;
      voiceDiscoveryWs = null;
      voiceDiscoveryMode = 'off';
      voiceDiscoveryConnectPromise = null;
      if (ws) {
          try { ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null; } catch (_) {}
          try { ws.close(); } catch (_) {}
      }
  }

  function sendVoiceDiscovery(obj) {
      try {
          if (!voiceDiscoveryWs || voiceDiscoveryWs.readyState !== 1) return false;
          voiceDiscoveryWs.send(JSON.stringify(obj));
          return true;
      } catch (_) {
          return false;
      }
  }

  function applyVoiceDiscoverySnapshot(list, room) {
      try {
          if (room && String(room) !== String(VOICE_ROOM_ID)) return;
          const now = Date.now();
          const incoming = Array.isArray(list) ? list : [];
          const seen = new Set();

          incoming.forEach((p) => {
              const pid = String(p?.peerId || '');
              const userId = String(p?.userId || '');
              if (!pid || !userId) return;
              seen.add(pid);
              const prev = voiceParticipants.get(pid) || { userId: '', lastSeen: now, lastSpokeTs: 0, speaking: false, connected: false, lastBroadcastTs: 0, level: 0, lastLevelTs: 0, muted: false };
              voiceParticipants.set(pid, {
                  ...prev,
                  userId,
                  lastSeen: Number(p?.ts || now) || now,
                  muted: !!p?.muted,
                  connected: true
              });
          });

          // Remove anyone not in the snapshot (except self if joined but snapshot is late)
          Array.from(voiceParticipants.keys()).forEach((pid) => {
              if (voiceJoined && pid === voicePeerId) return;
              if (!seen.has(pid)) {
                  cleanupVoiceCall(pid);
                  voiceParticipants.delete(pid);
              }
          });

          // Clear loading state when participants are received
          if (voiceParticipantsLoading) {
              voiceParticipantsLoading = false;
          }

          renderVoiceParticipants();
          if (voiceJoined) {
              voiceParticipants.forEach((_info, pid) => {
                  maybeCallPeer(pid);
                  maybeEnsureVoiceDataConn(pid);
              });
              // Periodically check and ensure all participants have active calls
              // More aggressive retries for late joiners
              setTimeout(() => {
                  if (voiceJoined) {
                      voiceParticipants.forEach((_info, pid) => {
                          if (pid !== voicePeerId && !voiceCalls.has(pid)) {
                              maybeCallPeer(pid);
                          }
                      });
                  }
              }, 1000);
              setTimeout(() => {
                  if (voiceJoined) {
                      voiceParticipants.forEach((_info, pid) => {
                          if (pid !== voicePeerId && !voiceCalls.has(pid)) {
                              maybeCallPeer(pid);
                          }
                      });
                  }
              }, 3000);
              setTimeout(() => {
                  if (voiceJoined) {
                      voiceParticipants.forEach((_info, pid) => {
                          if (pid !== voicePeerId && !voiceCalls.has(pid)) {
                              maybeCallPeer(pid);
                          }
                      });
                  }
              }, 6000);
          }
      } catch (_) {}
  }

  function scheduleVoiceDiscoveryReconnect(mode) {
      if (!VOICE_DISCOVERY_ENABLED) return;
      if (voiceDiscoveryReconnectTimer) return;
      voiceDiscoveryReconnectTimer = setTimeout(() => {
          voiceDiscoveryReconnectTimer = null;
          try { ensureVoiceDiscoverySocket(mode); } catch (_) {}
      }, 1200);
  }

  function ensureVoiceDiscoverySocket(mode) {
      if (!VOICE_DISCOVERY_ENABLED) return null;
      const desired = (mode === 'joined') ? 'joined' : 'observer';

      // Keep existing connection if it's already for this mode and still alive/connecting
      if (voiceDiscoveryWs && voiceDiscoveryMode === desired) {
          if (voiceDiscoveryWs.readyState === 0 || voiceDiscoveryWs.readyState === 1) return voiceDiscoveryWs;
      }

      stopVoiceDiscoverySocket();
      voiceDiscoveryMode = desired;

      if (voiceDiscoveryConnectPromise) return voiceDiscoveryWs;
      voiceDiscoveryConnectPromise = Promise.resolve().then(() => {
          const url = buildVoiceDiscoveryUrl();
          const ws = new WebSocket(url);
          voiceDiscoveryWs = ws;

          ws.onopen = () => {
              try {
                  if (voiceDiscoveryPingTimer) {
                      try { clearInterval(voiceDiscoveryPingTimer); } catch (_) {}
                  }
                  
                  // Set up ping timer that also requests participants periodically
                  // Reduced frequency to avoid Cloudflare rate limits
                  voiceDiscoveryPingTimer = setInterval(() => {
                      try {
                          if (voiceDiscoveryWs && voiceDiscoveryWs.readyState === 1) {
                              sendVoiceDiscovery({ type: 'ping', ts: Date.now() });
                              // Request participants less frequently to avoid rate limits (every 30 seconds)
                              // Only if we're joined or observing
                              if (voiceDiscoveryMode !== 'off') {
                                  sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                              }
                          }
                      } catch (_) {}
                  }, 30000); // Request participants every 30 seconds (reduced from 10s to avoid rate limits)

                  // Request participants immediately when socket opens (for both observer and joined modes)
                  sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                  
                  // If we're in joined mode and already have peerId, send join immediately
                  if (voiceDiscoveryMode === 'joined' && voiceJoined && voicePeerId) {
                      sendVoiceDiscovery({ type: 'join', peerId: voicePeerId, userId: globalChatUsername || 'User', muted: !!voiceMuted, ts: Date.now() });
                      // Request again after join (reduced frequency to avoid rate limits)
                      setTimeout(() => {
                          sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                      }, 500);
                      setTimeout(() => {
                          sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                      }, 2000);
                  } else if (voiceDiscoveryMode === 'observer') {
                      // Request participants list when observing (reduced frequency to avoid rate limits)
                      setTimeout(() => {
                          sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                      }, 500);
                      setTimeout(() => {
                          sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                      }, 2000);
                  }
              } catch (_) {}
          };

          ws.onmessage = (evt) => {
              try {
                  const data = JSON.parse(String(evt.data || '{}'));
                  const t = String(data?.type || '');
                  if (t === 'participants') {
                      applyVoiceDiscoverySnapshot(data?.list, data?.room);
                      return;
                  }
                  if (t === 'activity') {
                      const action = String(data?.action || '');
                      const userId = String(data?.userId || '');
                      const peerId = String(data?.peerId || '');
                      const muted = !!data?.muted;
                      const ts = Number(data?.ts || Date.now()) || Date.now();
                      
                      if (action === 'join' && userId && peerId) {
                          showVoiceActivity(`${getDisplayName(userId)} joined voice chat`);
                          // Update participants list immediately when someone joins
                          const now = Date.now();
                          const prev = voiceParticipants.get(peerId) || { userId: '', lastSeen: now, lastSpokeTs: 0, speaking: false, connected: false, lastBroadcastTs: 0, level: 0, lastLevelTs: 0, muted: false };
                          voiceParticipants.set(peerId, {
                              ...prev,
                              userId,
                              lastSeen: ts || now,
                              muted: muted,
                              connected: true
                          });
                          // Clear loading state when someone joins
                          if (voiceParticipantsLoading) {
                              voiceParticipantsLoading = false;
                          }
                          renderVoiceParticipants();
                          // If we're joined, try to call the new participant
                          if (voiceJoined && peerId !== voicePeerId) {
                              maybeCallPeer(peerId);
                              maybeEnsureVoiceDataConn(peerId);
                          }
                      }
                      else if (action === 'leave' && userId && peerId) {
                          showVoiceActivity(`${getDisplayName(userId)} left voice chat`);
                          // Remove from participants list immediately
                          cleanupVoiceCall(peerId);
                          voiceParticipants.delete(peerId);
                          renderVoiceParticipants();
                      }
                      return;
                  }
              } catch (_) {}
          };

          ws.onerror = (error) => {
              console.warn('Cloudflare WebSocket error:', error);
              // Check if it's a rate limit (429) or connection issue
              scheduleVoiceDiscoveryReconnect(desired);
          };

          ws.onclose = (event) => {
              // If closed abnormally (not 1000), it might be rate limiting or connection issue
              if (event.code !== 1000 && event.code !== 1001) {
                  console.warn('WebSocket closed abnormally, might be rate limited:', event.code, event.reason);
              }
              scheduleVoiceDiscoveryReconnect(desired);
          };
      }).finally(() => {
          voiceDiscoveryConnectPromise = null;
      });

      return voiceDiscoveryWs;
  }

  function ensureVoiceDiscoveryObserver() {
      return ensureVoiceDiscoverySocket('observer');
  }

  function ensureVoiceDiscoveryJoined() {
      return ensureVoiceDiscoverySocket('joined');
  }

  // Local mic meter (Web Audio analyser)
  let voiceAudioCtx = null;
  let voiceAnalyser = null;
  let voiceMeterRaf = null;
  let voiceLocalSpeaking = false;
  let voiceLocalLastSpeakingSendTs = 0;
  let voiceLocalLastLevelSendTs = 0;
  let voiceNoiseFloor = 0;
  let voiceNoiseFloorInitTs = 0;

  // Remote speaking detection (fallback, if broadcast packets are missed)
  let voiceRemoteAudioCtx = null;
  const voiceRemoteAnalysers = new Map(); // peerId -> { analyser, data }
  let voiceRemoteMeterRaf = null;

  // Local-only mutes (you can't hear specific peers; doesn't affect others)
  const VOICE_LOCAL_MUTES_KEY = 'voice_local_mutes_v1';
  let voiceLocallyMutedPeers = new Set();

  // Age gate / terms consent (localStorage-enforced UI gate)
  const VOICE_GATE_KEY = 'voice_gate_v1';
  // values: 'adult_accepted' | 'under18_declined'
  let voiceGateModalEl = null;

  // Join/leave notifications for everyone on chat pages
  const VOICE_BROADCAST_ACTIVITY_EVENT = 'activity';
  let voiceActivityEl = null;
  let voiceActivityTimer = null;
  let voiceActivityChannel = null;
  const voiceActivityLastTsByUser = new Map();
  const VOICE_ACTIVITY_HEARTBEAT_MS = 12000;
  const VOICE_ACTIVITY_STALE_MS = 28000;
  let voiceActivityHeartbeatTimer = null;

  function stopVoiceActivityHeartbeats() {
      if (voiceActivityHeartbeatTimer) {
          try { clearInterval(voiceActivityHeartbeatTimer); } catch (_) {}
          voiceActivityHeartbeatTimer = null;
      }
  }

  function pruneStaleVoiceParticipants() {
      try {
          const now = Date.now();
          let changed = false;
          voiceParticipants.forEach((info, pid) => {
              if (!pid) return;
              // Never prune yourself while joined
              if (voiceJoined && pid === voicePeerId) return;
              const last = Number(info?.lastSeen || 0) || 0;
              if (last && (now - last) > VOICE_ACTIVITY_STALE_MS) {
                  cleanupVoiceCall(pid);
                  voiceParticipants.delete(pid);
                  changed = true;
              }
          });
          if (changed) renderVoiceParticipants();
      } catch (_) {}
  }

  function startVoiceActivityHeartbeats() {
      // Skip Supabase heartbeats if Cloudflare discovery is enabled
      if (VOICE_DISCOVERY_ENABLED) return;
      if (voiceActivityHeartbeatTimer) return;
      voiceActivityHeartbeatTimer = setInterval(() => {
          try {
              if (!voiceJoined || !voicePeerId || !voiceActivityChannel) return;
              pruneStaleVoiceParticipants();
              voiceActivityChannel.send({
                  type: 'broadcast',
                  event: VOICE_BROADCAST_ACTIVITY_EVENT,
                  payload: { action: 'heartbeat', peerId: voicePeerId, userId: globalChatUsername || 'User', muted: !!voiceMuted, ts: Date.now() }
              });
          } catch (_) {}
      }, VOICE_ACTIVITY_HEARTBEAT_MS);
  }

  // Queue for notifications that arrive before banner is ready
  let voiceActivityQueue = [];
  
  function ensureVoiceActivityBanner() {
      if (voiceActivityEl) return voiceActivityEl;
      
      // Wait for body to exist if it doesn't yet
      const createBanner = () => {
          if (!document.body) {
              // Retry when body is available
              if (document.readyState === 'loading') {
                  document.addEventListener('DOMContentLoaded', createBanner, { once: true });
              } else {
                  setTimeout(createBanner, 50);
              }
              return null;
          }
          
          voiceActivityEl = document.createElement('div');
          voiceActivityEl.id = 'voiceActivityBanner';
          voiceActivityEl.style.position = 'fixed';
          voiceActivityEl.style.top = '56px';
          voiceActivityEl.style.left = '50%';
          voiceActivityEl.style.transform = 'translateX(-50%)';
          voiceActivityEl.style.zIndex = '29999';
          voiceActivityEl.style.padding = '10px 14px';
          voiceActivityEl.style.borderRadius = '12px';
          voiceActivityEl.style.background = 'linear-gradient(135deg, rgba(2,132,199,0.95), rgba(37,99,235,0.92))';
          voiceActivityEl.style.border = '1px solid rgba(147,197,253,0.65)';
          voiceActivityEl.style.color = '#eff6ff';
          voiceActivityEl.style.fontSize = '13px';
          voiceActivityEl.style.fontWeight = '850';
          voiceActivityEl.style.boxShadow = '0 18px 46px rgba(0,0,0,0.45)';
          voiceActivityEl.style.display = 'none';
          voiceActivityEl.style.maxWidth = 'min(820px, 92vw)';
          voiceActivityEl.style.textAlign = 'center';
          voiceActivityEl.style.userSelect = 'none';
          document.body.appendChild(voiceActivityEl);
          
          // Show any queued notifications
          if (voiceActivityQueue.length > 0) {
              const queued = voiceActivityQueue.shift();
              if (queued) showVoiceActivity(queued);
          }
          
          return voiceActivityEl;
      };
      
      return createBanner();
  }

  function showVoiceActivity(text) {
      if (!text) return;
      
      // Ensure banner exists
      if (!voiceActivityEl) {
          ensureVoiceActivityBanner();
          // If banner still doesn't exist (body not ready), queue the notification
          if (!voiceActivityEl) {
              voiceActivityQueue.push(text);
              // Keep only the most recent notification in queue
              if (voiceActivityQueue.length > 1) {
                  voiceActivityQueue.shift();
              }
              return;
          }
      }
      
      voiceActivityEl.textContent = text;
      voiceActivityEl.style.display = 'block';
      if (voiceActivityTimer) clearTimeout(voiceActivityTimer);
      voiceActivityTimer = setTimeout(() => {
          if (voiceActivityEl) voiceActivityEl.style.display = 'none';
      }, 2600);
  }

  async function ensureVoiceActivityChannel(client) {
      // Supabase removed - voice activity now handled by Cloudflare only
      // This function is kept for compatibility but does nothing
      return null;
  }

  let voiceUi = {
      built: false,
      toggleBtn: null,
      panel: null,
      joinBtn: null,
      leaveBtn: null,
      muteBtn: null,
      statusEl: null,
      listEl: null,
      audioBucket: null,
      meterCanvas: null,
      reportsBtn: null
  };
  
  // Voice volume control (default 1.0 = 100% volume)
  const VOICE_VOLUME_KEY = 'voice_volume_v1';
  // Load saved volume from localStorage, default to 1.0 (100%)
  let voiceVolume = 1.0;
  try {
    const saved = localStorage.getItem(VOICE_VOLUME_KEY);
    if (saved) {
      voiceVolume = parseFloat(saved);
      if (isNaN(voiceVolume) || voiceVolume < 0) voiceVolume = 1.0;
    }
  } catch (_) {}
  // Expose globally for volume slider access
  if (typeof window !== 'undefined') {
    window.voiceVolume = voiceVolume;
  }
  let voiceAudioGainNodes = new Map(); // Map of peerId -> GainNode
  let voiceMasterAudioCtx = null;

  async function ensurePeerJs() {
      if (window.Peer) return window.Peer;
      if (peerJsLoadPromise) return peerJsLoadPromise;
      peerJsLoadPromise = new Promise((resolve, reject) => {
          const existing = document.querySelector('script[data-peerjs]');
          if (existing && window.Peer) return resolve(window.Peer);
          const s = existing || document.createElement('script');
          if (!existing) {
              s.src = 'https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js';
              s.async = true;
              s.defer = true;
              s.crossOrigin = 'anonymous';
              s.dataset.peerjs = 'true';
              document.head.appendChild(s);
          }
          const timeout = setTimeout(() => reject(new Error('PeerJS load timeout')), 10000);
          s.onload = () => {
              clearTimeout(timeout);
              if (window.Peer) resolve(window.Peer);
              else reject(new Error('PeerJS loaded but window.Peer missing'));
          };
          s.onerror = () => {
              clearTimeout(timeout);
              reject(new Error('PeerJS script failed to load'));
          };
      }).catch((err) => {
          console.warn('PeerJS load failed', err);
          peerJsLoadPromise = null;
          return null;
      });
      return peerJsLoadPromise;
  }

  function setVoiceStatus(text, isError = false) {
      if (!voiceUi.statusEl) return;
      voiceUi.statusEl.textContent = text || '';
      voiceUi.statusEl.style.color = isError ? '#fecaca' : 'rgba(226,232,240,0.85)';
  }

  function loadVoiceVolume() {
      try {
          const stored = localStorage.getItem(VOICE_VOLUME_KEY);
          if (stored !== null) {
              const vol = parseFloat(stored);
              if (!isNaN(vol) && vol >= 0 && vol <= 3.0) {
                  voiceVolume = vol;
              }
          }
      } catch (_) {}
  }
  
  function saveVoiceVolume(vol) {
      try {
          voiceVolume = Math.max(0, Math.min(3.0, vol));
          localStorage.setItem(VOICE_VOLUME_KEY, String(voiceVolume));
          applyVoiceVolumeToAll();
      } catch (_) {}
  }
  
  function loadVoiceLocalMutes() {
      try {
          const raw = localStorage.getItem(VOICE_LOCAL_MUTES_KEY);
          const arr = JSON.parse(raw || '[]');
          voiceLocallyMutedPeers = new Set(Array.isArray(arr) ? arr.map(String) : []);
      } catch (_) {
          voiceLocallyMutedPeers = new Set();
      }
  }
  function saveVoiceLocalMutes() {
      try {
          localStorage.setItem(VOICE_LOCAL_MUTES_KEY, JSON.stringify(Array.from(voiceLocallyMutedPeers)));
      } catch (_) {}
  }
  function isPeerLocallyMuted(peerId) {
      if (!peerId) return false;
      return voiceLocallyMutedPeers.has(String(peerId));
  }
  function applyLocalMuteToAudio(peerId) {
      try {
          if (!voiceUi.audioBucket) return;
          const audio = voiceUi.audioBucket.querySelector(`audio[data-peer-id="${peerId}"]`);
          if (!audio) return;
          const gainNode = voiceAudioGainNodes.get(peerId);
          if (gainNode) {
              gainNode.gain.value = isPeerLocallyMuted(peerId) ? 0 : voiceVolume;
          } else {
              audio.volume = isPeerLocallyMuted(peerId) ? 0 : Math.min(1.0, voiceVolume);
          }
      } catch (_) {}
  }
  
  function applyVoiceVolumeToAll() {
      try {
          voiceAudioGainNodes.forEach((gainNode, peerId) => {
              if (gainNode) {
                  gainNode.gain.value = isPeerLocallyMuted(peerId) ? 0 : voiceVolume;
              }
          });
          // Also update audio elements without gain nodes
          if (voiceUi.audioBucket) {
              const audioElements = voiceUi.audioBucket.querySelectorAll('audio[data-peer-id]');
              audioElements.forEach(audio => {
                  const peerId = audio.dataset.peerId;
                  if (!voiceAudioGainNodes.has(peerId)) {
                      audio.volume = isPeerLocallyMuted(peerId) ? 0 : Math.min(1.0, voiceVolume);
                  }
              });
          }
          // Update volume display
          if (voiceUi.volumeValue) {
              voiceUi.volumeValue.textContent = Math.round(voiceVolume * 100) + '%';
          }
      } catch (_) {}
  }
  function toggleLocalMutePeer(peerId) {
      if (!peerId) return;
      const id = String(peerId);
      if (voiceLocallyMutedPeers.has(id)) voiceLocallyMutedPeers.delete(id);
      else voiceLocallyMutedPeers.add(id);
      saveVoiceLocalMutes();
      applyLocalMuteToAudio(id);
      renderVoiceParticipants();
  }

  function getVoiceGateState() {
      try { return String(localStorage.getItem(VOICE_GATE_KEY) || ''); } catch (_) { return ''; }
  }
  function setVoiceGateState(state) {
      try { localStorage.setItem(VOICE_GATE_KEY, String(state || '')); } catch (_) {}
  }

  function ensureVoiceGateModal() {
      if (voiceGateModalEl) return voiceGateModalEl;
      const overlay = document.createElement('div');
      overlay.id = 'voiceGateModal';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.zIndex = '999999';
      overlay.style.display = 'none';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.padding = '16px';
      overlay.style.background = 'rgba(0,0,0,0.65)';
      overlay.style.backdropFilter = 'blur(6px)';
      overlay.innerHTML = `
        <div style="width:min(720px, 96vw); max-height:82vh; overflow:auto; border-radius:16px; border:1px solid rgba(255,255,255,0.14); background:linear-gradient(180deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98)); box-shadow:0 24px 80px rgba(0,0,0,0.55); padding:16px 16px 14px;">
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
            <div>
              <div style="font-weight:950; letter-spacing:0.2px; font-size:16px; color:#e2e8f0;">Voice chat safety & rules</div>
              <div style="margin-top:6px; font-size:12px; color:rgba(226,232,240,0.78); line-height:1.35;">Voice chat connects you to other users live. Don’t share personal info. Others may record.</div>
            </div>
            <button data-voice-gate-close="1" style="border:none; background:rgba(255,255,255,0.06); color:rgba(226,232,240,0.9); font-weight:900; border-radius:10px; padding:8px 10px; cursor:pointer;">Close</button>
          </div>

          <div style="margin-top:12px; padding:12px; border-radius:14px; border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.04);">
            <div style="font-weight:900; color:#f1f5f9; font-size:13px;">Risks (read before joining)</div>
            <ul style="margin:8px 0 0 18px; padding:0; color:rgba(226,232,240,0.82); font-size:12px; line-height:1.35;">
              <li>People may say harmful or explicit things.</li>
              <li>Others can record audio without your permission.</li>
              <li>Sharing personal info can put you at risk.</li>
              <li>Not every session is actively moderated in real-time.</li>
            </ul>
          </div>

          <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
            <a href="/terms.html" target="_blank" rel="noopener" style="font-size:12px; font-weight:900; color:#93c5fd; text-decoration:none;">Read Terms</a>
            <a href="/privacy.html" target="_blank" rel="noopener" style="font-size:12px; font-weight:900; color:#93c5fd; text-decoration:none;">Read Privacy Policy</a>
          </div>

          <div style="margin-top:12px; padding:12px; border-radius:14px; border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.03);">
            <label style="display:flex; align-items:center; gap:8px; font-size:12px; color:rgba(226,232,240,0.9); font-weight:800;">
              <input type="checkbox" data-voice-accept="1" style="width:16px; height:16px;" />
              I have read and agree to the Terms and Privacy Policy
            </label>
            <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
              <button data-voice-age-adult="1" style="flex:1; min-width:220px; padding:10px 12px; border:none; border-radius:12px; background:linear-gradient(135deg, #10b981, #06b6d4); color:#07121a; font-weight:950; cursor:pointer;">I am 18 or older</button>
              <button data-voice-age-minor="1" style="flex:1; min-width:220px; padding:10px 12px; border:none; border-radius:12px; background:rgba(255,255,255,0.06); color:rgba(226,232,240,0.92); font-weight:950; cursor:pointer;">I am younger than 18</button>
            </div>
            <div data-voice-gate-hint="1" style="margin-top:8px; font-size:12px; color:rgba(226,232,240,0.70); line-height:1.35;"></div>
          </div>
        </div>
      `;
      overlay.addEventListener('click', (e) => {
          if (e.target === overlay) overlay.style.display = 'none';
      });
      document.body.appendChild(overlay);
      voiceGateModalEl = overlay;
      return overlay;
  }

  async function openVoiceGateModal({ afterAccept } = {}) {
      ensureVoiceGateModal();
      const el = voiceGateModalEl;
      const closeBtn = el.querySelector('[data-voice-gate-close="1"]');
      const acceptCb = el.querySelector('[data-voice-accept="1"]');
      const adultBtn = el.querySelector('[data-voice-age-adult="1"]');
      const minorBtn = el.querySelector('[data-voice-age-minor="1"]');
      const hint = el.querySelector('[data-voice-gate-hint="1"]');
      if (hint) hint.textContent = '';
      if (acceptCb) acceptCb.checked = false;
      el.style.display = 'flex';

      const cleanup = () => {
          closeBtn?.removeEventListener('click', onClose);
          adultBtn?.removeEventListener('click', onAdult);
          minorBtn?.removeEventListener('click', onMinor);
      };
      const onClose = () => { el.style.display = 'none'; cleanup(); };
      const onMinor = () => {
          setVoiceGateState('under18_declined');
          if (hint) hint.textContent = 'Okay — voice chat will not be joined. You can click Voice again if you selected this by mistake.';
          setTimeout(() => { el.style.display = 'none'; cleanup(); }, 650);
      };
      const onAdult = () => {
          if (!acceptCb?.checked) {
              if (hint) hint.textContent = 'To join voice chat, you must agree to the Terms and Privacy Policy.';
              return;
          }
          setVoiceGateState('adult_accepted');
          el.style.display = 'none';
          cleanup();
          // Open science page in about:blank wrapper
          const scienceUrl = window.location.pathname.includes('/pages/') 
              ? 'science.html' 
              : 'pages/science.html';
          if (typeof openGameInBlank === 'function') {
              openGameInBlank(scienceUrl);
          } else {
              window.open(scienceUrl, '_blank');
          }
          if (typeof afterAccept === 'function') afterAccept();
      };
      closeBtn?.addEventListener('click', onClose);
      adultBtn?.addEventListener('click', onAdult);
      minorBtn?.addEventListener('click', onMinor);
  }

  // -------- "New edition" one-time popup --------
  const NEW_EDITION_POPUP_KEY = 'new_edition_voicechat_popup_v1';
  let newEditionPopupEl = null;

  function ensureNewEditionPopup() {
      if (newEditionPopupEl) return newEditionPopupEl;
      const overlay = document.createElement('div');
      overlay.id = 'newEditionPopup';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.zIndex = '999998';
      overlay.style.display = 'none';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.padding = '16px';
      overlay.style.background = 'rgba(0,0,0,0.62)';
      overlay.style.backdropFilter = 'blur(6px)';

      overlay.innerHTML = `
        <div style="width:min(560px, 96vw); border-radius:16px; border:1px solid rgba(255,255,255,0.14); background:linear-gradient(180deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98)); box-shadow:0 24px 80px rgba(0,0,0,0.55); padding:14px 14px 12px;">
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:10px;">
            <div>
              <div style="font-weight:950; font-size:15px; color:#e2e8f0; letter-spacing:0.2px;">New edition</div>
              <div style="margin-top:6px; font-size:12px; color:rgba(226,232,240,0.78); line-height:1.35;">
                <strong>Voice chat</strong> is now available in chat. Look for the <strong>Voice</strong> button.
              </div>
            </div>
            <button data-newedition-close="1" style="border:none; background:rgba(255,255,255,0.06); color:rgba(226,232,240,0.9); font-weight:900; border-radius:10px; padding:8px 10px; cursor:pointer;">Close</button>
          </div>

          <div style="margin-top:12px; padding:12px; border-radius:14px; border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.04);">
            <div style="font-weight:900; color:#f1f5f9; font-size:13px;">Quick heads up</div>
            <ul style="margin:8px 0 0 18px; padding:0; color:rgba(226,232,240,0.82); font-size:12px; line-height:1.35;">
              <li>Voice chat is <strong>18+</strong> and requires agreeing to Terms & Privacy.</li>
              <li>Other people may record audio. Don’t share personal info.</li>
            </ul>
          </div>

          <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
            <a href="/terms.html" target="_blank" rel="noopener" style="font-size:12px; font-weight:900; color:#93c5fd; text-decoration:none;">Read Terms</a>
            <a href="/privacy.html" target="_blank" rel="noopener" style="font-size:12px; font-weight:900; color:#93c5fd; text-decoration:none;">Read Privacy Policy</a>
          </div>

          <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
            <button data-newedition-ok="1" style="padding:10px 12px; border:none; border-radius:12px; background:linear-gradient(135deg, #10b981, #06b6d4); color:#07121a; font-weight:950; cursor:pointer;">Got it</button>
          </div>
        </div>
      `;

      overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
              overlay.style.display = 'none';
              try { localStorage.setItem(NEW_EDITION_POPUP_KEY, '1'); } catch (_) {}
          }
      });
      document.body.appendChild(overlay);
      newEditionPopupEl = overlay;
      return overlay;
  }

  function showNewEditionPopupOnce() {
      try {
          if (localStorage.getItem(NEW_EDITION_POPUP_KEY) === '1') return;
      } catch (_) {}
      const el = ensureNewEditionPopup();
      el.style.display = 'flex';
      const closeBtn = el.querySelector('[data-newedition-close="1"]');
      const okBtn = el.querySelector('[data-newedition-ok="1"]');
      const finish = () => {
          el.style.display = 'none';
          try { localStorage.setItem(NEW_EDITION_POPUP_KEY, '1'); } catch (_) {}
          closeBtn?.removeEventListener('click', finish);
          okBtn?.removeEventListener('click', finish);
      };
      closeBtn?.addEventListener('click', finish);
      okBtn?.addEventListener('click', finish);
  }

  document.addEventListener('DOMContentLoaded', () => {
      showNewEditionPopupOnce();
  }, { once: true });

  function ensureVoiceUi() {
      if (voiceUi.built) return;
      voiceUi.built = true;
      loadVoiceLocalMutes();
      loadVoiceVolume();
      loadVoiceVolume();

      // Insert Voice button next to Settings button (works on chat-only page too)
      if (globalChatSettingsBtn && globalChatSettingsBtn.parentElement) {
          const btn = document.createElement('button');
          btn.id = 'globalChatVoiceBtn';
          btn.innerHTML = '<i class="fas fa-microphone"></i> Voice Chat';
          btn.style.padding = '10px 12px';
          btn.style.border = 'none';
          btn.style.borderRadius = '10px';
          btn.style.background = 'linear-gradient(135deg, #10b981, #06b6d4)';
          btn.style.color = '#07121a';
          btn.style.fontWeight = '800';
          btn.style.cursor = 'pointer';
          btn.style.display = 'flex';
          btn.style.alignItems = 'center';
          btn.style.gap = '8px';
          globalChatSettingsBtn.parentElement.insertBefore(btn, globalChatSettingsBtn);
          voiceUi.toggleBtn = btn;
      }

      const panel = document.createElement('div');
      panel.id = 'globalChatVoicePanel';
      panel.style.display = 'none';
      panel.style.padding = '12px';
      panel.style.borderRadius = '14px';
      panel.style.border = '1px solid rgba(255,255,255,0.10)';
      panel.style.background = 'rgba(255,255,255,0.04)';
      panel.style.boxShadow = 'inset 0 1px 0 rgba(255,255,255,0.06)';
      panel.style.position = 'relative';
      panel.style.width = '100%';
      panel.style.maxWidth = '100%';

      // Chat-only page: hide panel completely, never show it
      const isChatOnlyPage = window.location.pathname.includes('chat-only.html');
      if (isChatOnlyPage) {
          panel.style.display = 'none';
          panel.style.visibility = 'hidden';
          panel.style.position = 'absolute';
          panel.style.left = '-9999px';
      }

      panel.innerHTML = `
        <div style="display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap; padding-bottom:16px; border-bottom:2px solid rgba(255,255,255,0.1); margin-bottom:20px;">
          <div style="font-weight:900; letter-spacing:0.5px; color:#d1fae5; font-size:20px;">
            <i class="fas fa-headset"></i> Voice Chat
          </div>
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <button id="voiceLeaveBtn" style="padding:10px 18px; border:none; border-radius:12px; background:rgba(248,113,113,0.25); color:#fecaca; font-weight:800; cursor:pointer; display:none; font-size:14px; transition:all 0.2s;">Leave</button>
            <button id="voiceMuteBtn" style="padding:10px 18px; border:none; border-radius:12px; background:rgba(255,255,255,0.12); color:#e5e7eb; font-weight:800; cursor:pointer; display:none; font-size:14px; transition:all 0.2s;">Mute</button>
            <button id="voiceReportsBtn" style="display:none; padding:10px 18px; border:none; border-radius:12px; background:rgba(59,130,246,0.2); color:#bfdbfe; font-weight:900; cursor:pointer; font-size:14px; transition:all 0.2s;">Reports</button>
          </div>
        </div>
        <div id="voiceJoinBtnContainer" style="width:100%; display:flex !important; justify-content:center !important; align-items:center !important; margin:60px 0; padding:0;">
          <button id="voiceJoinBtn" style="padding:24px 60px; border:3px solid rgba(16,185,129,0.6); border-radius:20px; background:linear-gradient(135deg, rgba(16,185,129,0.4), rgba(6,182,212,0.4)); color:#bbf7d0; font-weight:900; font-size:24px; cursor:pointer; letter-spacing:1px; box-shadow:0 8px 30px rgba(16,185,129,0.35); transition:all 0.3s; min-width:300px;">Join Voice Chat</button>
        </div>
        <div id="voiceStatus" style="margin-top:8px; font-size:12px; color:rgba(226,232,240,0.85);"></div>
        <div style="margin-top:10px; display:flex; align-items:center; justify-content:space-between; gap:10px;">
          <div style="font-size:12px; color:rgba(226,232,240,0.75); font-weight:800;">Mic</div>
          <canvas id="voiceMeter" width="220" height="26" style="width:220px; height:26px; border-radius:999px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.10);"></canvas>
        </div>
        <div style="margin-top:20px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
          <div style="font-size:16px; color:rgba(226,232,240,0.9); font-weight:900; letter-spacing:0.5px;">Participants</div>
          <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
            <div style="font-size:12px; color:rgba(226,232,240,0.75); font-weight:800; white-space:nowrap;">Volume:</div>
            <input type="range" id="voiceVolumeSlider" min="0" max="300" value="180" step="5" style="width:120px; height:6px; border-radius:3px; background:rgba(255,255,255,0.1); outline:none; cursor:pointer; accent-color:#10b981;">
            <div id="voiceVolumeValue" style="font-size:12px; color:rgba(226,232,240,0.9); font-weight:800; min-width:45px; text-align:right;">180%</div>
          </div>
        </div>
        <div id="voiceParticipants" style="margin-top:16px; display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:16px; width:100%; padding-bottom:20px; align-items:start;"></div>
      `;

      if (globalChatPanel && globalChatBox && globalChatBox.parentElement === globalChatPanel) {
          globalChatPanel.insertBefore(panel, globalChatBox);
      } else if (globalChatPanel) {
          globalChatPanel.insertBefore(panel, globalChatPanel.firstChild || null);
      }

      voiceUi.panel = panel;
      voiceUi.joinBtn = panel.querySelector('#voiceJoinBtn');
      voiceUi.joinBtnContainer = panel.querySelector('#voiceJoinBtnContainer');
      voiceUi.leaveBtn = panel.querySelector('#voiceLeaveBtn');
      voiceUi.muteBtn = panel.querySelector('#voiceMuteBtn');
      voiceUi.statusEl = panel.querySelector('#voiceStatus');
      voiceUi.listEl = panel.querySelector('#voiceParticipants');
      voiceUi.meterCanvas = panel.querySelector('#voiceMeter');
      voiceUi.reportsBtn = panel.querySelector('#voiceReportsBtn');
      voiceUi.volumeSlider = panel.querySelector('#voiceVolumeSlider');
      voiceUi.volumeValue = panel.querySelector('#voiceVolumeValue');
      
      // Initialize volume slider
      if (voiceUi.volumeSlider) {
          voiceUi.volumeSlider.value = Math.round(voiceVolume * 100);
          if (voiceUi.volumeValue) {
              voiceUi.volumeValue.textContent = Math.round(voiceVolume * 100) + '%';
          }
          voiceUi.volumeSlider.addEventListener('input', (e) => {
              const newVol = parseFloat(e.target.value) / 100;
              saveVoiceVolume(newVol);
          });
      }

      voiceUi.audioBucket = document.createElement('div');
      voiceUi.audioBucket.style.display = 'none';
      voiceUi.audioBucket.style.position = 'absolute';
      voiceUi.audioBucket.style.left = '-9999px';
      voiceUi.audioBucket.style.width = '1px';
      voiceUi.audioBucket.style.height = '1px';
      voiceUi.audioBucket.style.overflow = 'hidden';
      document.body.appendChild(voiceUi.audioBucket); // Put in body to ensure it works

      const togglePanel = () => {
          // Chat-only page: never show panel
          const isChatOnlyPage = window.location.pathname.includes('chat-only.html');
          if (isChatOnlyPage) {
              panel.style.display = 'none';
              return;
          }
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
          if (panel.style.display !== 'none' && globalChatUsername === '%Owner%' && voiceUi.reportsBtn) {
              voiceUi.reportsBtn.style.display = 'inline-block';
          }
          // Pre-join participant preview - request participants immediately
          if (panel.style.display !== 'none' && !voiceJoined) {
              if (VOICE_DISCOVERY_ENABLED) {
                  try { 
                      ensureVoiceDiscoveryObserver();
                      // Request participants immediately when panel opens (even if socket not ready yet)
                      setTimeout(() => {
                          if (voiceDiscoveryWs && voiceDiscoveryWs.readyState === 1) {
                              sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                          }
                      }, 100);
                      setTimeout(() => {
                          if (voiceDiscoveryWs && voiceDiscoveryWs.readyState === 1) {
                              sendVoiceDiscovery({ type: 'getParticipants', ts: Date.now() });
                          }
                      }, 500);
                  } catch (_) {}
              } else {
                  // Only use Supabase if Cloudflare is not available (saves quota)
                  if (!VOICE_DISCOVERY_ENABLED) {
                      // Wait for Supabase to load properly
                      ensureSupabaseScript().then((supabaseClient) => {
                          // Double-check: ensure it's actually a client instance, not a library or boolean
                          if (supabaseClient && 
                              typeof supabaseClient === 'object' && 
                              typeof supabaseClient.channel === 'function' &&
                              supabaseClient !== true) {
                              try { 
                                  ensureVoiceObserverChannel(supabaseClient); 
                              } catch (err) {
                                  console.warn('Failed to ensure voice observer channel:', err);
                              }
                          } else {
                              console.warn('Supabase client not available or invalid for voice observer. Client:', supabaseClient);
                          }
                      }).catch((err) => {
                          console.warn('Failed to load Supabase for voice observer:', err);
                      });
                  }
              }
          }
      };

      voiceUi.toggleBtn?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Chat-only page: do not open voice popup, just open science page
          const isChatOnlyPage = window.location.pathname.includes('chat-only.html');
          if (isChatOnlyPage) {
              const gate = getVoiceGateState();
              if (gate !== 'adult_accepted') {
                  openVoiceGateModal({ 
                      afterAccept: () => {
                          // Open science page in about:blank wrapper
                          const scienceUrl = window.location.pathname.includes('/pages/') 
                              ? 'science.html' 
                              : 'pages/science.html';
                          if (typeof openGameInBlank === 'function') {
                              openGameInBlank(scienceUrl);
                          } else {
                              window.open(scienceUrl, '_blank');
                          }
                      }
                  });
                  return;
              }
              // Just open science page, no popup
              const scienceUrl = window.location.pathname.includes('/pages/') 
                  ? 'science.html' 
                  : 'pages/science.html';
              if (typeof openGameInBlank === 'function') {
                  openGameInBlank(scienceUrl);
              } else {
                  window.open(scienceUrl, '_blank');
              }
              return;
          }
          
          // Regular pages: show voice panel popup
          const gate = getVoiceGateState();
          if (gate !== 'adult_accepted') {
              openVoiceGateModal({ 
                  afterAccept: () => {
                      // Open science page in about:blank wrapper
                      const scienceUrl = window.location.pathname.includes('/pages/') 
                          ? 'science.html' 
                          : 'pages/science.html';
                      if (typeof openGameInBlank === 'function') {
                          openGameInBlank(scienceUrl);
                      } else {
                          window.open(scienceUrl, '_blank');
                      }
                  }
              });
              return;
          }
          togglePanel();
          // Open science page in about:blank wrapper
          const scienceUrl = window.location.pathname.includes('/pages/') 
              ? 'science.html' 
              : 'pages/science.html';
          if (typeof openGameInBlank === 'function') {
              openGameInBlank(scienceUrl);
          } else {
              window.open(scienceUrl, '_blank');
          }
          // Open the voice chat panel in full-page mode
          if (voiceUi.panel) {
              // Move panel to body if not already there
              if (voiceUi.panel.parentElement !== document.body) {
                  document.body.appendChild(voiceUi.panel);
              }
              
              // Apply full-page styles
              voiceUi.panel.style.setProperty('display', 'block', 'important');
              voiceUi.panel.style.setProperty('position', 'fixed', 'important');
              voiceUi.panel.style.setProperty('top', '0', 'important');
              voiceUi.panel.style.setProperty('left', '0', 'important');
              voiceUi.panel.style.setProperty('right', '0', 'important');
              voiceUi.panel.style.setProperty('bottom', '0', 'important');
              voiceUi.panel.style.setProperty('width', '100vw', 'important');
              voiceUi.panel.style.setProperty('height', '100vh', 'important');
              voiceUi.panel.style.setProperty('max-width', '100vw', 'important');
              voiceUi.panel.style.setProperty('max-height', '100vh', 'important');
              voiceUi.panel.style.setProperty('padding', '24px', 'important');
              voiceUi.panel.style.setProperty('border-radius', '0', 'important');
              voiceUi.panel.style.setProperty('z-index', '99999', 'important');
              voiceUi.panel.style.setProperty('overflow-y', 'auto', 'important');
              voiceUi.panel.style.setProperty('background', 'linear-gradient(135deg, rgba(15,23,42,0.98), rgba(30,41,59,0.95))', 'important');
              voiceUi.panel.style.setProperty('border', 'none', 'important');
              voiceUi.panel.style.setProperty('box-shadow', 'none', 'important');
              voiceUi.panel.style.setProperty('margin', '0', 'important');
          }
      });
      voiceUi.joinBtn?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          joinVoiceChat();
      });
      voiceUi.leaveBtn?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          leaveVoiceChat();
      });
      voiceUi.muteBtn?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleVoiceMute();
      });
      voiceUi.reportsBtn?.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          openVoiceReportsInbox();
      });
  }

  function renderVoiceParticipants() {
      if (!voiceUi.listEl) return;
      const items = Array.from(voiceParticipants.entries())
          .sort((a, b) => String(a[1]?.userId || '').localeCompare(String(b[1]?.userId || '')));
      
      // Show loading animation if loading and no participants yet (excluding self)
      const otherParticipants = items.filter(([pid]) => pid !== voicePeerId);
      if (voiceParticipantsLoading && voiceJoined && otherParticipants.length === 0) {
          voiceUi.listEl.innerHTML = `
              <div style="padding:20px; text-align:center; color:rgba(226,232,240,0.8);">
                  <div style="display:inline-block; margin-bottom:12px;">
                      <div style="width:40px; height:40px; border:3px solid rgba(16,185,129,0.3); border-top-color:rgba(16,185,129,0.9); border-radius:50%; animation:spin 0.8s linear infinite;"></div>
                  </div>
                  <div style="font-size:13px; font-weight:800; color:rgba(226,232,240,0.9);">Loading users...</div>
              </div>
              <style>
                  @keyframes spin {
                      to { transform: rotate(360deg); }
                  }
              </style>
          `;
          return;
      }
      
      voiceUi.listEl.innerHTML = '';
      items.forEach(([peerId, info]) => {
          const chip = document.createElement('div');
          chip.dataset.peerId = peerId;
          chip.style.display = 'flex';
          chip.style.flexDirection = 'column';
          chip.style.gap = '12px';
          chip.style.padding = '20px';
          chip.style.borderRadius = '16px';
          chip.style.minHeight = '160px';
          chip.style.position = 'relative';
          chip.style.overflow = 'hidden';
          const speaking = !!info?.speaking;
          const connected = !!info?.connected;
          const muted = !!info?.muted;
          const isMe = peerId === voicePeerId;
          chip.style.background = speaking
              ? 'linear-gradient(135deg, rgba(134,239,172,0.4), rgba(74,222,128,0.3))'
              : isMe
              ? 'linear-gradient(135deg, rgba(99,102,241,0.2), rgba(139,92,246,0.15))'
              : 'linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04))';
          chip.style.border = speaking 
              ? '2px solid rgba(134,239,172,0.8)' 
              : isMe
              ? '2px solid rgba(99,102,241,0.5)'
              : '2px solid rgba(255,255,255,0.12)';
          chip.style.boxShadow = speaking 
              ? '0 8px 24px rgba(134,239,172,0.3), 0 0 0 1px rgba(134,239,172,0.2) inset' 
              : '0 4px 12px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.05) inset';
          chip.style.transition = 'all 0.3s ease';
          chip.style.width = '100%';
          chip.style.boxSizing = 'border-box';

          // Avatar/Icon section
          const avatarSection = document.createElement('div');
          avatarSection.style.display = 'flex';
          avatarSection.style.flexDirection = 'column';
          avatarSection.style.alignItems = 'center';
          avatarSection.style.gap = '8px';
          avatarSection.style.marginBottom = '4px';
          avatarSection.style.width = '100%';
          
          const avatar = document.createElement('div');
          avatar.style.width = '60px';
          avatar.style.height = '60px';
          avatar.style.borderRadius = '50%';
          avatar.style.background = speaking
              ? 'linear-gradient(135deg, rgba(134,239,172,0.95), rgba(74,222,128,0.85))'
              : isMe
              ? 'linear-gradient(135deg, rgba(99,102,241,0.9), rgba(139,92,246,0.7))'
              : 'linear-gradient(135deg, rgba(148,163,184,0.6), rgba(100,116,139,0.4))';
          avatar.style.display = 'flex';
          avatar.style.alignItems = 'center';
          avatar.style.justifyContent = 'center';
          avatar.style.fontSize = '24px';
          avatar.style.fontWeight = '900';
          avatar.style.color = '#ffffff';
          avatar.style.border = speaking ? '3px solid rgba(134,239,172,0.9)' : '3px solid rgba(255,255,255,0.2)';
          avatar.style.boxShadow = speaking 
              ? '0 0 20px rgba(134,239,172,0.5)' 
              : '0 4px 12px rgba(0,0,0,0.2)';
          const initials = (getDisplayName(info?.userId || peerId.slice(0, 8)) || 'U').substring(0, 2).toUpperCase();
          avatar.textContent = initials;
          
          const statusDot = document.createElement('div');
          statusDot.dataset.peerDot = '1';
          statusDot.style.width = '14px';
          statusDot.style.height = '14px';
          statusDot.style.borderRadius = '50%';
          statusDot.style.background = connected ? 'rgba(34,197,94,1)' : 'rgba(239,68,68,1)';
          statusDot.style.border = '2px solid rgba(15,23,42,0.9)';
          statusDot.style.boxShadow = connected ? '0 0 8px rgba(34,197,94,0.6)' : '0 0 8px rgba(239,68,68,0.4)';
          statusDot.style.position = 'absolute';
          statusDot.style.top = '12px';
          statusDot.style.right = '12px';
          statusDot.style.zIndex = '10';
          
          avatarSection.appendChild(avatar);

          const topRow = document.createElement('div');
          topRow.style.display = 'flex';
          topRow.style.flexDirection = 'column';
          topRow.style.alignItems = 'center';
          topRow.style.gap = '6px';
          topRow.style.width = '100%';
          topRow.style.flexShrink = '0';

          const name = document.createElement('div');
          name.textContent = getDisplayName(info?.userId || peerId.slice(0, 8));
          name.style.fontSize = '14px';
          name.style.fontWeight = '900';
          name.style.color = speaking ? '#86efac' : isMe ? '#c4b5fd' : 'rgba(226,232,240,0.95)';
          name.style.textAlign = 'center';
          name.style.letterSpacing = '0.5px';
          
          const statusText = document.createElement('div');
          statusText.style.fontSize = '11px';
          statusText.style.fontWeight = '700';
          statusText.style.color = muted 
              ? 'rgba(239,68,68,0.9)' 
              : speaking 
              ? 'rgba(134,239,172,0.95)' 
              : 'rgba(148,163,184,0.8)';
          statusText.textContent = muted ? 'Muted' : speaking ? 'Speaking' : isMe ? 'You' : 'Connected';
          statusText.style.textAlign = 'center';

          topRow.appendChild(name);
          topRow.appendChild(statusText);

          const right = document.createElement('div');
          right.style.display = 'flex';
          right.style.alignItems = 'center';
          right.style.justifyContent = 'center';
          right.style.gap = '6px';
          right.style.marginTop = '6px';
          right.style.flexWrap = 'wrap';
          right.style.width = '100%';
          right.style.flexShrink = '0';

          // Local-only mute toggle (doesn't affect others)
          if (voicePeerId && peerId !== voicePeerId) {
              const localMuted = isPeerLocallyMuted(peerId);
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.textContent = localMuted ? 'Unmute' : 'Mute';
              btn.style.padding = '8px 14px';
              btn.style.borderRadius = '10px';
              btn.style.border = '1px solid rgba(255,255,255,0.15)';
              btn.style.background = localMuted ? 'rgba(239,68,68,0.25)' : 'rgba(255,255,255,0.1)';
              btn.style.color = localMuted ? '#fecaca' : 'rgba(226,232,240,0.95)';
              btn.style.fontWeight = '800';
              btn.style.cursor = 'pointer';
              btn.style.fontSize = '12px';
              btn.style.transition = 'all 0.2s ease';
              btn.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  toggleLocalMutePeer(peerId);
              });
              right.appendChild(btn);
          }

          // Report (everyone, except self)
          if (voicePeerId && peerId !== voicePeerId) {
              const reportBtn = document.createElement('button');
              reportBtn.type = 'button';
              reportBtn.textContent = 'Report';
              reportBtn.style.padding = '8px 14px';
              reportBtn.style.borderRadius = '10px';
              reportBtn.style.border = '1px solid rgba(255,255,255,0.15)';
              reportBtn.style.background = 'rgba(59,130,246,0.2)';
              reportBtn.style.color = '#bfdbfe';
              reportBtn.style.fontWeight = '800';
              reportBtn.style.cursor = 'pointer';
              reportBtn.style.fontSize = '12px';
              reportBtn.style.transition = 'all 0.2s ease';
              reportBtn.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  openVoiceReportModal(String(info?.userId || ''));
              });
              right.appendChild(reportBtn);
          }

          // Audio level meter
          const meterOuter = document.createElement('div');
          meterOuter.dataset.peerMeter = '1';
          meterOuter.style.width = '100%';
          meterOuter.style.height = '8px';
          meterOuter.style.borderRadius = '999px';
          meterOuter.style.background = 'rgba(15,23,42,0.6)';
          meterOuter.style.border = '1px solid rgba(255,255,255,0.1)';
          meterOuter.style.overflow = 'hidden';
          meterOuter.style.marginTop = '8px';
          meterOuter.style.flexShrink = '0';

          const meterFill = document.createElement('div');
          meterFill.dataset.peerMeterFill = '1';
          meterFill.style.height = '100%';
          meterFill.style.width = '0%';
          meterFill.style.borderRadius = '999px';
          meterFill.style.background = muted
              ? 'linear-gradient(90deg, rgba(239,68,68,0.95), rgba(220,38,38,0.9))'
              : (speaking 
                  ? 'linear-gradient(90deg, rgba(134,239,172,0.95), rgba(74,222,128,0.9))' 
                  : 'linear-gradient(90deg, rgba(99,102,241,0.9), rgba(139,92,246,0.8))');
          meterFill.style.transition = 'width 80ms linear';
          meterFill.style.boxShadow = speaking ? '0 0 8px rgba(134,239,172,0.6)' : 'none';
          meterOuter.appendChild(meterFill);

          // Build structure properly
          chip.appendChild(statusDot); // Status dot first (absolute positioned)
          chip.appendChild(avatarSection);
          chip.appendChild(topRow);
          chip.appendChild(right);
          chip.appendChild(meterOuter);
          
          // Ensure chip is properly sized for grid
          chip.style.minWidth = '0';
          chip.style.maxWidth = '100%';

          const lvl = Math.max(0, Math.min(1, Number(info?.level) || 0));
          meterFill.style.width = `${Math.round(lvl * 100)}%`;

          voiceUi.listEl.appendChild(chip);
      });
  }

  function cleanupVoiceCall(remotePeerId) {
      const call = voiceCalls.get(remotePeerId);
      if (call) {
          try { call.close(); } catch (_) {}
      }
      voiceCalls.delete(remotePeerId);
      cleanupVoiceDataConn(remotePeerId);
      if (voiceUi.audioBucket) {
          const el = voiceUi.audioBucket.querySelector(`audio[data-peer-id="${remotePeerId}"]`);
          if (el) el.remove();
      }
      // Clean up gain node
      const gainNode = voiceAudioGainNodes.get(remotePeerId);
      if (gainNode) {
          try {
              gainNode.disconnect();
          } catch (_) {}
          voiceAudioGainNodes.delete(remotePeerId);
      }
      // Video elements removed - audio-only voice chat
      stopRemoteSpeakingMeter(remotePeerId);
      const info = voiceParticipants.get(remotePeerId);
      if (info) voiceParticipants.set(remotePeerId, { ...info, connected: false, speaking: false });
      renderVoiceParticipants();
  }

  // checkCallForVideo removed - audio-only voice chat

  function attachRemoteAudio(remotePeerId, stream) {
      
      if (!voiceUi.audioBucket) {
          // Ensure audio bucket exists
          voiceUi.audioBucket = document.createElement('div');
          voiceUi.audioBucket.style.display = 'none';
          voiceUi.audioBucket.style.position = 'absolute';
          voiceUi.audioBucket.style.left = '-9999px';
          voiceUi.audioBucket.style.width = '1px';
          voiceUi.audioBucket.style.height = '1px';
          voiceUi.audioBucket.style.overflow = 'hidden';
          document.body.appendChild(voiceUi.audioBucket);
      }
      if (!stream) {
          console.warn('No stream provided for', remotePeerId);
          return;
      }
      
      // Check if stream has audio tracks
      const audioTracks = stream.getAudioTracks();
      if (audioTracks.length === 0) {
          console.warn('No audio tracks in stream for', remotePeerId);
          return;
      }
      
      // Use Web Audio API for volume amplification (can go above 1.0)
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!voiceMasterAudioCtx && AudioCtx) {
          try {
              voiceMasterAudioCtx = new AudioCtx();
              // CRITICAL: Resume AudioContext if suspended (browser autoplay policy)
              if (voiceMasterAudioCtx.state === 'suspended') {
                  voiceMasterAudioCtx.resume().then(() => {
                  }).catch(err => {
                      console.warn('Failed to resume AudioContext:', err);
                  });
              }
              // Store globally for easy access
              window.audioCtx = voiceMasterAudioCtx;
          } catch (err) {
              console.error('Failed to create AudioContext:', err);
          }
      } else if (voiceMasterAudioCtx && voiceMasterAudioCtx.state === 'suspended') {
          // Resume if already created but suspended
          voiceMasterAudioCtx.resume().then(() => {
          }).catch(err => {
              console.warn('Failed to resume existing AudioContext:', err);
          });
      }
      
      // Use simple <audio> element approach (more reliable than Web Audio API for basic playback)
      // Web Audio API gain nodes can cause issues with routing
      let audio = voiceUi.audioBucket.querySelector(`audio[data-peer-id="${remotePeerId}"]`);
      
      if (!audio) {
          audio = document.createElement('audio');
          audio.autoplay = true;
          audio.playsInline = true;
          audio.dataset.peerId = remotePeerId;
          audio.setAttribute('playsinline', 'true');
          audio.setAttribute('autoplay', 'true');
          audio.muted = false;
          // Set volume directly (we'll use gain node separately if needed for amplification)
          audio.volume = 1.0;
          voiceUi.audioBucket.appendChild(audio);
          
          // Use direct stream (simpler and more reliable)
          audio.srcObject = stream;
      }
      
      try {
          // Always update srcObject with the original stream
          // This ensures we get all tracks, even if they're not 'live' yet
          if (audio.srcObject !== stream) {
              audio.srcObject = stream;
          }
          
          // Update volume (limited to 1.0 for <audio> element)
          // Use global voiceVolume if available, otherwise use module-level voiceVolume
          const currentVolume = typeof window !== 'undefined' && typeof window.voiceVolume !== 'undefined' 
            ? window.voiceVolume 
            : voiceVolume;
          const isMuted = typeof isPeerLocallyMuted === 'function' ? isPeerLocallyMuted(remotePeerId) : false;
          audio.volume = isMuted ? 0 : Math.min(1.0, currentVolume);
          
          // CRITICAL: Ensure muted is false
          audio.muted = false;
          
          // Force play with retry logic
          const playAudio = async () => {
              if (!audio) return;
              // CRITICAL: Ensure audio is not muted and volume is set
              audio.muted = false;
              const isMuted = typeof isPeerLocallyMuted === 'function' ? isPeerLocallyMuted(remotePeerId) : false;
              audio.volume = isMuted ? 0 : Math.min(1.0, voiceVolume);
              
              // CRITICAL: Resume AudioContext if suspended (browser autoplay policy)
              if (voiceMasterAudioCtx && voiceMasterAudioCtx.state === 'suspended') {
                  try {
                      await voiceMasterAudioCtx.resume();
                  } catch (err) {
                      console.warn('Failed to resume AudioContext:', err);
                  }
              }
              
              try {
                  const playPromise = audio.play();
                  if (playPromise !== undefined) {
                      await playPromise;
                      
                      // Verify it's actually playing
                      if (audio.paused) {
                          console.warn('⚠️ Audio element is paused after play() call for', remotePeerId);
                          setTimeout(() => {
                              if (audio && audio.paused) {
                                  console.warn('⚠️ Retrying play() for paused audio element', remotePeerId);
                                  audio.play().catch(e => console.error('Retry play failed:', e));
                              }
                          }, 100);
                      }
                  }
              } catch (err) {
                  console.error('❌ Audio play failed for', remotePeerId, err);
                  // Retry after a short delay
                  setTimeout(() => {
                      if (audio) {
                          try {
                              audio.play().catch(e => console.warn('Retry play failed:', e));
                          } catch (_) {}
                      }
                  }, 500);
              }
          };
          
          // Try to play immediately
          playAudio();
          
          // Also try after short delays in case the stream needs time to initialize
          setTimeout(playAudio, 100);
          setTimeout(playAudio, 500);
          setTimeout(playAudio, 1000);
          
          // Verify audio is actually playing and log detailed state
          setTimeout(() => {
              if (audio) {
                  const tracks = audio.srcObject?.getAudioTracks() || [];
                  const enabledTracks = tracks.filter(t => t.enabled);
                  const gainNode = voiceAudioGainNodes.get(remotePeerId);
                  
                  if (audio.paused) {
                      console.warn('Audio still paused for', remotePeerId, '- retrying play');
                      playAudio();
                  }
                  
                  // Double-check gain node is set correctly
                  if (gainNode) {
                      const expectedGain = isPeerLocallyMuted(remotePeerId) ? 0 : voiceVolume;
                      // Check with tolerance for floating point precision (Web Audio API uses float32)
                      const tolerance = 0.0001;
                      if (Math.abs(gainNode.gain.value - expectedGain) > tolerance) {
                          gainNode.gain.value = expectedGain;
                      }
                  }
              }
          }, 1500);
          
          // Additional verification after longer delay
          setTimeout(() => {
              if (audio && audio.paused) {
                  console.warn('Audio still paused after 3 seconds for', remotePeerId, '- forcing play');
                  playAudio();
              }
          }, 3000);
          
      } catch (err) {
          console.error('Error attaching remote audio for', remotePeerId, err);
      }
      const info = voiceParticipants.get(remotePeerId);
      if (info) voiceParticipants.set(remotePeerId, { ...info, connected: true });
      startRemoteSpeakingMeter(remotePeerId, stream);
      renderVoiceParticipants();
  }

  function maybeCallPeer(remotePeerId) {
      if (!voiceJoined || !voicePeer || !voicePeerId || !voiceLocalStream) {
          return;
      }
      if (!remotePeerId || remotePeerId === voicePeerId) {
          return;
      }
      if (voiceCalls.has(remotePeerId)) {
          return;
      }
      // Respect owner moderation (don't connect to banned/timed-out users)
      try {
          const info = voiceParticipants.get(remotePeerId);
          const uid = String(info?.userId || '');
          const block = getVoiceBlockReason(uid);
          if (block.blocked) {
              return;
          }
      } catch (_) {}
      // Avoid double-calling: only initiate when our peerId sorts lower
      // But if the other peer hasn't called us after 1 second, we should try anyway (for late joiners)
      const shouldWait = String(voicePeerId) > String(remotePeerId);
      if (shouldWait) {
          // Wait a bit, then call anyway if no call was received (helps with late joiners)
          // Reduced timeout to 1 second for faster bidirectional connection
          setTimeout(() => {
              if (voiceJoined && !voiceCalls.has(remotePeerId)) {
                  try {
                      let streamToSend = voiceLocalStream;
                      const call = voicePeer.call(remotePeerId, streamToSend, { metadata: { room: VOICE_ROOM_ID } });
                      voiceCalls.set(remotePeerId, call);
                      // Set up the same handlers as the normal call path
                      call.on('stream', (remoteStream) => {
                          call.remoteStream = remoteStream;
                          attachRemoteAudio(remotePeerId, remoteStream);
                          if (remoteStream.getAudioTracks().length > 0) {
                              remoteStream.getAudioTracks().forEach(track => {
                                  track.onunmute = () => {
                                      attachRemoteAudio(remotePeerId, remoteStream);
                                  };
                              });
                          }
                      });
                      if (call.peerConnection) {
                          call.peerConnection.ontrack = (event) => {
                              const track = event.track;
                              if (track && track.kind === 'audio') {
                                  let streamToUse = null;
                                  if (event.streams && event.streams.length > 0) {
                                      streamToUse = event.streams[0];
                                      call.remoteStream = streamToUse;
                                  } else if (call.remoteStream) {
                                      if (!call.remoteStream.getAudioTracks().some(t => t.id === track.id)) {
                                          call.remoteStream.addTrack(track);
                                      }
                                      streamToUse = call.remoteStream;
                                  }
                                  if (streamToUse) {
                                      attachRemoteAudio(remotePeerId, streamToUse);
                                  }
                              }
                          };
                      }
                  } catch (err) {
                      console.error('maybeCallPeer: fallback call failed', err);
                  }
              }
          }, 1000); // Reduced to 1 second for faster bidirectional connection
          return;
      }
      try {
          let streamToSend = voiceLocalStream;
          const call = voicePeer.call(remotePeerId, streamToSend, { metadata: { room: VOICE_ROOM_ID } });
          if (!call) {
              console.error('maybeCallPeer: voicePeer.call returned null/undefined');
              return;
          }
          voiceCalls.set(remotePeerId, call);
          call.on('stream', (remoteStream) => {
              // Store the remote stream on the call object
              call.remoteStream = remoteStream;
              // Immediately attach audio
              attachRemoteAudio(remotePeerId, remoteStream);
              // Monitor audio tracks for state changes
              if (remoteStream.getAudioTracks().length > 0) {
                  remoteStream.getAudioTracks().forEach(track => {
                      track.onended = () => {
                      };
                      track.onmute = () => {
                      };
                      track.onunmute = () => {
                          attachRemoteAudio(remotePeerId, remoteStream);
                      };
                  });
              }
          });
          // Listen for track events to detect when audio/video tracks are added
          if (call.peerConnection) {
              call.peerConnection.ontrack = (event) => {
                  const track = event.track;
                  if (!track) return;
                  
                  
                  if (track.kind === 'audio') {
                      // Audio track added - use stream from event if available
                      let streamToUse = null;
                      if (event.streams && event.streams.length > 0) {
                          // Use the stream from the event (this is the actual PeerJS stream)
                          streamToUse = event.streams[0];
                          call.remoteStream = streamToUse;
                      } else {
                          // Track without stream - add to existing or create new
                          if (!call.remoteStream) {
                              call.remoteStream = new MediaStream();
                          }
                          // Check if track already exists
                          if (call.remoteStream && call.remoteStream.getAudioTracks) {
                              if (!call.remoteStream.getAudioTracks().some(t => t.id === track.id)) {
                                  call.remoteStream.addTrack(track);
                              }
                          }
                          streamToUse = call.remoteStream;
                      }
                      
                      // Attach audio with the stream
                      if (streamToUse) {
                          attachRemoteAudio(remotePeerId, streamToUse);
                      }
                      
                      // Monitor track state changes
                      track.onended = () => {
                      };
                      track.onmute = () => {
                      };
                      track.onunmute = () => {
                          // Use the stream from call.remoteStream
                          if (call.remoteStream) {
                              attachRemoteAudio(remotePeerId, call.remoteStream);
                          }
                      };
                  }
                  // Video tracks are ignored - audio-only voice chat
              };
          }
          call.on('close', () => cleanupVoiceCall(remotePeerId));
          call.on('error', () => cleanupVoiceCall(remotePeerId));
      } catch (err) {
          console.warn('Call failed', err);
      }
  }

  function setParticipantConnected(peerId, isConnected) {
      if (!peerId) return;
      const info = voiceParticipants.get(peerId);
      if (!info) return;
      const next = !!isConnected;
      if (!!info.connected === next) return;
      info.connected = next;
      voiceParticipants.set(peerId, info);
      if (voiceUi.listEl) {
          const chip = voiceUi.listEl.querySelector(`[data-peer-id="${peerId}"]`);
          const dot = chip ? chip.querySelector('span[data-peer-dot="1"]') : null;
          if (dot) {
              dot.style.background = next ? 'rgba(34,197,94,0.95)' : 'rgba(148,163,184,0.75)';
              dot.style.boxShadow = next ? '0 0 0 3px rgba(34,197,94,0.14)' : 'none';
          } else {
              renderVoiceParticipants();
          }
      }
  }

  function setParticipantSpeaking(peerId, isSpeaking) {
      if (!peerId) return;
      const info = voiceParticipants.get(peerId);
      if (!info) return;
      const next = !!isSpeaking;
      if (!!info.speaking === next) return;
      info.speaking = next;
      voiceParticipants.set(peerId, info);
      // Re-render to ensure consistent styling, especially for local user
      renderVoiceParticipants();
      if (voiceUi.listEl) {
          const chip = voiceUi.listEl.querySelector(`[data-peer-id="${peerId}"]`);
          if (chip) {
              const connected = !!info.connected;
              const isMe = peerId === voicePeerId;
              const muted = !!info.muted;
              // Update styles to match renderVoiceParticipants logic
              chip.style.background = next
                  ? 'linear-gradient(135deg, rgba(134,239,172,0.4), rgba(74,222,128,0.3))'
                  : isMe
                  ? 'linear-gradient(135deg, rgba(99,102,241,0.2), rgba(139,92,246,0.15))'
                  : 'linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04))';
              chip.style.border = next 
                  ? '2px solid rgba(134,239,172,0.8)' 
                  : isMe
                  ? '2px solid rgba(99,102,241,0.5)'
                  : '2px solid rgba(255,255,255,0.12)';
              chip.style.boxShadow = next 
                  ? '0 8px 24px rgba(134,239,172,0.3), 0 0 0 1px rgba(134,239,172,0.2) inset' 
                  : '0 4px 12px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.05) inset';
              const dot = chip.querySelector('span[data-peer-dot="1"]');
              // Find status text - it's the second div in the topRow (after name)
              const topRow = chip.querySelector('div[style*="flexDirection"][style*="column"]');
              let statusText = null;
              if (topRow && topRow.children.length >= 2) {
                  statusText = topRow.children[1]; // Second child is status text
              }
              if (statusText) {
                  // Update status text to show "Speaking" when speaking
                  statusText.textContent = muted ? 'Muted' : next ? 'Speaking' : isMe ? 'You' : 'Connected';
                  statusText.style.color = muted 
                      ? 'rgba(239,68,68,0.9)' 
                      : next 
                      ? 'rgba(134,239,172,0.95)' 
                      : 'rgba(148,163,184,0.8)';
              }
              // Update avatar border for speaking state
              const avatar = chip.querySelector('div[style*="borderRadius"][style*="50%"]');
              if (avatar) {
                  avatar.style.border = next ? '3px solid rgba(134,239,172,0.9)' : '3px solid rgba(255,255,255,0.2)';
                  avatar.style.background = next
                      ? 'linear-gradient(135deg, rgba(134,239,172,0.95), rgba(74,222,128,0.85))'
                      : isMe
                      ? 'linear-gradient(135deg, rgba(99,102,241,0.9), rgba(139,92,246,0.7))'
                      : 'linear-gradient(135deg, rgba(148,163,184,0.6), rgba(100,116,139,0.4))';
                  avatar.style.boxShadow = next 
                      ? '0 0 20px rgba(134,239,172,0.5)' 
                      : '0 4px 12px rgba(0,0,0,0.2)';
              }
              if (dot) {
                  dot.style.background = next
                      ? 'rgba(34,197,94,0.95)'
                      : (connected ? 'rgba(34,197,94,0.95)' : 'rgba(148,163,184,0.75)');
                  dot.style.boxShadow = next
                      ? '0 0 0 4px rgba(34,197,94,0.18)'
                      : (connected ? '0 0 0 3px rgba(34,197,94,0.14)' : 'none');
              }
              const meterFill = chip.querySelector('div[data-peer-meter-fill="1"]');
              if (meterFill) {
                  const muted = !!info.muted;
                  meterFill.style.background = muted
                      ? 'rgba(239,68,68,0.95)'
                      : (next ? 'rgba(34,197,94,0.95)' : 'rgba(99,102,241,0.9)');
              }
          } else {
              renderVoiceParticipants();
          }
      }
  }

  function setParticipantLevel(peerId, level01, ts = Date.now()) {
      if (!peerId) return;
      const info = voiceParticipants.get(peerId);
      if (!info) return;
      const lvl = Math.max(0, Math.min(1, Number(level01) || 0));
      info.level = lvl;
      info.lastLevelTs = ts || Date.now();
      voiceParticipants.set(peerId, info);
      if (voiceUi.listEl) {
          const chip = voiceUi.listEl.querySelector(`[data-peer-id="${peerId}"]`);
          const fill = chip ? chip.querySelector('div[data-peer-meter-fill="1"]') : null;
          if (fill) {
              fill.style.width = `${Math.round(lvl * 100)}%`;
              const muted = !!info.muted;
              const speaking = !!info.speaking;
              fill.style.background = muted
                  ? 'rgba(239,68,68,0.95)'
                  : (speaking ? 'rgba(34,197,94,0.95)' : 'rgba(99,102,241,0.9)');
          } else {
              renderVoiceParticipants();
          }
      }
  }

  function broadcastLocalSpeaking(nextSpeaking) {
      try {
          if (!voiceJoined || !voicePeerId) return;
          const next = !!nextSpeaking;
          const now = Date.now();
          // Heartbeat while speaking so remotes stay synced
          if (voiceLocalSpeaking === next) {
              if (!next) return;
              if ((now - voiceLocalLastSpeakingSendTs) < 700) return;
          }
          if ((now - voiceLocalLastSpeakingSendTs) < 120) return;
          voiceLocalLastSpeakingSendTs = now;
          voiceLocalSpeaking = next;
          broadcastVoiceData({ type: 'speaking', peerId: voicePeerId, speaking: next, ts: now });
      } catch (_) {}
  }

  function broadcastLocalLevel(level01) {
      try {
          if (!voiceJoined || !voicePeerId) return;
          const now = Date.now();
          if ((now - voiceLocalLastLevelSendTs) < VOICE_LEVEL_SEND_INTERVAL_MS) return;
          voiceLocalLastLevelSendTs = now;
          const lvl = Math.max(0, Math.min(1, Number(level01) || 0));
          broadcastVoiceData({ type: 'level', peerId: voicePeerId, level: lvl, muted: !!voiceMuted, ts: now });
      } catch (_) {}
  }

  function stopVoiceMeter() {
      if (voiceMeterRaf) cancelAnimationFrame(voiceMeterRaf);
      voiceMeterRaf = null;
      voiceAnalyser = null;
      if (voiceAudioCtx) {
          try { voiceAudioCtx.close(); } catch (_) {}
      }
      voiceAudioCtx = null;
      if (voiceUi.meterCanvas) {
          const ctx = voiceUi.meterCanvas.getContext('2d');
          if (ctx) ctx.clearRect(0, 0, voiceUi.meterCanvas.width, voiceUi.meterCanvas.height);
      }
  }

  function startVoiceMeter(stream) {
      stopVoiceMeter();
      if (!voiceUi.meterCanvas) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;
      try {
          voiceAudioCtx = new AudioCtx();
          const src = voiceAudioCtx.createMediaStreamSource(stream);
          voiceAnalyser = voiceAudioCtx.createAnalyser();
          voiceAnalyser.fftSize = 1024;
          voiceAnalyser.smoothingTimeConstant = 0.85;
          src.connect(voiceAnalyser);
      } catch (err) {
          console.warn('Voice meter init failed', err);
          stopVoiceMeter();
          return;
      }
      const canvas = voiceUi.meterCanvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      const data = new Uint8Array(voiceAnalyser.frequencyBinCount);

      const draw = () => {
          if (!voiceAnalyser || !ctx) return;
          voiceAnalyser.getByteTimeDomainData(data);
          let sum = 0;
          for (let i = 0; i < data.length; i++) {
              const v = (data[i] - 128) / 128;
              sum += v * v;
          }
          const rms = Math.sqrt(sum / data.length);
          const level = Math.min(1, Math.max(0, rms * 2.2));

          // Update speaking + broadcast
          if (voicePeerId) {
              const now = Date.now();
              const info = voiceParticipants.get(voicePeerId) || { userId: globalChatUsername || 'User', lastSeen: now, lastSpokeTs: 0, speaking: false, connected: true, lastBroadcastTs: 0, level: 0, lastLevelTs: 0, muted: false };
              if (!voiceNoiseFloorInitTs) voiceNoiseFloorInitTs = now;
              const warmup = (now - voiceNoiseFloorInitTs) < 1200;
              const alpha = warmup ? 0.12 : 0.04;
              if (voiceMuted || !info.speaking) {
                  if (!voiceNoiseFloor) voiceNoiseFloor = rms;
                  else voiceNoiseFloor = (voiceNoiseFloor * (1 - alpha)) + (rms * alpha);
              }
              const gate = Math.max(VOICE_SPEAKING_RMS_THRESHOLD, (voiceNoiseFloor * 2.8 + 0.002));
              const crosses = (!voiceMuted) && (rms > gate) && (level > VOICE_SPEAKING_LEVEL_THRESHOLD);
              if (crosses) info.lastSpokeTs = now;
              const speaking = (!voiceMuted) && (now - (info.lastSpokeTs || 0)) < VOICE_SPEAKING_HOLD_MS;
              voiceParticipants.set(voicePeerId, { ...info, speaking });
              setParticipantSpeaking(voicePeerId, speaking);
              broadcastLocalSpeaking(speaking);
              const sendLevel = voiceMuted ? 0 : level;
              setParticipantLevel(voicePeerId, sendLevel, now);
              broadcastLocalLevel(sendLevel);
          }

          // Draw meter - starts green, turns red as volume increases
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const w = Math.floor(canvas.width * level);
          const h = canvas.height;
          
          if (voiceMuted) {
              ctx.fillStyle = 'rgba(148,163,184,0.55)';
              ctx.fillRect(0, 0, w, h);
          } else {
              // Interpolate from green (low) to red (high) based on level
              // Green: rgb(34, 197, 94) -> Red: rgb(239, 68, 68)
              const greenR = 34, greenG = 197, greenB = 94;
              const redR = 239, redG = 68, redB = 68;
              const r = Math.round(greenR + (redR - greenR) * level);
              const g = Math.round(greenG + (redG - greenG) * level);
              const b = Math.round(greenB + (redB - greenB) * level);
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.95)`;
              ctx.fillRect(0, 0, w, h);
          }

          voiceMeterRaf = requestAnimationFrame(draw);
      };
      voiceMeterRaf = requestAnimationFrame(draw);
  }

  function stopRemoteSpeakingMeter(peerId) {
      if (peerId) {
          voiceRemoteAnalysers.delete(peerId);
          setParticipantSpeaking(peerId, false);
      }
      if (voiceRemoteAnalysers.size === 0) {
          if (voiceRemoteMeterRaf) cancelAnimationFrame(voiceRemoteMeterRaf);
          voiceRemoteMeterRaf = null;
          if (voiceRemoteAudioCtx) {
              try { voiceRemoteAudioCtx.close(); } catch (_) {}
          }
          voiceRemoteAudioCtx = null;
      }
  }

  function startRemoteSpeakingMeter(peerId, stream) {
      if (!peerId || !stream) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;
      if (!voiceRemoteAudioCtx) {
          try { voiceRemoteAudioCtx = new AudioCtx(); } catch (_) { voiceRemoteAudioCtx = null; }
      }
      if (!voiceRemoteAudioCtx) return;
      try {
          const analyser = voiceRemoteAudioCtx.createAnalyser();
          analyser.fftSize = 1024;
          analyser.smoothingTimeConstant = 0.85;
          const src = voiceRemoteAudioCtx.createMediaStreamSource(stream);
          src.connect(analyser);
          const data = new Uint8Array(analyser.frequencyBinCount);
          voiceRemoteAnalysers.set(peerId, { analyser, data });
      } catch (err) {
          console.warn('Remote voice meter init failed', err);
          return;
      }
      if (!voiceRemoteMeterRaf) {
          const tick = () => {
              voiceRemoteAnalysers.forEach((entry, pid) => {
                  try {
                      const now = Date.now();
                      const existing = voiceParticipants.get(pid);
                      // If we recently got broadcast speaking, don't fight it
                      if (existing?.lastBroadcastTs && (now - existing.lastBroadcastTs) < 1500) return;
                      entry.analyser.getByteTimeDomainData(entry.data);
                      let sum = 0;
                      for (let i = 0; i < entry.data.length; i++) {
                          const v = (entry.data[i] - 128) / 128;
                          sum += v * v;
                      }
                      const rms = Math.sqrt(sum / entry.data.length);
                      const threshold = 0.020;
                      const info = voiceParticipants.get(pid) || { userId: '', lastSeen: now, lastSpokeTs: 0, speaking: false, connected: false, lastBroadcastTs: 0, level: 0, lastLevelTs: 0, muted: false };
                      if (rms > threshold) info.lastSpokeTs = now;
                      const speaking = (now - (info.lastSpokeTs || 0)) < 350;
                      voiceParticipants.set(pid, { ...info, speaking });
                      setParticipantSpeaking(pid, speaking);
                  } catch (_) {}
              });
              voiceRemoteMeterRaf = requestAnimationFrame(tick);
          };
          voiceRemoteMeterRaf = requestAnimationFrame(tick);
      }
  }

  // Firebase Realtime Database functions for voice chat
  function getFirebaseDb() {
      // Try window.firebaseDb first (set by initialization script)
      if (typeof window !== 'undefined' && window.firebaseDb) {
          // Verify it has the ref() method (real Firebase database)
          if (typeof window.firebaseDb.ref === 'function') {
              return window.firebaseDb;
          }
      }
      // Try window.db (set by firebase-shim.js or initialization)
      if (typeof window !== 'undefined' && window.db) {
          // Verify it has the ref() method (real Firebase database, not BackendAPI shim)
          if (typeof window.db.ref === 'function') {
              return window.db;
          }
      }
      // Try firebase.database() (compat version) - initialize if needed
      if (typeof firebase !== 'undefined' && firebase.database) {
          try {
              const db = firebase.database();
              if (db) return db;
          } catch (err) {
              console.warn('firebase.database() failed:', err);
          }
      }
      // Try firebaseApp if available
      if (typeof window !== 'undefined' && window.firebaseApp) {
          try {
              return window.firebaseApp.database();
          } catch (err) {
              console.warn('window.firebaseApp.database() failed:', err);
          }
      }
      // Only log warning if we've waited a bit (avoid spam on initial load)
      if (typeof window !== 'undefined' && (!window.__firebaseDbWarningShown || Date.now() - window.__firebaseDbWarningShown > 5000)) {
          console.warn('Firebase Database not available - checking initialization...', {
              hasWindow: typeof window !== 'undefined',
              hasFirebaseDb: typeof window !== 'undefined' && !!window.firebaseDb,
              hasDb: typeof window !== 'undefined' && !!window.db,
              hasFirebase: typeof firebase !== 'undefined',
              hasFirebaseApp: typeof window !== 'undefined' && !!window.firebaseApp,
              hasBackendAPI: typeof BackendAPI !== 'undefined'
          });
          window.__firebaseDbWarningShown = Date.now();
      }
      return null;
  }

  function ensureVoiceFirebasePresence() {
      // Wait for Firebase to be available
      let firebaseReadyListener = null;
      const tryEnsure = (attempts = 0) => {
          const db = getFirebaseDb();
          if (!db) {
              if (attempts === 0 && typeof window !== 'undefined') {
                  // Listen for firebaseReady event on first attempt
                  firebaseReadyListener = () => {
                      if (typeof window !== 'undefined') {
                          window.removeEventListener('firebaseReady', firebaseReadyListener);
                      }
                      // Retry immediately when Firebase is ready
                      setTimeout(() => tryEnsure(0), 100);
                  };
                  window.addEventListener('firebaseReady', firebaseReadyListener);
              }
              if (attempts < 20) {
                  // Retry up to 20 times (10 seconds total)
                  setTimeout(() => tryEnsure(attempts + 1), 500);
                  return null;
              }
              // Clean up listener if still attached
              if (firebaseReadyListener && typeof window !== 'undefined') {
                  window.removeEventListener('firebaseReady', firebaseReadyListener);
              }
              console.warn('Firebase Database not available for presence after retries');
              return null;
          }
          
          // Clean up listener if we got here
          if (firebaseReadyListener && typeof window !== 'undefined') {
              window.removeEventListener('firebaseReady', firebaseReadyListener);
          }
          
          if (!voicePeerId) return null;
          if (voiceFirebasePresenceRef) return voiceFirebasePresenceRef;
      
      const roomPath = `voiceChat/${VOICE_ROOM_ID}/participants`;
      const fullPath = `${roomPath}/${voicePeerId}`;
      voiceFirebasePresenceRef = db.ref(fullPath);
      
      // Set presence data
      const presenceData = {
          peerId: voicePeerId,
          userId: globalChatUsername || 'User',
          muted: !!voiceMuted,
          joinedAt: Date.now(),
          lastSeen: Date.now()
      };
      
      voiceFirebasePresenceRef.set(presenceData).then(() => {
      }).catch((err) => {
          console.error('❌ Firebase presence write failed:', err);
          console.error('Error details:', {
              code: err.code,
              message: err.message,
              path: fullPath,
              data: presenceData
          });
          // Check if it's a permission error
          if (err.code === 'PERMISSION_DENIED') {
              console.error('⚠️ PERMISSION DENIED - Check Firebase Security Rules!');
              console.error('You need to allow writes to voiceChat/global/participants in Firebase Console > Realtime Database > Rules');
          }
      });
      voiceFirebasePresenceRef.onDisconnect().remove().catch((err) => {
          console.warn('Firebase onDisconnect setup failed:', err);
      });
      
      // Update lastSeen periodically
      const presenceUpdateInterval = setInterval(() => {
          if (voiceFirebasePresenceRef && voiceJoined) {
              voiceFirebasePresenceRef.update({ lastSeen: Date.now(), muted: !!voiceMuted });
          } else {
              clearInterval(presenceUpdateInterval);
          }
      }, 10000); // Update every 10 seconds
      
      return voiceFirebasePresenceRef;
      };
      
      return tryEnsure();
  }

  function startVoiceFirebaseListener() {
      // Wait for Firebase to be available
      let firebaseReadyListener = null;
      const tryStart = (attempts = 0) => {
          const db = getFirebaseDb();
          if (!db) {
              if (attempts === 0 && typeof window !== 'undefined') {
                  // Listen for firebaseReady event on first attempt
                  firebaseReadyListener = () => {
                      if (typeof window !== 'undefined') {
                          window.removeEventListener('firebaseReady', firebaseReadyListener);
                      }
                      // Retry immediately when Firebase is ready
                      setTimeout(() => tryStart(0), 100);
                  };
                  window.addEventListener('firebaseReady', firebaseReadyListener);
              }
              if (attempts < 20) {
                  // Retry up to 20 times (10 seconds total)
                  setTimeout(() => tryStart(attempts + 1), 500);
                  return;
              }
              // Clean up listener if still attached
              if (firebaseReadyListener && typeof window !== 'undefined') {
                  window.removeEventListener('firebaseReady', firebaseReadyListener);
              }
              console.warn('Firebase Database not available for listener after retries');
              return;
          }
          
          // Clean up listener if we got here
          if (firebaseReadyListener && typeof window !== 'undefined') {
              window.removeEventListener('firebaseReady', firebaseReadyListener);
          }
          
          if (voiceFirebaseListeners.length > 0) {
              return; // Already listening
          }
      
      const roomPath = `voiceChat/${VOICE_ROOM_ID}/participants`;
      const participantsRef = db.ref(roomPath);
      
      
      // Set loading state initially
      voiceParticipantsLoading = true;
      
      // Listen for participant changes (fires on initial load and updates)
      const onValueListener = participantsRef.on('value', (snapshot) => {
          try {
              const participants = snapshot.val() || {};
              const now = Date.now();
              const seen = new Set();
              
              // Track which participants were already known before this update
              // This helps detect truly new participants even if listener starts late
              const previouslyKnown = new Set(voiceParticipants.keys());
              
              // Update participants from Firebase (handles both initial load and updates)
              Object.keys(participants).forEach((peerId) => {
                  const data = participants[peerId];
                  if (!data) {
                      return;
                  }
                  if (!data.peerId) {
                      return;
                  }
                  seen.add(peerId);
                  
                  const prev = voiceParticipants.get(peerId);
                  const isNew = !prev;
                  const wasConnected = prev?.connected || false;
                  
                  // Show notification if this is a truly new participant (not in map and wasn't known before)
                  // This handles the case where listener starts after someone already joined
                  if (isNew && !previouslyKnown.has(peerId) && peerId !== voicePeerId && data.userId && !voiceParticipantsLoading) {
                      showVoiceActivity(`${getDisplayName(data.userId)} joined voice chat`);
                  }
                  
                  const updatedInfo = {
                      ...(prev || { userId: '', lastSeen: now, lastSpokeTs: 0, speaking: false, connected: false, lastBroadcastTs: 0, level: 0, lastLevelTs: 0, muted: false }),
                      userId: String(data.userId || ''),
                      lastSeen: Number(data.lastSeen || now) || now,
                      muted: !!data.muted,
                      connected: true // Always true when participant exists in Firebase
                  };
                  
                  // Only update if something actually changed (to prevent unnecessary re-renders)
                  const needsUpdate = isNew || 
                      prev.userId !== updatedInfo.userId ||
                      prev.muted !== updatedInfo.muted ||
                      prev.connected !== updatedInfo.connected ||
                      Math.abs(prev.lastSeen - updatedInfo.lastSeen) > 5000; // Only update if lastSeen changed significantly
                  
                  if (needsUpdate) {
                      voiceParticipants.set(peerId, updatedInfo);
                      
                      // Only update UI if connection status actually changed
                      if (wasConnected !== updatedInfo.connected && voiceUi.listEl) {
                          setParticipantConnected(peerId, updatedInfo.connected);
                      }
                  } else {
                  }
              });
              
              // Remove participants not in Firebase (except self if joined)
              Array.from(voiceParticipants.keys()).forEach((pid) => {
                  if (voiceJoined && pid === voicePeerId) return;
                  if (!seen.has(pid)) {
                      cleanupVoiceCall(pid);
                      voiceParticipants.delete(pid);
                  }
              });
              
              // Clear loading state after processing
              const wasLoading = voiceParticipantsLoading;
              voiceParticipantsLoading = false;
              
              // Only render if we were loading (initial load) or if participant count changed
              // This prevents flickering from periodic lastSeen updates
              if (wasLoading || seen.size !== (voiceParticipants.size - (voiceJoined && voicePeerId ? 1 : 0))) {
                  renderVoiceParticipants();
              } else {
              }
              
              // Try to call new participants - be aggressive about connecting
              if (voiceJoined) {
                  voiceParticipants.forEach((_info, pid) => {
                      if (pid !== voicePeerId && !voiceCalls.has(pid)) {
                          maybeCallPeer(pid);
                          maybeEnsureVoiceDataConn(pid);
                      } else if (pid !== voicePeerId) {
                      }
                  });
              }
          } catch (err) {
              console.error('Error processing Firebase participants:', err);
          }
      });
      
      voiceFirebaseListeners.push({ ref: participantsRef, listener: onValueListener, type: 'value' });
      
      // Listen for join events (for notifications)
      const onChildAddedListener = participantsRef.on('child_added', (snapshot) => {
          try {
              const data = snapshot.val();
              const peerId = snapshot.key;
              if (!data || !data.peerId) {
                  console.warn('🔥 Skipping participant - missing data or peerId:', { data, peerId });
                  return;
              }
              
              if (peerId !== voicePeerId && data.userId) {
                  showVoiceActivity(`${getDisplayName(data.userId)} joined voice chat`);
              }
              
              // Ensure participant is in the map (child_added may fire before value listener)
              if (!voiceParticipants.has(peerId)) {
                  const now = Date.now();
                  voiceParticipants.set(peerId, {
                      userId: String(data.userId || ''),
                      lastSeen: Number(data.lastSeen || now) || now,
                      muted: !!data.muted,
                      connected: true,
                      lastSpokeTs: 0,
                      speaking: false,
                      lastBroadcastTs: 0,
                      level: 0,
                      lastLevelTs: 0
                  });
              }
              
              // Clear loading state
              voiceParticipantsLoading = false;
              
              // Always render to show participants
              renderVoiceParticipants();
              
              // If we're joined, try to call the new participant
              if (voiceJoined && peerId !== voicePeerId) {
                  maybeCallPeer(peerId);
                  maybeEnsureVoiceDataConn(peerId);
              }
          } catch (err) {
              console.error('Error processing Firebase join:', err);
          }
      });
      
      voiceFirebaseListeners.push({ ref: participantsRef, listener: onChildAddedListener, type: 'child_added' });
      
      // Listen for leave events
      const onChildRemovedListener = participantsRef.on('child_removed', (snapshot) => {
          try {
              const data = snapshot.val();
              if (!data || !data.peerId) return;
              const peerId = snapshot.key;
              
              if (peerId !== voicePeerId && data.userId) {
                  showVoiceActivity(`${getDisplayName(data.userId)} left voice chat`);
              }
              
              cleanupVoiceCall(peerId);
              voiceParticipants.delete(peerId);
              renderVoiceParticipants();
          } catch (err) {
              console.error('Error processing Firebase leave:', err);
          }
      });
      
      voiceFirebaseListeners.push({ ref: participantsRef, listener: onChildRemovedListener, type: 'child_removed' });
      };
      
      tryStart();
  }

  function stopVoiceFirebaseListener() {
      voiceFirebaseListeners.forEach(({ ref, listener, type }) => {
          try {
              // listener is the unsubscribe function returned by .on()
              if (typeof listener === 'function') {
                  listener(); // Call unsubscribe function directly
              } else {
                  ref.off(type, listener); // Fallback to .off() method
              }
          } catch (_) {}
      });
      voiceFirebaseListeners = [];
      console.log('Firebase listeners stopped');
  }

  async function ensureVoiceRealtimeChannel(client) {
      // Re-enabled for participant discovery (user requested Supabase back for VC controls)
      // Notifications still use Cloudflare only to save quota
      // Make Supabase optional - if Cloudflare is enabled, don't wait for Supabase timeout
      if (!client) return null;
      if (!voicePeerId) return null;
      if (voiceRtChannel) return voiceRtChannel;
      // If Cloudflare is enabled, make Supabase optional (don't block on timeout)
      const useSupabaseAsFallback = !VOICE_DISCOVERY_ENABLED;
      voiceRtSubscribed = false;
      voiceRtChannel = client.channel(`voice:${VOICE_ROOM_ID}`, { config: { presence: { key: voicePeerId } } });
      voiceRtChannel
          .on('presence', { event: 'sync' }, () => {
              try {
                  const state = voiceRtChannel.presenceState();
                  const prevMap = new Map(voiceParticipants);
                  voiceParticipants.clear();
                  Object.keys(state || {}).forEach((key) => {
                      const metas = state[key] || [];
                      metas.forEach((m) => {
                          const pid = String(m?.peerId || key || '');
                          if (!pid) return;
                          const prev = prevMap.get(pid);
                          voiceParticipants.set(pid, {
                              userId: String(m?.userId || ''),
                              lastSeen: Date.now(),
                              lastSpokeTs: prev?.lastSpokeTs || 0,
                              speaking: !!prev?.speaking,
                              lastBroadcastTs: prev?.lastBroadcastTs || 0,
                              level: prev?.level || 0,
                              lastLevelTs: prev?.lastLevelTs || 0,
                              muted: !!prev?.muted,
                              connected: !!prev?.connected
                          });
                      });
                  });
                  // Ensure me is visible
                  if (voicePeerId && !voiceParticipants.has(voicePeerId)) {
                      const prev = prevMap.get(voicePeerId);
                      voiceParticipants.set(voicePeerId, {
                          userId: globalChatUsername || 'User',
                          lastSeen: Date.now(),
                          lastSpokeTs: prev?.lastSpokeTs || 0,
                          speaking: !!prev?.speaking,
                          lastBroadcastTs: prev?.lastBroadcastTs || 0,
                          level: prev?.level || 0,
                          lastLevelTs: prev?.lastLevelTs || 0,
                          muted: !!prev?.muted,
                          connected: prev ? !!prev.connected : true
                      });
                  }
                  renderVoiceParticipants();
                  voiceParticipants.forEach((_info, pid) => {
                      maybeCallPeer(pid);
                      maybeEnsureVoiceDataConn(pid);
                  });
              } catch (_) {}
          })
          .on('presence', { event: 'join' }, ({ newPresences }) => {
              (newPresences || []).forEach((m) => {
                  const pid = String(m?.peerId || '');
                  if (!pid) return;
                  const prev = voiceParticipants.get(pid);
                  voiceParticipants.set(pid, {
                      userId: String(m?.userId || ''),
                      lastSeen: Date.now(),
                      lastSpokeTs: prev?.lastSpokeTs || 0,
                      speaking: !!prev?.speaking,
                      lastBroadcastTs: prev?.lastBroadcastTs || 0,
                      level: prev?.level || 0,
                      lastLevelTs: prev?.lastLevelTs || 0,
                      muted: !!prev?.muted,
                      connected: !!prev?.connected
                  });
              });
              renderVoiceParticipants();
              voiceParticipants.forEach((_info, pid) => {
                  maybeCallPeer(pid);
                  maybeEnsureVoiceDataConn(pid);
              });
          })
          .on('presence', { event: 'leave' }, ({ leftPresences }) => {
              (leftPresences || []).forEach((m) => {
                  const pid = String(m?.peerId || '');
                  if (!pid) return;
                  cleanupVoiceCall(pid);
                  voiceParticipants.delete(pid);
              });
              renderVoiceParticipants();
          });

      // If Cloudflare is enabled, don't wait for Supabase timeout - make it non-blocking
      const subscribeTimeout = VOICE_DISCOVERY_ENABLED ? 3000 : 900; // Shorter timeout if Cloudflare is primary
      const status = await Promise.race([
          new Promise((resolve) => {
              try {
                  voiceRtChannel.subscribe((s) => {
                      if (s === 'SUBSCRIBED' || s === 'TIMED_OUT' || s === 'CHANNEL_ERROR' || s === 'CLOSED') resolve(s);
                  });
              } catch (_) { resolve('CHANNEL_ERROR'); }
          }),
          new Promise((resolve) => setTimeout(() => resolve('TIMEOUT_LOCAL'), subscribeTimeout))
      ]);
      voiceRtSubscribed = (status === 'SUBSCRIBED');

      if (voiceRtSubscribed) {
          try {
              await voiceRtChannel.track({ peerId: voicePeerId, userId: globalChatUsername || 'User', ts: Date.now() });
          } catch (_) {}
      } else {
          // If not subscribed, do NOT broadcast (prevents send() REST fallback spam)
          if (VOICE_DISCOVERY_ENABLED) {
              // Cloudflare is primary, Supabase timeout is not critical - just log
              console.log('Supabase Realtime not available, using Cloudflare discovery only');
          } else {
              // Supabase is primary, this is more critical
              console.warn('Voice realtime subscribe status:', status);
              if (String(status) === 'TIMED_OUT' || String(status) === 'TIMEOUT_LOCAL') {
                  showChatNotice('Supabase Realtime timed out. This can happen if WebSockets are blocked, an extension blocks Realtime, or the project is restricted/over quota. Voice peer discovery may fall back to activity heartbeats.', true);
                  setVoiceStatus('Realtime timed out. Trying fallback discovery…', true);
              }
          }
      }

      return voiceRtChannel;
  }

  async function ensureVoiceObserverChannel(client) {
      // Re-enabled for participant discovery (user requested Supabase back for VC controls)
      // Notifications still use Cloudflare only to save quota
      if (!client) return null;
      if (typeof client.channel !== 'function') {
          console.warn('ensureVoiceObserverChannel: client.channel is not a function. Client:', client);
          return null;
      }
      if (voiceJoined) return null;
      if (voiceObserverChannel) return voiceObserverChannel;
      if (!voiceObserverKey) voiceObserverKey = `obs_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
      voiceObserverChannel = client.channel(`voice:${VOICE_ROOM_ID}`, { config: { presence: { key: voiceObserverKey } } });

      const mergePresence = (meta) => {
          const pid = String(meta?.peerId || '');
          if (!pid) return;
          const prev = voiceParticipants.get(pid);
          voiceParticipants.set(pid, {
              userId: String(meta?.userId || prev?.userId || ''),
              lastSeen: Date.now(),
              lastSpokeTs: prev?.lastSpokeTs || 0,
              speaking: !!prev?.speaking,
              lastBroadcastTs: prev?.lastBroadcastTs || 0,
              level: prev?.level || 0,
              lastLevelTs: prev?.lastLevelTs || 0,
              muted: !!prev?.muted,
              connected: prev ? !!prev.connected : false
          });
      };

      voiceObserverChannel
          .on('presence', { event: 'sync' }, () => {
              try {
                  const state = voiceObserverChannel.presenceState();
                  const prevMap = new Map(voiceParticipants);
                  voiceParticipants.clear();
                  Object.keys(state || {}).forEach((key) => {
                      const metas = state[key] || [];
                      metas.forEach((m) => {
                          const pid = String(m?.peerId || key || '');
                          if (!pid) return;
                          const prev = prevMap.get(pid);
                          voiceParticipants.set(pid, {
                              userId: String(m?.userId || prev?.userId || ''),
                              lastSeen: Date.now(),
                              lastSpokeTs: prev?.lastSpokeTs || 0,
                              speaking: !!prev?.speaking,
                              lastBroadcastTs: prev?.lastBroadcastTs || 0,
                              level: prev?.level || 0,
                              lastLevelTs: prev?.lastLevelTs || 0,
                              muted: !!prev?.muted,
                              connected: prev ? !!prev.connected : false
                          });
                      });
                  });
                  renderVoiceParticipants();
              } catch (_) {}
          })
          .on('presence', { event: 'join' }, ({ newPresences }) => {
              (newPresences || []).forEach((m) => mergePresence(m));
              renderVoiceParticipants();
          })
          .on('presence', { event: 'leave' }, ({ leftPresences }) => {
              (leftPresences || []).forEach((m) => {
                  const pid = String(m?.peerId || '');
                  if (pid) voiceParticipants.delete(pid);
              });
              renderVoiceParticipants();
          });

      try {
          await new Promise((resolve) => {
              voiceObserverChannel.subscribe((s) => {
                  if (s === 'SUBSCRIBED' || s === 'TIMED_OUT' || s === 'CHANNEL_ERROR' || s === 'CLOSED') resolve(s);
              });
          });
      } catch (_) {}

      return voiceObserverChannel;
  }

  async function joinVoiceChat() {
      ensureVoiceUi();
      if (voiceJoined) return;
      if (!globalChatUsername) {
          showChatNotice('Set your chat name before joining voice.', true);
          return;
      }
      const gate = getVoiceGateState();
      if (gate !== 'adult_accepted') {
          await openVoiceGateModal({ afterAccept: () => joinVoiceChat() });
          return;
      }
      const block = getVoiceBlockReason(globalChatUsername);
      if (block.blocked) {
          if (block.type === 'ban') {
              showChatNotice('You are banned from voice chat.', true);
              setVoiceStatus('Voice banned.', true);
              return;
          }
          if (block.type === 'timeout') {
              const ms = Math.max(0, (block.until || 0) - Date.now());
              const mins = Math.ceil(ms / 60000);
              showChatNotice(`You are timed out from voice chat (${mins}m).`, true);
              setVoiceStatus('Voice timed out.', true);
              return;
          }
      }

      setVoiceStatus('Requesting microphone permission…');
      const Peer = await ensurePeerJs();
      if (!Peer) {
          showChatNotice('Voice chat failed: PeerJS did not load.', true);
          setVoiceStatus('PeerJS failed to load.', true);
          return;
      }

      try {
          voiceLocalStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          // CRITICAL: Ensure all audio tracks are enabled
          if (voiceLocalStream) {
              voiceLocalStream.getAudioTracks().forEach(track => {
                  track.enabled = true;
              });
          }
      } catch (err) {
          console.warn('getUserMedia failed', err);
          showChatNotice('Mic permission denied/unavailable.', true);
          setVoiceStatus('Mic unavailable.', true);
          return;
      }

      setVoiceStatus('Connecting voice…');
      voicePeer = new Peer();
      
      // CRITICAL: Resume AudioContext on user gesture (browser autoplay policy)
      if (!voiceMasterAudioCtx) {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          if (AudioCtx) {
              try {
                  voiceMasterAudioCtx = new AudioCtx();
                  window.audioCtx = voiceMasterAudioCtx; // Store globally
              } catch (err) {
                  console.warn('Failed to create AudioContext:', err);
              }
          }
      }
      if (voiceMasterAudioCtx && voiceMasterAudioCtx.state === 'suspended') {
          voiceMasterAudioCtx.resume().then(() => {
              console.log('✅ AudioContext resumed on join (user gesture)');
          }).catch(err => {
              console.warn('Failed to resume AudioContext on join:', err);
          });
      }
      
      // PeerJS data channel: used for voice meter + speaking sync (reduces Supabase realtime usage)
      try {
          voicePeer.on('connection', (conn) => {
              try { setupVoiceDataConn(conn); } catch (_) {}
          });
      } catch (_) {}
      voicePeer.on('open', async (id) => {
          voicePeerId = String(id || '');
          voiceJoined = true;
          voiceMuted = false;
          if (voiceUi.joinBtn) voiceUi.joinBtn.style.display = 'none';
          if (voiceUi.joinBtnContainer) voiceUi.joinBtnContainer.style.display = 'none';
          if (voiceUi.leaveBtn) voiceUi.leaveBtn.style.display = 'inline-block';
          if (voiceUi.muteBtn) voiceUi.muteBtn.style.display = 'inline-block';
          if (voiceUi.muteBtn) voiceUi.muteBtn.textContent = 'Mute';
          // Screen sharing removed - no longer needed
          if (voiceUi.reportsBtn) voiceUi.reportsBtn.style.display = (globalChatUsername === '%Owner%') ? 'inline-block' : 'none';
          
          // Make panel full-page - move to body and apply full-page styles
          if (voiceUi.panel) {
              // Move panel to body if it's not already there
              if (voiceUi.panel.parentElement !== document.body) {
                  document.body.appendChild(voiceUi.panel);
              }
              
              // Apply full-page styles with !important to override any parent constraints
              voiceUi.panel.style.setProperty('display', 'block', 'important');
              voiceUi.panel.style.setProperty('position', 'fixed', 'important');
              voiceUi.panel.style.setProperty('top', '0', 'important');
              voiceUi.panel.style.setProperty('left', '0', 'important');
              voiceUi.panel.style.setProperty('right', '0', 'important');
              voiceUi.panel.style.setProperty('bottom', '0', 'important');
              voiceUi.panel.style.setProperty('width', '100vw', 'important');
              voiceUi.panel.style.setProperty('height', '100vh', 'important');
              voiceUi.panel.style.setProperty('max-width', '100vw', 'important');
              voiceUi.panel.style.setProperty('max-height', '100vh', 'important');
              voiceUi.panel.style.setProperty('padding', '24px', 'important');
              voiceUi.panel.style.setProperty('border-radius', '0', 'important');
              voiceUi.panel.style.setProperty('z-index', '99999', 'important');
              voiceUi.panel.style.setProperty('overflow-y', 'auto', 'important');
              voiceUi.panel.style.setProperty('background', 'linear-gradient(135deg, rgba(15,23,42,0.98), rgba(30,41,59,0.95))', 'important');
              voiceUi.panel.style.setProperty('border', 'none', 'important');
              voiceUi.panel.style.setProperty('box-shadow', 'none', 'important');
              voiceUi.panel.style.setProperty('margin', '0', 'important');
          }

          voiceNoiseFloor = 0;
          voiceNoiseFloorInitTs = Date.now();
          startVoiceMeter(voiceLocalStream);

          voiceParticipants.set(voicePeerId, {
              userId: globalChatUsername || 'User',
              lastSeen: Date.now(),
              lastSpokeTs: 0,
              speaking: false,
              lastBroadcastTs: 0,
              level: 0,
              lastLevelTs: 0,
              muted: false,
              connected: true,
          });
          // Set loading state while waiting for other participants
          voiceParticipantsLoading = true;
          renderVoiceParticipants();
          setVoiceStatus('Joined voice.');
          
          // Clear loading state after 5 seconds max (in case participants never arrive)
          setTimeout(() => {
              if (voiceParticipantsLoading) {
                  voiceParticipantsLoading = false;
                  renderVoiceParticipants();
              }
          }, 5000);

          // Use Firebase Realtime Database as primary for participant discovery
          try {
              // Set up Firebase presence
              ensureVoiceFirebasePresence();
              // Start listening for participant changes
              startVoiceFirebaseListener();
          } catch (err) {
              console.error('Firebase voice chat setup failed:', err);
          }
          
          // Optional: Cloudflare for notifications only (if enabled)
          if (VOICE_DISCOVERY_ENABLED) {
              try {
                  ensureVoiceDiscoveryJoined();
                  // Send join notification via Cloudflare (optional)
                  const sendJoinNotification = () => {
                      if (voiceDiscoveryWs && voiceDiscoveryWs.readyState === 1) {
                          sendVoiceDiscovery({ type: 'join', peerId: voicePeerId, userId: globalChatUsername || 'User', muted: !!voiceMuted, ts: Date.now() });
                      } else if (voiceDiscoveryWs && voiceDiscoveryWs.readyState === 0) {
                          setTimeout(() => {
                              if (voiceDiscoveryWs && voiceDiscoveryWs.readyState === 1) {
                                  sendVoiceDiscovery({ type: 'join', peerId: voicePeerId, userId: globalChatUsername || 'User', muted: !!voiceMuted, ts: Date.now() });
                              }
                          }, 200);
                      } else {
                          setTimeout(sendJoinNotification, 100);
                      }
                  };
                  sendJoinNotification();
              } catch (_) {}
          }
          
          // Stop Supabase channels (Firebase replaces them)
          if (voiceObserverChannel) {
              try { await voiceObserverChannel.unsubscribe(); } catch (_) {}
              voiceObserverChannel = null;
          }
          if (voiceRtChannel) {
              try { await voiceRtChannel.unsubscribe(); } catch (_) {}
              voiceRtChannel = null;
          }
      });
      voicePeer.on('call', (call) => {
          console.log('📞 Incoming call from', call.peer);
          if (!voiceLocalStream) {
              console.warn('📞 Rejecting call - no local stream');
              try { call.close(); } catch (_) {}
              return;
          }
          const remoteId = call.peer;
          // Respect owner moderation
          try {
              const info = voiceParticipants.get(remoteId);
              const uid = String(info?.userId || '');
              const block = getVoiceBlockReason(uid);
              if (block.blocked) {
                  console.warn('📞 Rejecting call - peer is blocked');
                  try { call.close(); } catch (_) {}
                  return;
              }
          } catch (_) {}
          if (!voiceCalls.has(remoteId)) {
              voiceCalls.set(remoteId, call);
              console.log('📞 Stored incoming call for', remoteId);
          } else {
              console.log('📞 Call already exists for', remoteId, '- using existing');
              call = voiceCalls.get(remoteId); // Use existing call
          }
          let streamToAnswer = voiceLocalStream;
          console.log('📞 Answering call from', remoteId, 'with stream:', !!streamToAnswer, 'tracks:', streamToAnswer?.getTracks().length);
          if (!streamToAnswer || streamToAnswer.getTracks().length === 0) {
              console.error('📞 Cannot answer call - no valid local stream');
              try { call.close(); } catch (_) {}
              return;
          }
          try { 
              call.answer(streamToAnswer);
              console.log('📞 Call answered successfully');
              
              // IMPORTANT: Also initiate a call back to ensure bidirectional audio
              // Even though they called us, we should also call them to ensure both directions work
              // This is especially important if there are any connection issues
              setTimeout(() => {
                  if (voiceJoined && voicePeerId && remoteId) {
                      // Check if we already have a call (we should, but double-check)
                      if (!voiceCalls.has(remoteId)) {
                          console.log('📞 Initiating bidirectional call to', remoteId, 'after receiving their call');
                          maybeCallPeer(remoteId);
                      } else {
                          console.log('📞 Bidirectional call already established with', remoteId);
                      }
                  }
              }, 300);
          } catch (err) {
              console.error('📞 Error answering call:', err);
          }
          call.on('stream', (remoteStream) => {
              // Store the remote stream on the call object
              call.remoteStream = remoteStream;
              console.log('✅ Received incoming call stream for', remoteId, 'Audio tracks:', remoteStream.getAudioTracks().length);
              console.log('✅ Stream details:', {
                  id: remoteStream.id,
                  active: remoteStream.active,
                  tracks: remoteStream.getTracks().map(t => ({
                      id: t.id,
                      kind: t.kind,
                      enabled: t.enabled,
                      readyState: t.readyState,
                      muted: t.muted
                  }))
              });
              // Immediately attach audio
              attachRemoteAudio(remoteId, remoteStream);
              // Also check for audio tracks that might be added later
              if (remoteStream.getAudioTracks().length > 0) {
                  remoteStream.getAudioTracks().forEach(track => {
                      track.onended = () => {
                          console.log('Audio track ended for', remoteId);
                      };
                      track.onmute = () => {
                          console.log('Audio track muted for', remoteId);
                      };
                      track.onunmute = () => {
                          console.log('Audio track unmuted for', remoteId);
                          attachRemoteAudio(remoteId, remoteStream);
                      };
                  });
              }
          });
          // Listen for track events to detect when audio/video tracks are added
          if (call.peerConnection) {
              call.peerConnection.ontrack = (event) => {
                  const track = event.track;
                  if (!track) return;
                  
                  console.log('Track event for incoming call', remoteId, 'Kind:', track.kind, 'Enabled:', track.enabled);
                  
                  if (track.kind === 'audio') {
                      // Audio track added - use stream from event if available
                      let streamToUse = null;
                      if (event.streams && event.streams.length > 0) {
                          // Use the stream from the event (this is the actual PeerJS stream)
                          streamToUse = event.streams[0];
                          call.remoteStream = streamToUse;
                          console.log('Using stream from event for incoming call audio track', remoteId);
                      } else {
                          // Track without stream - add to existing or create new
                          if (!call.remoteStream) {
                              call.remoteStream = new MediaStream();
                          }
                          // Check if track already exists
                          if (call.remoteStream && call.remoteStream.getAudioTracks) {
                              if (!call.remoteStream.getAudioTracks().some(t => t.id === track.id)) {
                                  call.remoteStream.addTrack(track);
                                  console.log('Added audio track to incoming call stream for', remoteId);
                              }
                          }
                          streamToUse = call.remoteStream;
                      }
                      
                      // Attach audio with the stream
                      if (streamToUse) {
                          attachRemoteAudio(remoteId, streamToUse);
                      }
                      
                      // Monitor track state changes
                      track.onended = () => {
                          console.log('Audio track ended for incoming call', remoteId);
                      };
                      track.onmute = () => {
                          console.log('Audio track muted for incoming call', remoteId);
                      };
                      track.onunmute = () => {
                          console.log('Audio track unmuted for incoming call', remoteId);
                          // Use the stream from call.remoteStream
                          if (call.remoteStream) {
                              attachRemoteAudio(remoteId, call.remoteStream);
                          }
                      };
                  }
                  // Video tracks are ignored - audio-only voice chat
              };
          }
          call.on('close', () => cleanupVoiceCall(remoteId));
          call.on('error', () => cleanupVoiceCall(remoteId));
      });
      voicePeer.on('error', (err) => {
          console.warn('Peer error', err);
          setVoiceStatus('Voice connection error.', true);
      });
  }

  async function leaveVoiceChat() {
      if (!voiceJoined) return;
      setVoiceStatus('Leaving voice…');
      // Make leaving instant; do realtime cleanup/broadcast in the background (realtime may be TIMED_OUT).
      const leavingPeerId = voicePeerId;
      const leavingUserId = globalChatUsername || 'User';

      // Send leave message BEFORE closing anything (so Cloudflare can broadcast it)
      if (VOICE_DISCOVERY_ENABLED) {
          try { sendVoiceDiscovery({ type: 'leave', peerId: leavingPeerId, userId: leavingUserId, ts: Date.now() }); } catch (_) {}
          // Give the message time to send before switching to observer mode
          await new Promise((r) => setTimeout(r, 150));
      }

      Array.from(voiceCalls.keys()).forEach((pid) => cleanupVoiceCall(pid));
      voiceCalls.clear();
      voiceDataConns.clear();
      stopVoiceActivityHeartbeats();
      voiceParticipants.clear();
      renderVoiceParticipants();
      if (voiceLocalStream) {
          try { voiceLocalStream.getTracks().forEach(t => t.stop()); } catch (_) {}
      }
      voiceLocalStream = null;
      stopVoiceMeter();
      if (voicePeer) {
          try { voicePeer.destroy(); } catch (_) {}
      }
      voicePeer = null;
      voicePeerId = '';
      voiceJoined = false;
      voiceMuted = false;
      if (voiceUi.joinBtn) voiceUi.joinBtn.style.display = 'block';
      if (voiceUi.joinBtnContainer) voiceUi.joinBtnContainer.style.display = 'flex';
      if (voiceUi.leaveBtn) voiceUi.leaveBtn.style.display = 'none';
      if (voiceUi.muteBtn) voiceUi.muteBtn.style.display = 'none';
      if (voiceUi.reportsBtn) voiceUi.reportsBtn.style.display = 'none';
      
      // Science page: restore Join button and hide all in-call controls
      if (typeof window !== 'undefined' && window.location.pathname.includes('science.html')) {
          const joinBtnCenter = document.getElementById('joinBtnCenter');
          const joinButtonContainer = document.getElementById('joinButtonContainer');
          const leaveBtn = document.getElementById('leaveBtn');
          const muteBtn = document.getElementById('muteBtn');
          const reportsBtn = document.getElementById('reportsBtn');
          
          if (joinBtnCenter) joinBtnCenter.style.display = 'flex';
          if (joinButtonContainer) joinButtonContainer.style.display = 'flex';
          if (leaveBtn) leaveBtn.style.display = 'none';
          if (muteBtn) muteBtn.style.display = 'none';
          if (reportsBtn) reportsBtn.style.display = 'none';
      }
      
      // Restore panel to normal size and move back to original location
      if (voiceUi.panel) {
          // Move panel back to original location
          const originalParent = globalChatPanel;
          if (originalParent && voiceUi.panel.parentElement === document.body) {
              if (globalChatBox && globalChatBox.parentElement === originalParent) {
                  originalParent.insertBefore(voiceUi.panel, globalChatBox);
              } else {
                  originalParent.insertBefore(voiceUi.panel, originalParent.firstChild || null);
              }
          }
          
          // Restore normal styles
          voiceUi.panel.style.cssText = `
              display: none;
              position: relative;
              padding: 12px;
              border-radius: 14px;
              border: 1px solid rgba(255,255,255,0.10);
              background: rgba(255,255,255,0.04);
              box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
              width: 100%;
              max-width: 100%;
          `;
      }
      setVoiceStatus('Left voice.');

      // Clean up Firebase presence
      if (voiceFirebasePresenceRef) {
          try {
              voiceFirebasePresenceRef.remove();
          } catch (_) {}
          voiceFirebasePresenceRef = null;
      }
      
      // Stop Firebase listeners
      stopVoiceFirebaseListener();
      
      // Background cleanup (best effort)
      setTimeout(async () => {
          // Optional: Send leave notification via Cloudflare if enabled
          if (VOICE_DISCOVERY_ENABLED && leavingPeerId) {
              try {
                  sendVoiceDiscovery({ type: 'leave', peerId: leavingPeerId, userId: leavingUserId, ts: Date.now() });
              } catch (_) {}
          }

          // Clean up Supabase channels (if any)
          if (voiceRtChannel) {
              const ch = voiceRtChannel;
              voiceRtChannel = null;
              voiceRtSubscribed = false;
              try { await Promise.race([ch.untrack(), new Promise((r) => setTimeout(r, 700))]); } catch (_) {}
              try { await Promise.race([ch.unsubscribe(), new Promise((r) => setTimeout(r, 700))]); } catch (_) {}
          }
      }, 0);

      // Re-enable observer mode (Firebase) so users can see participants without joining
      try {
          if (VOICE_DISCOVERY_ENABLED) {
              stopVoiceDiscoverySocket();
              setTimeout(() => {
                  try { ensureVoiceDiscoveryObserver(); } catch (_) {}
              }, 100);
          }
          // Start Firebase observer listener for non-joined users
          startVoiceFirebaseListener();
      } catch (_) {}
  }

  function toggleVoiceMute() {
      if (!voiceLocalStream) return;
      voiceMuted = !voiceMuted;
      try { voiceLocalStream.getAudioTracks().forEach(t => { t.enabled = !voiceMuted; }); } catch (_) {}
      if (voiceUi.muteBtn) voiceUi.muteBtn.textContent = voiceMuted ? 'Unmute' : 'Mute';
      setVoiceStatus(voiceMuted ? 'Muted.' : 'Unmuted.');
      // Update Firebase presence with mute state
      if (voiceFirebasePresenceRef && voicePeerId) {
          try {
              voiceFirebasePresenceRef.update({ muted: !!voiceMuted, lastSeen: Date.now() });
          } catch (_) {}
      }
      
      // Optional: Update Cloudflare if enabled
      if (VOICE_DISCOVERY_ENABLED && voicePeerId) {
          try { sendVoiceDiscovery({ type: 'update', peerId: voicePeerId, muted: !!voiceMuted, ts: Date.now() }); } catch (_) {}
      }
      // Broadcast mute state via level packets (so mini meter turns red for everyone)
      if (voicePeerId && voiceParticipants.has(voicePeerId)) {
          const info = voiceParticipants.get(voicePeerId);
          info.muted = !!voiceMuted;
          voiceParticipants.set(voicePeerId, info);
          setParticipantLevel(voicePeerId, voiceMuted ? 0 : (info.level || 0), Date.now());
          if (voiceMuted) setParticipantSpeaking(voicePeerId, false);
          broadcastLocalLevel(voiceMuted ? 0 : (info.level || 0));
      }
  }


  // Detect phone numbers in text
  function containsPhoneNumber(text) {
      if (!text) return false;
      // Common phone number patterns:
      // (123) 456-7890, 123-456-7890, 123.456.7890, 1234567890
      // +1 123 456 7890, +1-123-456-7890
      // International: +44 20 1234 5678
      // Exclude years (4 digits) and common numbers that aren't phones
      const phonePatterns = [
          /(\+?\d{1,3}[\s.-]?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}\b/, // US format with word boundary
          /\+\d{1,3}[\s.-]?\d{1,4}[\s.-]?\d{1,4}[\s.-]?\d{1,9}\b/, // International with word boundary
          /\b\d{3}[\s.-]?\d{3}[\s.-]?\d{4}\b/, // Simple 10-digit with word boundaries
          /\b\d{10,11}\b/, // 10-11 digit numbers (but not years like 2024)
      ];
      
      // Exclude common false positives
      const excludePatterns = [
          /\b(19|20)\d{2}\b/, // Years like 1999, 2024
          /\b\d{4}-\d{2}-\d{2}\b/, // Dates like 2024-01-01
          /\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/, // Dates like 1/1/2024
      ];
      
      // Check if text matches phone patterns
      const hasPhonePattern = phonePatterns.some(pattern => pattern.test(text));
      if (!hasPhonePattern) return false;
      
      // Exclude if it matches date/year patterns
      const isExcluded = excludePatterns.some(pattern => pattern.test(text));
      if (isExcluded) return false;
      
      return true;
  }

  // Detect addresses in text
  function containsAddress(text) {
      if (!text) return false;
      
      // Address indicators - more specific patterns
      const addressPatterns = [
          // Street address patterns: "123 Main Street", "456 Oak Ave"
          /\b\d+\s+[a-z]+\s+(street|st|avenue|ave|road|rd|drive|dr|lane|ln|way|blvd|boulevard|court|ct|place|pl|circle|cir|parkway|pkwy)\b/i,
          // Street name with number: "Main Street 123"
          /\b[a-z]+\s+(street|st|avenue|ave|road|rd|drive|dr|lane|ln|way|blvd|boulevard|court|ct|place|pl|circle|cir)\s+\d+/i,
          // Apartment/Unit patterns: "Apt 5", "Suite 100", "Unit 3B"
          /\b(apartment|apt|suite|ste|unit|building|bldg|floor|fl|room|rm)\s*[#]?\s*\d+[a-z]?\b/i,
          // ZIP code patterns: "12345" or "12345-6789" followed by city/state
          /\b\d{5}(-\d{4})?\s+[a-z]+\s*,\s*[a-z]{2}\b/i, // ZIP City, State
          /\b[a-z]+\s*,\s*[a-z]{2}\s+\d{5}(-\d{4})?\b/i, // City, State ZIP
          // Full address pattern: "123 Main St, City, ST 12345"
          /\b\d+\s+[a-z]+\s+(street|st|avenue|ave|road|rd|drive|dr|lane|ln|way|blvd|boulevard)\s*,\s*[a-z]+\s*,\s*[a-z]{2}\s+\d{5}\b/i,
      ];
      
      // Check for address patterns
      return addressPatterns.some(pattern => pattern.test(text));
  }

  // Username checking removed - Worker handles this server-side if needed
  async function isUsernameTaken(username, excludeCurrentUser = false) {
      // Always return false - Worker will handle username validation
      return false;
  }

const COMMON_EMOJIS = [
  '\u{1F600}','\u{1F603}','\u{1F604}','\u{1F601}','\u{1F606}','\u{1F605}','\u{1F602}','\u{1F923}',
  '\u{1F60A}','\u{1F60D}','\u{1F618}','\u{1F61B}','\u{1F61C}','\u{1F61D}','\u{1F60E}',
  '\u{1F642}','\u{1F609}','\u{1F917}','\u{1F929}','\u{1F973}','\u{1F60F}','\u{1F612}','\u{1F620}',
  '\u{1F621}','\u{1F624}','\u{1F92C}','\u{1F62D}','\u{1F613}','\u{1F622}','\u{1F625}','\u{1F630}',
  '\u{1F631}','\u{1F628}','\u{1F62E}','\u{1F634}','\u{1F635}','\u{1F637}','\u{1F912}','\u{1F915}',
  '\u{1F47B}','\u{1F47D}','\u{1F921}','\u{1F4A9}','\u{1F44D}','\u{1F44E}','\u{1F44C}','\u{1F44F}',
  '\u{1F64C}','\u{1F64F}','\u{1F91D}','\u{1F918}','\u{1F919}','\u{1F91F}','\u{1F44A}','\u{1F4AA}',
  '\u{2764}\u{FE0F}','\u{1F494}','\u{1F496}','\u{2728}','\u{1F389}','\u{1F525}','\u{1F340}',
  '\u{1F31F}','\u{2B50}','\u{2600}\u{FE0F}','\u{1F319}','\u{2614}', '6','7'
];
const EMOJI_POPULAR = [
  '\u{1F600}','\u{1F605}','\u{1F602}','\u{1F60A}','\u{1F60D}','\u{1F60E}','\u{1F62D}','\u{1F914}',
  '\u{1F620}','\u{1F44D}','\u{1F44F}','\u{1F64F}','\u{1F525}','\u{1F480}','\u{1F389}','\u{1F973}',
  '\u{1F92F}','\u{1F91D}','\u{2764}\u{FE0F}','\u{2728}','\u{1F44C}','\u{1F64C}','\u{1F634}','\u{1F922}','\u{1F921}','6','7'
];
let emojiPaletteLoaded = false;
  let emojiList = [...COMMON_EMOJIS];
let supabaseScriptLoadPromise = null;
// Supabase removed from chat - using Worker only
// Keep enough chat history so "messages since last open" doesn't get artificially capped.
// (This is also used by the cleanup routine.)
const CHAT_MAX_MESSAGES = 5000;
const CHAT_CLEANUP_COOLDOWN = 5 * 60 * 1000; // 5 minutes
let lastChatCleanupTs = 0;
  const typingUsers = new Map(); // user -> lastSeen
  let typingThrottleTs = 0;
  let typingTimeout = null;
  const chatThemes = {
      nebula: {
          panelBg: 'linear-gradient(145deg, rgba(17,17,27,0.92), rgba(28,21,46,0.95))',
          panelBorder: 'rgba(124,58,237,0.35)',
          boxBg: 'rgba(255,255,255,0.02)',
          boxBorder: 'rgba(255,255,255,0.05)',
          bubbleBg: 'linear-gradient(135deg, rgba(124,58,237,0.18), rgba(99,102,241,0.22))',
          bubbleBorder: 'rgba(124,58,237,0.35)',
          bubbleShadow: '0 8px 22px rgba(0,0,0,0.25)',
          sendBg: 'linear-gradient(135deg, #8B5CF6, #6366F1)'
      },
      sunset: {
          panelBg: 'linear-gradient(145deg, rgba(48,19,7,0.92), rgba(83,23,17,0.95))',
          panelBorder: 'rgba(249,115,22,0.4)',
          boxBg: 'rgba(255,255,255,0.03)',
          boxBorder: 'rgba(249,115,22,0.2)',
          bubbleBg: 'linear-gradient(135deg, rgba(249,115,22,0.22), rgba(239,68,68,0.24))',
          bubbleBorder: 'rgba(249,115,22,0.4)',
          bubbleShadow: '0 10px 24px rgba(0,0,0,0.28)',
          sendBg: 'linear-gradient(135deg, #F97316, #EF4444)'
      },
      ocean: {
          panelBg: 'linear-gradient(145deg, rgba(6,30,49,0.9), rgba(4,49,70,0.94))',
          panelBorder: 'rgba(6,182,212,0.35)',
          boxBg: 'rgba(255,255,255,0.025)',
          boxBorder: 'rgba(6,182,212,0.2)',
          bubbleBg: 'linear-gradient(135deg, rgba(6,182,212,0.22), rgba(37,99,235,0.24))',
          bubbleBorder: 'rgba(6,182,212,0.35)',
          bubbleShadow: '0 10px 24px rgba(0,0,0,0.28)',
          sendBg: 'linear-gradient(135deg, #06B6D4, #2563EB)'
      },
      dark: {
          panelBg: 'linear-gradient(145deg, rgba(10,10,15,0.96), rgba(18,18,22,0.96))',
          panelBorder: 'rgba(255,255,255,0.08)',
          boxBg: 'rgba(255,255,255,0.03)',
          boxBorder: 'rgba(255,255,255,0.08)',
          bubbleBg: 'linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.04))',
          bubbleBorder: 'rgba(255,255,255,0.08)',
          bubbleShadow: '0 10px 24px rgba(0,0,0,0.35)',
          sendBg: 'linear-gradient(135deg, #1f2937, #0f172a)'
      }
  };
  let activeChatTheme = localStorage.getItem('globalChatTheme') || 'dark';
  let currentBubbleStyle = chatThemes[activeChatTheme] || chatThemes.nebula;

  function hexToRgb(hex) {
      let h = hex.replace('#','');
      if (h.length === 3) {
          h = h.split('').map(c => c + c).join('');
      }
      const int = parseInt(h, 16);
      if (Number.isNaN(int) || h.length !== 6) return null;
      return [(int >> 16) & 255, (int >> 8) & 255, int & 255];
  }

  function persistReactions() {
      try {
          localStorage.setItem('globalChatReactions', JSON.stringify(reactionsById));
      } catch (_) {}
  }

  function buildPersonalBubbleStyle() {
      const rgb = hexToRgb(customMyBubbleColor || '');
      if (!rgb) {
          return {
              bg: currentBubbleStyle.bubbleBg,
              border: currentBubbleStyle.bubbleBorder,
              shadow: currentBubbleStyle.bubbleShadow
          };
      }
      const [r,g,b] = rgb;
      const border = `rgba(${r}, ${g}, ${b}, 0.9)`;
      const bg = `linear-gradient(135deg, rgba(${r}, ${g}, ${b}, 0.12), rgba(${r}, ${g}, ${b}, 0.18))`;
      const shadow = `0 8px 22px rgba(${r}, ${g}, ${b}, 0.18)`;
      return { bg, border, shadow };
  }

  function unifiedToEmoji(unified) {
      if (!unified) return '';
      try {
          return unified.split('-').map(u => String.fromCodePoint(parseInt(u, 16))).join('');
      } catch (_) {
          return '';
      }
  }

  async function loadEmojiPicker(targetContainer, onSelect) {
      if (!targetContainer) return;
      const populate = (list) => {
          targetContainer.innerHTML = '';
          const ordered = [...new Set([...EMOJI_POPULAR, ...list])];
          ordered.forEach(ch => {
              const btn = document.createElement('button');
              btn.textContent = ch;
              btn.style.border = 'none';
              btn.style.background = 'transparent';
              btn.style.fontSize = '18px';
              btn.style.cursor = 'pointer';
              btn.style.padding = '6px';
              btn.addEventListener('click', () => onSelect(ch));
              targetContainer.appendChild(btn);
          });
      };
      populate(emojiList);
      emojiPaletteLoaded = true;
      // Display state is controlled by callers (keep hidden by default)
  }

  function applyChatTheme(themeKey) {
      const theme = chatThemes[themeKey] || chatThemes.nebula;
      activeChatTheme = themeKey;
      currentBubbleStyle = theme;
      localStorage.setItem('globalChatTheme', themeKey);
      if (globalChatPanel) {
          globalChatPanel.style.background = theme.panelBg;
          globalChatPanel.style.borderColor = theme.panelBorder;
      }
      if (globalChatBox) {
          globalChatBox.style.background = theme.boxBg;
          globalChatBox.style.borderColor = theme.boxBorder;
      }
      if (globalChatSendBtn) {
          globalChatSendBtn.style.background = theme.sendBg;
      }
  }
  applyChatTheme(activeChatTheme);
  const messageNodeIndex = new Map();
  let chatToastTimer = null;
  let chatToastEl = null;
  let chatToastStyleInjected = false;
  let suppressChatToast = true; // prevent toasts during history bootstrap
  let chatHistoryBootstrapped = false;
  let globalChatUnread = 0;
  let globalChatBadge = null;
  let globalChatIsOpen = false;
  let lastGlobalChatSeenTs = Number(localStorage.getItem('globalChatLastSeenTs') || 0) || 0;
  let lastSupabaseChatTs = 0; // Keep for timestamp tracking (renamed from Supabase but still used for message timestamps)
  
  // Cloudflare Worker WebSocket for chat (no Supabase cost)
  const CHAT_WS_URL = "wss://chat-worker.ethan-owsiany.workers.dev";
  let chatWorkerWs = null;
  let chatWorkerWsReconnectTimer = null;
  let chatWorkerConnected = false;
  let workerHistoryLoaded = false;
  
  // Hybrid snapshot model: Local cache for instant loading
  const CHAT_CACHE_KEY = 'chat_cache_v1';
  const CHAT_CACHE_MAX_AGE = 5 * 60 * 1000; // 5 minutes
  const MAX_CACHED_MESSAGES = 50;
  
  // Rate limiting for message deduplication
  const MIN_REALTIME_INTERVAL = 5000; // 5 seconds minimum between realtime messages (deduplication)

  function ensureChatToast() {
      if (!chatToastStyleInjected) {
          const style = document.createElement('style');
          style.textContent = `
              .chat-toast {
                  position: fixed;
                  top: 16px;
                  left: 16px;
                  z-index: 1000000;
                  background: rgba(16, 18, 30, 0.95);
                  border: 1px solid rgba(255, 255, 255, 0.15);
                  color: #f8fafc;
                  padding: 10px 14px;
                  border-radius: 10px;
                  box-shadow: 0 16px 40px rgba(0,0,0,0.55), 0 0 0 2px rgba(99,102,241,0.35);
                  font-size: 13px;
                  font-weight: 700;
                  max-width: min(320px, 90vw);
                  display: none;
              }
              .chat-toast .toast-user { color: #a5b4fc; margin-right: 6px; }
              .chat-toast .toast-text { color: #e2e8f0; }
              .chat-unread-badge {
                  position: absolute;
                  top: -6px;
                  left: -6px;
                  background: #ef4444;
                  color: #fff;
                  border-radius: 999px;
                  min-width: 22px;
                  height: 22px;
                  padding: 0 6px;
                  display: none;
                  align-items: center;
                  justify-content: center;
                  font-size: 12px;
                  font-weight: 800;
                  box-shadow: 0 4px 10px rgba(0,0,0,0.35);
                  z-index: 9999;
              }
          `;
          document.head.appendChild(style);
          chatToastStyleInjected = true;
      }
      if (!chatToastEl) {
          chatToastEl = document.createElement('div');
          chatToastEl.className = 'chat-toast';
          chatToastEl.innerHTML = `<span class="toast-user"></span><span class="toast-text"></span>`;
          document.body.appendChild(chatToastEl);
      }
  }

function ensureChatBadge() {
    if (!globalChatBadge) {
        ensureChatToast();
        globalChatBadge = document.createElement('div');
        globalChatBadge.className = 'chat-unread-badge';
        globalChatBadge.textContent = ' ';
    }
    const target = document.getElementById('globalChatToggle') || globalChatToggle;
    if (!target) return;
    if (globalChatBadge.parentElement !== target) {
        globalChatBadge.remove();
        if (getComputedStyle(target).position === 'static') {
            target.style.position = 'relative';
        }
        target.appendChild(globalChatBadge);
    }
    // Seed empty badge (hidden until count > 0)
    globalChatBadge.style.visibility = 'visible';
    globalChatBadge.style.opacity = '1';
    globalChatBadge.style.transform = 'scale(1)';
    globalChatBadge.style.color = '#fff';
    globalChatBadge.style.fontWeight = '800';
    globalChatBadge.style.fontSize = '12px';
}

  function showChatToast(user, text) {
      ensureChatToast();
      const userEl = chatToastEl.querySelector('.toast-user');
      const textEl = chatToastEl.querySelector('.toast-text');
      userEl.textContent = user ? `${user}:` : 'Message:';
      textEl.textContent = text || '';
      chatToastEl.style.display = 'inline-flex';
      if (chatToastTimer) clearTimeout(chatToastTimer);
      chatToastTimer = setTimeout(() => {
          if (chatToastEl) chatToastEl.style.display = 'none';
      }, 3000);
  }

  function updateChatBadge() {
      ensureChatBadge();
      if (!globalChatBadge) return;
      const count = Number(globalChatUnread || 0);
      const text = count > 0 ? String(count) : ' ';
      globalChatBadge.textContent = text;
      globalChatBadge.style.display = count > 0 ? 'flex' : 'none';
      // Auto-fit big numbers without capping them
      const len = text.trim().length;
      globalChatBadge.style.fontSize = len >= 6 ? '9px' : len >= 4 ? '10px' : '12px';
      globalChatBadge.style.visibility = 'visible';
      globalChatBadge.style.opacity = '1';
      globalChatBadge.style.transform = 'scale(1)';
  }

  function markChatSeen() {
      lastGlobalChatSeenTs = Date.now();
      try {
          localStorage.setItem('globalChatLastSeenTs', String(lastGlobalChatSeenTs));
      } catch (_) {}
      globalChatUnread = 0;
      updateChatBadge();
  }

  // Inline toast for status/errors (so we can hide the status bar)
  let chatNoticeEl = null;
  let chatNoticeTimer = null;
  function ensureChatNotice() {
      if (chatNoticeEl) return;
      chatNoticeEl = document.createElement('div');
      chatNoticeEl.style.position = 'fixed';
      chatNoticeEl.style.top = '16px';
      chatNoticeEl.style.left = '50%';
      chatNoticeEl.style.transform = 'translateX(-50%)';
      chatNoticeEl.style.zIndex = '30000';
      chatNoticeEl.style.padding = '10px 14px';
      chatNoticeEl.style.borderRadius = '12px';
      chatNoticeEl.style.background = 'rgba(15,23,42,0.9)';
      chatNoticeEl.style.border = '1px solid rgba(255,255,255,0.15)';
      chatNoticeEl.style.color = '#e5e7eb';
      chatNoticeEl.style.fontSize = '13px';
      chatNoticeEl.style.fontWeight = '700';
      chatNoticeEl.style.boxShadow = '0 16px 40px rgba(0,0,0,0.35)';
      chatNoticeEl.style.display = 'none';
      document.body.appendChild(chatNoticeEl);
  }

  function showChatNotice(text, isError = false) {
      if (!text) return;
      ensureChatNotice();
      chatNoticeEl.textContent = text;
      chatNoticeEl.style.background = isError ? 'linear-gradient(135deg, #991b1b, #b91c1c)' : 'linear-gradient(135deg, #0f172a, #1e293b)';
      chatNoticeEl.style.borderColor = isError ? 'rgba(248,113,113,0.9)' : 'rgba(96,165,250,0.6)';
      chatNoticeEl.style.color = '#f8fafc';
      chatNoticeEl.style.boxShadow = isError
        ? '0 18px 44px rgba(127,29,29,0.45)'
        : '0 18px 44px rgba(15,23,42,0.45)';
      chatNoticeEl.style.display = 'block';
      if (chatNoticeTimer) clearTimeout(chatNoticeTimer);
      chatNoticeTimer = setTimeout(() => {
          if (chatNoticeEl) chatNoticeEl.style.display = 'none';
      }, 3200);
  }

  // Custom confirmation dialog that works in sandboxed contexts
  function showChatConfirm(message) {
      return new Promise((resolve) => {
          // Create overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:10000; display:flex; align-items:center; justify-content:center;';
          
          // Create modal
          const modal = document.createElement('div');
          modal.style.cssText = 'background:linear-gradient(135deg, #1e293b, #0f172a); border:1px solid rgba(255,255,255,0.1); border-radius:12px; padding:24px; max-width:400px; width:90%; box-shadow:0 20px 60px rgba(0,0,0,0.5);';
          
          // Message text
          const messageEl = document.createElement('div');
          messageEl.textContent = message;
          messageEl.style.cssText = 'color:#f8fafc; font-size:16px; margin-bottom:24px; text-align:center;';
          modal.appendChild(messageEl);
          
          // Buttons container
          const buttons = document.createElement('div');
          buttons.style.cssText = 'display:flex; gap:12px; justify-content:center;';
          
          // Cancel button
          const cancelBtn = document.createElement('button');
          cancelBtn.textContent = 'Cancel';
          cancelBtn.style.cssText = 'padding:10px 20px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; color:#f8fafc; cursor:pointer; font-size:14px; flex:1;';
          cancelBtn.addEventListener('click', () => {
              document.body.removeChild(overlay);
              resolve(false);
          });
          cancelBtn.addEventListener('mouseenter', () => {
              cancelBtn.style.background = 'rgba(255,255,255,0.15)';
          });
          cancelBtn.addEventListener('mouseleave', () => {
              cancelBtn.style.background = 'rgba(255,255,255,0.1)';
          });
          
          // Confirm button
          const confirmBtn = document.createElement('button');
          confirmBtn.textContent = 'Delete';
          confirmBtn.style.cssText = 'padding:10px 20px; background:linear-gradient(135deg, #dc2626, #b91c1c); border:none; border-radius:8px; color:#ffffff; cursor:pointer; font-size:14px; font-weight:600; flex:1;';
          confirmBtn.addEventListener('click', () => {
              document.body.removeChild(overlay);
              resolve(true);
          });
          confirmBtn.addEventListener('mouseenter', () => {
              confirmBtn.style.background = 'linear-gradient(135deg, #b91c1c, #991b1b)';
          });
          confirmBtn.addEventListener('mouseleave', () => {
              confirmBtn.style.background = 'linear-gradient(135deg, #dc2626, #b91c1c)';
          });
          
          buttons.appendChild(cancelBtn);
          buttons.appendChild(confirmBtn);
          modal.appendChild(buttons);
          
          overlay.appendChild(modal);
          document.body.appendChild(overlay);
          
          // Close on overlay click (outside modal)
          overlay.addEventListener('click', (e) => {
              if (e.target === overlay) {
                  document.body.removeChild(overlay);
                  resolve(false);
              }
          });
      });
  }

  // Owner reports inbox (local list, populated from incoming report events)
  const VOICE_REPORTS_INBOX_KEY = 'voice_reports_inbox_v1';
  function loadVoiceReportsInbox() {
      try {
          const raw = localStorage.getItem(VOICE_REPORTS_INBOX_KEY);
          const arr = JSON.parse(raw || '[]');
          return Array.isArray(arr) ? arr : [];
      } catch (_) { return []; }
  }
  function saveVoiceReportsInbox(list) {
      try { localStorage.setItem(VOICE_REPORTS_INBOX_KEY, JSON.stringify(Array.isArray(list) ? list : [])); } catch (_) {}
  }
  function addReportToInbox(rep) {
      if (globalChatUsername !== '%Owner%') return;
      const list = loadVoiceReportsInbox();
      list.unshift(rep);
      while (list.length > 50) list.pop();
      saveVoiceReportsInbox(list);
  }

  // Voice report/mod event handlers (messages-table hidden payloads)
  function handleVoiceReportEvent(fromUserId, parsed) {
      if (!parsed || parsed.type !== VOICE_REPORT_TYPE) return;
      if (parsed.room !== VOICE_ROOM_ID) return;
      if (globalChatUsername !== '%Owner%') return;
      const rep = {
          reporterUserId: String(fromUserId || parsed.reporterUserId || ''),
          reportedUserId: String(parsed.reportedUserId || ''),
          reason: String(parsed.reason || ''),
          ts: Number(parsed.ts || Date.now())
      };
      if (!rep.reportedUserId) return;
      addReportToInbox(rep);
      showChatNotice(`New report: ${getDisplayName(rep.reportedUserId)}`, true);
      try {
          if (voiceReportsInboxEl && voiceReportsInboxEl.style.display !== 'none') renderVoiceReportsInbox();
      } catch (_) {}
  }

  function handleVoiceModEvent(fromUserId, parsed) {
      try {
          if (String(fromUserId || '') !== '%Owner%') return;
          if (!parsed || parsed.type !== VOICE_MOD_TYPE) return;
          if (parsed.room !== VOICE_ROOM_ID) return;
          const action = String(parsed.action || '');
          const targetUserId = String(parsed.targetUserId || '');
          if (!action || !targetUserId) return;
          let state = pruneVoiceModState(loadVoiceModState());
          state.bans = state.bans || {};
          state.timeouts = state.timeouts || {};
          if (action === 'ban') state.bans[targetUserId] = true;
          else if (action === 'unban') delete state.bans[targetUserId];
          else if (action === 'timeout') {
              const until = Number(parsed.untilTs || 0);
              if (until && until > Date.now()) state.timeouts[targetUserId] = until;
          } else if (action === 'untimeout') delete state.timeouts[targetUserId];
          state = pruneVoiceModState(state);
          saveVoiceModState(state);

          const me = String(globalChatUsername || '');
          if (me && me === targetUserId) {
              const block = getVoiceBlockReason(me);
              if (block.blocked && typeof leaveVoiceChat === 'function') {
                  try { leaveVoiceChat(); } catch (_) {}
              }
              if (block.blocked) {
                  showChatNotice(block.type === 'ban' ? 'You were banned from voice chat.' : 'You were timed out from voice chat.', true);
              } else {
                  showChatNotice('Voice restriction removed.', false);
              }
          } else {
              // If someone else was banned/timed out, drop active calls to them on this client
              const b = getVoiceBlockReason(targetUserId);
              if (b.blocked) {
                  try {
                      voiceParticipants.forEach((info, pid) => {
                          if (String(info?.userId || '') !== targetUserId) return;
                          cleanupVoiceCall(pid);
                      });
                  } catch (_) {}
              }
              try { renderVoiceParticipants(); } catch (_) {}
          }
      } catch (_) {}
  }

  function formatChatTime(ts) {
      try {
          const d = new Date(ts || Date.now());
          return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch (_) {
          return '';
      }
  }

  function getMessageTimestamp(msg) {
      try {
          const raw = msg.created_at || msg.createdAt || msg.timestamp;
          if (!raw) return Date.now();
          return new Date(raw).getTime();
      } catch (_) {
          return Date.now();
      }
  }

  function appendGlobalChatMessage(msg) {
      if (!globalChatBox || !msg) return;
      const key = msg.id ? `id:${msg.id}` : `temp:${msg.user_id || ''}:${msg.content || ''}:${msg.created_at || ''}`;
      if (globalChatSeen.has(key)) return;
      globalChatSeen.add(key);
      let displayText = msg.content || '';
      let stateText = '';
      const parsed = parseChatContentJson(msg.content);
      if (parsed) {
          // Hide legacy moderation/ban event payloads (they are not user chat messages)
          if (parsed.type === 'ban') return;
          // Voice reports/mod events should not render in chat
          if (parsed.type === VOICE_REPORT_TYPE) {
              handleVoiceReportEvent(msg.user_id || '', parsed);
              return;
          }
          if (parsed.type === VOICE_MOD_TYPE) {
              handleVoiceModEvent(msg.user_id || '', parsed);
              return;
          }
          if (typeof parsed.text === 'string') displayText = parsed.text;
          if (typeof parsed.state === 'string') stateText = parsed.state;
      }
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'flex-start';
      row.style.alignItems = 'flex-start';
      row.style.userSelect = 'text';
      row.style.webkitUserSelect = 'text';
      row.style.MozUserSelect = 'text';
      // Add golden ring for %Owner% messages
      const isOwner = (msg.user_id === '%Owner%');
      if (isOwner) {
          row.style.border = '2px solid #FFD700';
          row.style.borderRadius = '12px';
          row.style.padding = '8px';
          row.style.marginBottom = '8px';
          row.style.boxShadow = '0 0 0 2px rgba(255, 215, 0, 0.3), 0 0 10px rgba(255, 215, 0, 0.2)';
          row.style.background = 'rgba(255, 215, 0, 0.05)';
      }
      const bubble = document.createElement('div');
      const isMine = (msg.user_id || '') === globalChatUsername;
      // Always scroll to bottom for new messages if chat is open and user is near bottom
      // This ensures messages from others appear immediately when user is viewing the chat
      const shouldStick = globalChatIsOpen && (isChatNearBottom(200) || isMine);
      if (isMine && customMyBubbleColor) {
          const personal = buildPersonalBubbleStyle();
          bubble.style.background = personal.bg;
          bubble.style.border = `1px solid ${personal.border}`;
          bubble.style.boxShadow = personal.shadow;
      } else {
          bubble.style.background = currentBubbleStyle.bubbleBg;
          bubble.style.border = `1px solid ${currentBubbleStyle.bubbleBorder}`;
          bubble.style.boxShadow = currentBubbleStyle.bubbleShadow || '0 8px 22px rgba(0,0,0,0.25)';
      }
      bubble.style.borderRadius = '16px';
      bubble.style.padding = '12px 14px';
      bubble.style.backdropFilter = 'blur(6px)';
      bubble.style.transition = 'transform 0.15s ease';
      bubble.style.width = '100%';
      bubble.style.userSelect = 'text';
      bubble.style.webkitUserSelect = 'text';
      bubble.style.MozUserSelect = 'text';
      bubble.dataset.msgId = msg.id || '';
      if (stateText) {
          const stateLine = document.createElement('div');
          stateLine.textContent = stateText;
          stateLine.style.fontSize = '11px';
          stateLine.style.color = 'rgba(255,255,255,0.55)';
          stateLine.style.marginBottom = '2px';
          bubble.appendChild(stateLine);
      }
      const user = document.createElement('strong');
      const userName = msg.user_id || 'User';
      const displayName = getDisplayName(userName);
      user.textContent = `${displayName}: `;
      const text = document.createElement('span');
      text.textContent = displayText;
      const time = document.createElement('span');
      time.textContent = formatChatTime(msg.created_at || msg.createdAt || msg.timestamp || Date.now());
      time.style.fontSize = '11px';
      time.style.color = 'rgba(255,255,255,0.55)';
      time.style.marginLeft = '8px';

      bubble.appendChild(user);
      bubble.appendChild(text);
      bubble.appendChild(time);

      // Show lightweight toast in upper-left for any new message
      const toastSnippet = (displayText || '').slice(0, 80);
      const msgTime = getMessageTimestamp(msg);
      lastSupabaseChatTs = Math.max(lastSupabaseChatTs, msgTime);
      // Update local cache when new message arrives
      updateChatCache(msg);
      const isRecent = Date.now() - msgTime < 5 * 60 * 1000; // 5 minutes freshness window
      if (!suppressChatToast && isRecent) {
          showChatToast(displayName, toastSnippet);
      }

      // Increment unread count for new incoming messages when chat is closed
      // ONLY count messages that are newer than the last seen timestamp
      if (!globalChatIsOpen && chatHistoryBootstrapped && !isMine) {
          // Only increment if this message is newer than when we last saw the chat
          if (msgTime > lastGlobalChatSeenTs) {
              globalChatUnread += 1;
              updateChatBadge();
          }
      } else if (globalChatIsOpen) {
          // If chat is open, treat this message as seen
          lastGlobalChatSeenTs = Math.max(lastGlobalChatSeenTs, msgTime);
          try {
              localStorage.setItem('globalChatLastSeenTs', String(lastGlobalChatSeenTs));
          } catch (_) {}
      }

      const actionsRow = document.createElement('div');
      actionsRow.style.display = 'flex';
      actionsRow.style.alignItems = 'center';
      actionsRow.style.justifyContent = 'space-between';
      actionsRow.style.marginTop = '8px';

      // Reactions bar
      const reactBar = document.createElement('div');
      reactBar.style.display = 'flex';
      reactBar.style.alignItems = 'center';
      reactBar.style.gap = '8px';
      reactBar.style.marginTop = '8px';
      reactBar.style.position = 'relative';
      const reactBtn = document.createElement('button');
      reactBtn.innerHTML = '<span style="font-size:14px;">😊+</span>';
      reactBtn.style.border = 'none';
      reactBtn.style.borderRadius = '8px';
      reactBtn.style.padding = '6px 8px';
      reactBtn.style.background = 'rgba(255,255,255,0.1)';
      reactBtn.style.color = '#fff';
      reactBtn.style.cursor = 'pointer';
      reactBtn.style.minWidth = '32px';
      const reactList = document.createElement('div');
      reactList.style.display = 'flex';
      reactList.style.gap = '6px';
      reactList.style.flexWrap = 'wrap';
      const reactPicker = document.createElement('div');
      reactPicker.className = 'react-picker';
      reactPicker.style.display = 'none';
      reactPicker.style.position = 'absolute';
      reactPicker.style.top = '36px';
      reactPicker.style.left = '0';
      reactPicker.style.background = 'rgba(20,20,30,0.95)';
      reactPicker.style.border = '1px solid rgba(255,255,255,0.1)';
      reactPicker.style.borderRadius = '10px';
      reactPicker.style.padding = '8px';
      reactPicker.style.boxShadow = '0 10px 25px rgba(0,0,0,0.4)';
      reactPicker.style.zIndex = '20';
      reactPicker.style.width = '280px';
      reactPicker.style.maxHeight = '260px';
      reactPicker.style.overflowY = 'auto';
      reactPicker.style.display = 'none';
      reactPicker.style.gridTemplateColumns = 'repeat(7, 1fr)';
      reactPicker.style.gap = '4px';
      COMMON_EMOJIS.forEach(em => {
          const btn = document.createElement('button');
          btn.textContent = em;
          btn.style.border = 'none';
          btn.style.background = 'transparent';
          btn.style.fontSize = '16px';
          btn.style.cursor = 'pointer';
          btn.style.padding = '4px';
          btn.addEventListener('click', () => {
              addReaction(msg.id, em);
              renderReactions(msg.id, reactList);
              reactPicker.style.display = 'none';
      });
      reactPicker.appendChild(btn);
      });
      reactBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          if (reactPicker.style.display === 'grid') {
              reactPicker.style.display = 'none';
              return;
          }
          await loadEmojiPicker(reactPicker, (em) => {
              addReaction(msg.id, em);
              renderReactions(msg.id, reactList);
              reactPicker.style.display = 'none';
          });
          reactPicker.style.display = 'grid';
      });
      reactBar.appendChild(reactBtn);
      reactBar.appendChild(reactList);
      reactionListNodes.set(msg.id, reactList);
      actionsRow.appendChild(reactBar);

      // Delete button for own messages
      if (isMine && msg.id) {
          const delBtn = document.createElement('button');
          delBtn.innerHTML = '<i class="fas fa-trash"></i>';
          delBtn.style.border = 'none';
          delBtn.style.borderRadius = '8px';
          delBtn.style.padding = '6px 8px';
          delBtn.style.background = 'rgba(255,255,255,0.08)';
          delBtn.style.color = '#f87171';
          delBtn.style.cursor = 'pointer';
          delBtn.addEventListener('click', async (e) => {
              e.stopPropagation();
              const confirmed = await showChatConfirm('Delete this message?');
              if (!confirmed) return;
              
              // Send delete request to Worker WebSocket
              if (chatWorkerWs && chatWorkerWs.readyState === WebSocket.OPEN) {
                  try {
                      chatWorkerWs.send(JSON.stringify({
                          type: 'delete',
                          id: msg.id
                      }));
                      // Optimistically remove from UI
                      removeMessageById(msg.id);
                      setGlobalChatStatus('Message deleted', false);
                  } catch (err) {
                      console.error('Delete failed', err);
                      setGlobalChatStatus('Delete failed.', true);
                  }
              } else {
                  setGlobalChatStatus('Not connected to chat server.', true);
              }
          });
          actionsRow.appendChild(delBtn);
      }

      bubble.appendChild(actionsRow);
      bubble.appendChild(reactPicker);

      row.appendChild(bubble);
      
      // Store timestamp in row for ordering
      row.dataset.timestamp = String(msgTime);
      
      // Insert message in chronological order instead of just appending
      const children = Array.from(globalChatBox.children);
      
      // If no messages exist, just append
      if (children.length === 0) {
          globalChatBox.appendChild(row);
      } else {
          // Find the correct position by comparing timestamps
          let insertIndex = children.length;
          for (let i = 0; i < children.length; i++) {
              const childTimestamp = parseFloat(children[i].dataset.timestamp || '0');
              if (msgTime < childTimestamp) {
                  insertIndex = i;
                  break;
              }
          }
          
          // Insert at the correct position
          if (insertIndex === children.length) {
              globalChatBox.appendChild(row);
          } else {
              globalChatBox.insertBefore(row, children[insertIndex]);
          }
      }
      
      // Scroll to bottom for new messages (especially from others)
      if (shouldStick) {
          scrollGlobalChatToBottom();
          // Also scroll after a brief delay to ensure DOM is updated
          setTimeout(() => {
              if (globalChatIsOpen && isChatNearBottom(200)) {
                  scrollGlobalChatToBottom();
              }
          }, 50);
      }
      if (msg.id) {
          messageNodeIndex.set(msg.id, row);
      }

      // Render existing reactions for this message
      renderReactions(msg.id, reactList);
  }

  function renderReactions(id, container) {
      if (!container) return;
      container.innerHTML = '';
      const list = reactionsById[id] || [];
      const counts = {};
      list.forEach(em => { counts[em] = (counts[em] || 0) + 1; });
      Object.entries(counts).forEach(([em, count]) => {
          const chip = document.createElement('span');
          chip.textContent = count > 1 ? `${em} ${count}` : em;
          chip.style.padding = '4px 6px';
          chip.style.borderRadius = '8px';
          chip.style.background = 'rgba(255,255,255,0.08)';
          container.appendChild(chip);
      });
  }

  async function addReaction(id, emoji) {
      if (!id) return;
      // TODO: Send reaction to Worker WebSocket when Worker supports reactions
      // For now, just optimistic local update
      if (!reactionsById[id]) reactionsById[id] = [];
      reactionsById[id].push(emoji);
      const node = reactionListNodes.get(id);
      if (node) renderReactions(id, node);
      console.log('Reaction added locally (Worker reaction support coming soon)');
  }

  function removeMessageById(id) {
      const node = messageNodeIndex.get(id);
      if (node && node.parentNode) {
          node.parentNode.removeChild(node);
      }
      messageNodeIndex.delete(id);
      delete reactionsById[id];
      reactionListNodes.delete(id);
      globalChatSeen.delete(`id:${id}`);
  }

  function isChatNearBottom(threshold = 140) {
      if (!globalChatBox) return true;
      const gap = globalChatBox.scrollHeight - (globalChatBox.scrollTop + globalChatBox.clientHeight);
      return gap <= threshold;
  }

  function scrollGlobalChatToBottom() {
      if (!globalChatBox) return;
      globalChatBox.style.userSelect = 'text';
      globalChatBox.style.webkitUserSelect = 'text';
      globalChatBox.style.MozUserSelect = 'text';
      requestAnimationFrame(() => {
          if (!globalChatBox) return;
          globalChatBox.scrollTop = globalChatBox.scrollHeight;
      });
      setTimeout(() => {
          if (!globalChatBox) return;
          globalChatBox.scrollTop = globalChatBox.scrollHeight;
      }, 75);
  }

  function setGlobalChatStatus(text, isError = false) {
      if (globalChatStatus) {
          // Hide the bar to avoid covering typing indicator; keep text for accessibility if needed
      globalChatStatus.textContent = text || '';
          globalChatStatus.style.display = 'none';
      }
      if (text) {
          showChatNotice(text, isError);
      }
  }

  function updateTypingIndicator() {
      if (!globalChatTypingEl) return;
      const now = Date.now();
      // prune stale (older than 8s)
      typingUsers.forEach((ts, user) => {
          if (now - ts > 8000) typingUsers.delete(user);
      });
      const ordered = Array.from(typingUsers.entries())
          .sort((a, b) => a[1] - b[1]) // earliest start first
          .map(([user]) => user)
          .filter(Boolean);
      if (ordered.length === 0) {
          globalChatTypingEl.textContent = '';
      } else if (ordered.length > 3) {
          globalChatTypingEl.textContent = 'Several people are typing…';
      } else {
          const list = ordered.join(', ');
          globalChatTypingEl.textContent = `${list} ${ordered.length === 1 ? 'is' : 'are'} typing…`;
      }
  }

  // Typing indicators removed - no longer using Supabase typing table
  // Local typingUsers Map is kept for potential future client-side only implementation

  // ================= Hybrid Snapshot Model: Local Cache =================
  // Save messages to local cache for instant loading
  function saveChatCache(messages) {
      try {
          if (!Array.isArray(messages)) return;
          // Keep only the most recent messages
          const recent = messages.slice(-MAX_CACHED_MESSAGES);
          const cacheData = {
              messages: recent,
              timestamp: Date.now(),
              lastMessageTs: recent.length > 0 ? getMessageTimestamp(recent[recent.length - 1]) : 0
          };
          localStorage.setItem(CHAT_CACHE_KEY, JSON.stringify(cacheData));
      } catch (err) {
          console.warn('Failed to save chat cache:', err);
      }
  }

  // Load messages from local cache
  function loadChatCache() {
      try {
          const cached = localStorage.getItem(CHAT_CACHE_KEY);
          if (!cached) return null;
          const data = JSON.parse(cached);
          // Check if cache is still valid (not older than 5 minutes)
          const age = Date.now() - (data.timestamp || 0);
          if (age > CHAT_CACHE_MAX_AGE) {
              localStorage.removeItem(CHAT_CACHE_KEY);
              return null;
          }
          return data.messages || [];
      } catch (err) {
          console.warn('Failed to load chat cache:', err);
          try {
              localStorage.removeItem(CHAT_CACHE_KEY);
          } catch (_) {}
          return null;
      }
  }

  // Update cache when new message arrives
  function updateChatCache(newMessage) {
      try {
          const cached = loadChatCache();
          const messages = cached || [];
          // Add new message and keep only recent ones
          messages.push(newMessage);
          const recent = messages.slice(-MAX_CACHED_MESSAGES);
          saveChatCache(recent);
      } catch (err) {
          console.warn('Failed to update chat cache:', err);
      }
  }

  // Connect to Cloudflare Worker WebSocket for chat
  function connectChatWorker() {
      if (chatWorkerWs && (chatWorkerWs.readyState === WebSocket.CONNECTING || chatWorkerWs.readyState === WebSocket.OPEN)) {
          return; // Already connecting or connected
      }
      
      try {
          chatWorkerWs = new WebSocket(CHAT_WS_URL);
          chatWorkerConnected = false;
          
          chatWorkerWs.onopen = () => {
              chatWorkerConnected = true;
              console.log('✅ Chat Worker WebSocket CONNECTED');
              console.log('📍 URL:', CHAT_WS_URL);
              
              // Request initial snapshot
              chatWorkerWs.send(JSON.stringify({ type: 'getSnapshot' }));
              console.log('📤 Sent snapshot request to Worker');
              
              // Clear reconnect timer
              if (chatWorkerWsReconnectTimer) {
                  clearTimeout(chatWorkerWsReconnectTimer);
                  chatWorkerWsReconnectTimer = null;
              }
              
              // Update status if chat UI is visible
              try {
                  setGlobalChatStatus('Connected to chat server', false);
              } catch (_) {}
          };
          
          chatWorkerWs.onmessage = (event) => {
              try {
                  const data = JSON.parse(event.data);
                  
                  if ((data.type === 'snapshot' || data.type === 'history') && Array.isArray(data.messages)) {
                      // ✅ HARD GUARD: Prevent history from loading twice
                      if (workerHistoryLoaded) return;
                      
                      // Received snapshot or history - update cache and display
                      workerHistoryLoaded = true; // ✅ THIS IS KEY - Worker history is authoritative
                      console.log(`📥 Received ${data.type} from Worker: ${data.messages.length} messages`);
                      console.log('📦 Snapshot sample:', JSON.stringify(data.messages.slice(0, 2), null, 2)); // Log first 2 for debugging
                      
                      // Convert Worker format to our format if needed
                      const convertedMessages = data.messages.map(m => {
                          // If message is in Worker format { id, t, name, text }, convert it
                          if (m.name && m.text && !m.user_id) {
                              return {
                                  id: m.id,
                                  user_id: m.name,
                                  content: JSON.stringify({ text: m.text, state: null }),
                                  created_at: m.t ? new Date(m.t).toISOString() : new Date().toISOString()
                              };
                          }
                          // Already in our format
                          return m;
                      });
                      
                      // Clear existing messages from Supabase fallback if Worker snapshot is available
                      // This ensures Worker messages (authoritative) replace Supabase fallback
                      const chatBox = document.getElementById('globalChatBox');
                      if (chatBox) {
                          // Clear all messages - Worker snapshot/history is authoritative
                          chatBox.innerHTML = '';
                          messageNodeIndex.clear(); // Clear message index
                          globalChatSeen.clear(); // Clear seen set so messages can be re-rendered
                          console.log('🧹 Cleared Supabase fallback messages - replacing with Worker ' + data.type);
                      }
                      
                      let newCount = 0;
                      convertedMessages.forEach(m => {
                          appendGlobalChatMessage(m);
                          lastSupabaseChatTs = Math.max(lastSupabaseChatTs, getMessageTimestamp(m));
                          newCount++;
                      });
                      
                      saveChatCache(convertedMessages);
                      console.log(`✅ Loaded ${newCount} messages from Worker ${data.type} (${convertedMessages.length} total) - REPLACED Supabase fallback`);
                      console.log('✅ Chat Worker is WORKING! Messages loaded successfully.');
                      
                      // Calculate unread count based on lastGlobalChatSeenTs
                      // Only count messages newer than when we last saw the chat
                      const seenCutoff = lastGlobalChatSeenTs || 0;
                      let unreadCount = 0;
                      if (seenCutoff > 0) {
                          unreadCount = convertedMessages.reduce((acc, m) => {
                              const ts = getMessageTimestamp(m);
                              const isMine = (m.user_id || '') === globalChatUsername;
                              return acc + (!isMine && ts > seenCutoff ? 1 : 0);
                          }, 0);
                      }
                      
                      // Update unread badge only if chat is closed
                      if (!globalChatIsOpen) {
                          globalChatUnread = unreadCount;
                          updateChatBadge();
                          console.log(`📊 Calculated ${unreadCount} unread messages (seen cutoff: ${new Date(seenCutoff).toISOString()})`);
                      } else {
                          // Chat is open, mark as seen
                          markChatSeen();
                      }
                      
                      // ✅ REQUIRED: Enable notifications and badge after history is loaded
                      chatHistoryBootstrapped = true;
                      suppressChatToast = false; // ✅ Enable toasts immediately (no setTimeout needed)
                  } else if (data.type === 'message' || data.type === 'chat') {
                      // New message received from Worker
                      console.log('📦 Raw Worker message data:', JSON.stringify(data, null, 2));
                      
                      let message = null;
                      
                      // Handle different Worker response formats
                      if (data.message) {
                          // Worker sent: { type: 'chat', message: { id, t, name, text } }
                          const msg = data.message;
                          message = {
                              id: msg.id || `worker_${Date.now()}_${Math.random()}`,
                              user_id: msg.name || msg.user_id || 'User',
                              content: JSON.stringify({ 
                                  text: msg.text || '', 
                                  state: null 
                              }),
                              created_at: msg.t ? new Date(msg.t).toISOString() : 
                                         msg.created_at || new Date().toISOString()
                          };
                      } else if (data.name || data.user_id) {
                          // Worker sent: { type: 'chat', name: '...', text: '...' }
                          message = {
                              id: data.id || `worker_${Date.now()}_${Math.random()}`,
                              user_id: data.name || data.user_id || 'User',
                              content: JSON.stringify({ 
                                  text: data.text || '', 
                                  state: data.state || null 
                              }),
                              created_at: data.timestamp ? new Date(data.timestamp).toISOString() : 
                                         data.t ? new Date(data.t).toISOString() :
                                         data.created_at || new Date().toISOString()
                          };
                      }
                      
                      if (message && message.user_id && message.content) {
                          // Skip if message is empty
                          try {
                              const contentObj = JSON.parse(message.content);
                              if (!contentObj.text || contentObj.text.trim() === '') {
                                  console.warn('⚠️ Skipping empty message from Worker');
                                  return;
                              }
                          } catch (_) {
                              // If content is not JSON, check if it's a plain string
                              if (!message.content || message.content.trim() === '') {
                                  console.warn('⚠️ Skipping empty message from Worker');
                                  return;
                              }
                          }
                          
                          console.log('📨 Received new message from Worker:', message.user_id);
                          const msgTs = getMessageTimestamp(message);
                          
                          // Check if this is our own message echoing back (optimistic UI replacement)
                          const isMyMessage = (message.user_id || '') === globalChatUsername;
                          let replacedOptimistic = false;
                          
                          if (isMyMessage && message.content && globalChatBox) {
                              try {
                                  const contentObj = JSON.parse(message.content);
                                  const messageText = contentObj.text || '';
                                  
                                  // ✅ IMPROVED: Use tracked optimistic message ID for reliable replacement
                                  if (lastOptimisticTempId && messageText && Math.abs(Date.now() - msgTs) < 5000) {
                                      // Check if we have a tracked optimistic message
                                      const optimisticNode = messageNodeIndex.get(lastOptimisticTempId);
                                      if (optimisticNode && optimisticNode.parentNode) {
                                          // Verify it's still in the DOM and matches our message
                                          const bubble = optimisticNode.querySelector('[data-msg-id]');
                                          if (bubble && bubble.getAttribute('data-msg-id') === lastOptimisticTempId) {
                                              // This is our optimistic message - replace it with real one
                                              console.log('🔄 Removing optimistic message:', lastOptimisticTempId);
                                              removeMessageById(lastOptimisticTempId);
                                              replacedOptimistic = true;
                                              // Note: We'll clear lastOptimisticTempId after cleanup in the replacement block
                                              console.log('🔄 Replaced optimistic message with real Worker message');
                                          } else {
                                              console.log('⚠️ Optimistic message node found but bubble ID mismatch');
                                          }
                                      } else {
                                          console.log('⚠️ Optimistic message node not found in index or DOM:', lastOptimisticTempId);
                                      }
                                  }
                                  
                                  // Fallback: If tracked ID didn't work, try finding by text match (within last 3 seconds)
                                  if (!replacedOptimistic && messageText && Math.abs(Date.now() - msgTs) < 3000) {
                                      const allRows = Array.from(globalChatBox.children);
                                      for (const row of allRows) {
                                          const bubble = row.querySelector('[data-msg-id]');
                                          if (!bubble) continue;
                                          
                                          const tempId = bubble.getAttribute('data-msg-id');
                                          if (tempId && tempId.startsWith('temp_')) {
                                              // Check if text matches - look for the text span (not timestamp)
                                              const userSpan = bubble.querySelector('strong');
                                              const textSpan = userSpan?.nextSibling;
                                              if (textSpan && textSpan.textContent && textSpan.textContent.trim() === messageText.trim()) {
                                                  // This is our optimistic message - replace it with real one
                                                  console.log('🔄 Removing optimistic message (fallback):', tempId);
                                                  removeMessageById(tempId);
                                                  replacedOptimistic = true;
                                                  // Note: We'll handle clearing lastOptimisticTempId in the replacement block
                                                  console.log('🔄 Replaced optimistic message with real Worker message (fallback)');
                                                  break;
                                              }
                                          }
                                      }
                                  }
                              } catch (_) {}
                          }
                          
                          // If we replaced an optimistic message, the DOM was cleared
                          // Now append the real message with the real ID
                          if (replacedOptimistic) {
                              // ✅ Save temp ID before clearing it (needed for cleanup)
                              const tempIdToClean = lastOptimisticTempId;
                              lastOptimisticTempId = null; // Clear after we've saved it
                              
                              // Clean up ALL possible temp keys from seen set
                              // The optimistic message was added with key: id:${tempId}
                              if (tempIdToClean) {
                                  const tempKeyToRemove = `id:${tempIdToClean}`;
                                  globalChatSeen.delete(tempKeyToRemove);
                                  console.log('🧹 Cleaned up temp key from seen set:', tempKeyToRemove);
                              }
                              
                              // Also try the alternative temp key format (in case it was added differently)
                              const altTempKey = `temp:${message.user_id || ''}:${message.content || ''}:${message.created_at || ''}`;
                              globalChatSeen.delete(altTempKey);
                              
                              // Clean up any temp keys that might exist (comprehensive cleanup)
                              // Iterate through seen set and remove any temp keys for this user/content
                              const keysToRemove = [];
                              globalChatSeen.forEach(key => {
                                  if (key.startsWith('id:temp_') || (key.startsWith('temp:') && key.includes(message.user_id || ''))) {
                                      keysToRemove.push(key);
                                  }
                              });
                              keysToRemove.forEach(key => globalChatSeen.delete(key));
                              if (keysToRemove.length > 0) {
                                  console.log('🧹 Cleaned up additional temp keys:', keysToRemove);
                              }
                              
                              // ✅ IMPORTANT: Don't add real key to seen set yet - let appendGlobalChatMessage do it
                              // This ensures the message actually gets rendered
                              
                              console.log('✅ Adding real message to chat, ID:', message.id);
                              // Append the real message (it will add itself to globalChatSeen)
                              appendGlobalChatMessage(message);
                              lastSupabaseChatTs = Math.max(lastSupabaseChatTs, msgTs);
                              updateChatCache(message);
                              // ✅ Increment message counter for confirmed message (replacing optimistic)
                              incrementMessageCounter();
                          } else if (!chatHistoryBootstrapped || msgTs > lastSupabaseChatTs) {
                              // Normal message (not replacing optimistic)
                              appendGlobalChatMessage(message);
                              lastSupabaseChatTs = Math.max(lastSupabaseChatTs, msgTs);
                              
                              // Update cache with new message
                              updateChatCache(message);
                              // ✅ Increment message counter for confirmed message
                              incrementMessageCounter();
                          }
                      } else {
                          console.warn('⚠️ Received invalid message from Worker (missing user_id or content):', JSON.stringify(data, null, 2));
                      }
                  } else {
                      console.log('📦 Received data from Worker:', data.type, data);
                  }
              } catch (err) {
                  console.warn('Chat Worker message parse error:', err);
              }
          };
          
          chatWorkerWs.onerror = (error) => {
              console.error('❌ Chat Worker WebSocket ERROR:', error);
              chatWorkerConnected = false;
              try {
                  setGlobalChatStatus('Connection error - retrying...', true);
              } catch (_) {}
          };
          
          chatWorkerWs.onclose = (event) => {
              chatWorkerConnected = false;
              console.warn('⚠️ Chat Worker WebSocket CLOSED');
              console.warn('   Code:', event.code, 'Reason:', event.reason || 'none');
              console.warn('   Reconnecting in 3s...');
              
              try {
                  setGlobalChatStatus('Disconnected - reconnecting...', true);
              } catch (_) {}
              
              // Reconnect after delay
              if (chatWorkerWsReconnectTimer) {
                  clearTimeout(chatWorkerWsReconnectTimer);
              }
              chatWorkerWsReconnectTimer = setTimeout(() => {
                  console.log('🔄 Attempting to reconnect to Chat Worker...');
                  connectChatWorker();
              }, 3000);
          };
      } catch (err) {
          console.error('❌ Failed to connect to Chat Worker:', err);
          chatWorkerConnected = false;
          try {
              setGlobalChatStatus('Failed to connect - using fallback', true);
          } catch (_) {}
      }
  }
  
  // Debug function to check Chat Worker status
  function checkChatWorkerStatus() {
      console.log('🔍 Chat Worker Status Check:');
      console.log('   URL:', CHAT_WS_URL);
      console.log('   Connected:', chatWorkerConnected);
      console.log('   WebSocket State:', chatWorkerWs ? 
          (chatWorkerWs.readyState === WebSocket.CONNECTING ? 'CONNECTING' :
           chatWorkerWs.readyState === WebSocket.OPEN ? 'OPEN ✅' :
           chatWorkerWs.readyState === WebSocket.CLOSING ? 'CLOSING' :
           chatWorkerWs.readyState === WebSocket.CLOSED ? 'CLOSED ❌' : 'UNKNOWN') : 'NULL');
      console.log('   Reconnect Timer:', chatWorkerWsReconnectTimer ? 'Active' : 'None');
      
      if (chatWorkerWs && chatWorkerWs.readyState === WebSocket.OPEN) {
          console.log('✅ Chat Worker is WORKING!');
      } else {
          console.log('❌ Chat Worker is NOT connected');
          console.log('   Attempting to reconnect...');
          connectChatWorker();
      }
      
      return {
          connected: chatWorkerConnected,
          wsState: chatWorkerWs?.readyState,
          url: CHAT_WS_URL
      };
  }
  
  // Make it available globally for debugging
  window.checkChatWorkerStatus = checkChatWorkerStatus;

  // Request server snapshot from Cloudflare Worker (no Supabase cost)
  // NOTE: Snapshot is requested via WebSocket (connectChatWorker sends 'getSnapshot' on connect)
  // This HTTP fallback is optional and may have CORS issues - WebSocket is primary method
  async function requestServerSnapshot() {
      try {
          // WebSocket is the primary method (handled in connectChatWorker)
          // HTTP endpoint may have CORS restrictions, so we skip it
          // The WebSocket will send snapshot automatically on connect
          
          // Fallback: Try backend API if available
          if (backendApi && backendApi.connected) {
              const response = await backendApi.request('/chat/snapshot', { method: 'GET' });
              if (response && Array.isArray(response.messages)) {
                  return response.messages;
              }
          }
      } catch (err) {
          console.debug('Server snapshot not available:', err.message);
      }
      return null;
  }

  // Cleanup is now handled by Worker - no client-side cleanup needed

  function syncGlobalChatNameInput() {
      if (globalChatNameInput) {
          globalChatNameInput.value = globalChatUsername;
      }
      if (globalChatLocationValue) {
          globalChatLocationValue.textContent = 'Not available';
      }
  }
  syncGlobalChatNameInput();

  let globalChatStateLookupInFlight = false;
  async function fetchIpFallbackLocation() {
      try {
          const res = await fetch('https://ipapi.co/json/');
          if (!res.ok) throw new Error('ip api fail');
          const data = await res.json();
          return data.region || data.city || data.country_name || '';
      } catch (err) {
          console.warn('IP fallback location failed', err);
          return '';
      }
  }

  async function autoDetectState() {
      // ✅ Location detection disabled - do nothing
      return;
  }

  async function saveGlobalChatName() {
      const val = (globalChatNameInput?.value || '').trim();
      if (!isValidChatName(val)) {
          setGlobalChatStatus('Please choose a name (3+ chars, not default User###).', true);
          showChatNotice('Please enter a proper display name (3+ characters, not the default).', true);
          return;
      }
      if (isNameBlocked(val)) {
          setGlobalChatStatus('Display name blocked for inappropriate content. Choose another.', true);
          showChatNotice('Display name blocked for inappropriate content. Choose another.', true);
          return;
      }
      // Check for reserved names (but allow %Owner% as special case)
      if (val !== '%Owner%' && containsReservedName(val)) {
          setGlobalChatStatus('You cannot use "Owner", "Admin", "Mod", or similar words in your name.', true);
          showChatNotice('You cannot use "Owner", "Admin", "Mod", or similar words in your name.', true);
          return;
      }
      // Special check for %Owner% - always check if it's taken (only one person can be Owner)
      if (val === '%Owner%') {
          const isTaken = await isUsernameTaken('%Owner%');
          if (isTaken && val !== globalChatUsername) {
              setGlobalChatStatus('The name "%Owner%" is already in use by another user. Please choose another name.', true);
              showChatNotice('The name "%Owner%" is already in use by another user. Please choose another name.', true);
              return;
          }
      }
      // Check if username is already taken (unless it's the current user's name)
      if (val !== globalChatUsername) {
          const isTaken = await isUsernameTaken(val);
          if (isTaken) {
              setGlobalChatStatus('This username is already taken. Please choose another name.', true);
              showChatNotice('This username is already taken. Please choose another name.', true);
              return;
          }
      }
      globalChatUsername = val;
      localStorage.setItem('globalChatUsername', globalChatUsername);
      setGlobalChatStatus('Name saved.');
      // Owner-only UI (Reports inbox)
      try { updateOwnerReportsButtonVisibility(); } catch (_) {}
  }
  globalChatNameSave?.addEventListener('click', saveGlobalChatName);
  globalChatNameInput?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
          e.preventDefault();
          saveGlobalChatName();
      }
  });
  globalChatThemeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
          const theme = btn.getAttribute('data-theme');
          applyChatTheme(theme);
      });
  });
  if (globalChatMyBubbleColorInput && customMyBubbleColor) {
      globalChatMyBubbleColorInput.value = customMyBubbleColor;
  }
  globalChatMyBubbleColorInput?.addEventListener('input', () => {
      customMyBubbleColor = globalChatMyBubbleColorInput.value;
      localStorage.setItem('globalChatMyBubbleColor', customMyBubbleColor);
      applyChatTheme(activeChatTheme);
  });
  function insertEmoji(em) {
      if (!globalChatInput) return;
      const start = globalChatInput.selectionStart || globalChatInput.value.length;
      const end = globalChatInput.selectionEnd || start;
      const current = globalChatInput.value;
      globalChatInput.value = current.slice(0, start) + em + current.slice(end);
      globalChatInput.focus();
      const caret = start + em.length;
      globalChatInput.setSelectionRange(caret, caret);
      if (globalChatEmojiPicker) globalChatEmojiPicker.style.display = 'none';
  }

  globalChatEmojiBtn?.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (!globalChatEmojiPicker) return;
      if (globalChatEmojiPicker.style.display === 'grid') {
          globalChatEmojiPicker.style.display = 'none';
          return;
      }
      await loadEmojiPicker(globalChatEmojiPicker, insertEmoji);
      globalChatEmojiPicker.style.display = 'grid';
  });
  // Typing state listeners removed - no longer using Supabase typing table

  async function ensureSupabaseScript() {
      // Check if we already have a Supabase client instance (not just the library)
      if (window.supabase && typeof window.supabase.channel === 'function') {
          return window.supabase;
      }
      // Check if we have the library and need to create a client
      if (window.supabase && typeof window.supabase.createClient === 'function') {
          // Library is loaded but no client created - this shouldn't happen in current setup
          // Return null to indicate we need proper initialization
          console.warn('Supabase library loaded but no client instance found');
          return null;
      }
      if (supabaseScriptLoadPromise) return supabaseScriptLoadPromise;
      setGlobalChatStatus('Loading chat client...');
      supabaseScriptLoadPromise = new Promise((resolve, reject) => {
          const existing = document.querySelector('script[data-supabase-global]') || document.querySelector('script[src*=\"supabase-js\"]');
          const el = existing || document.createElement('script');
          if (!existing) {
              el.src = 'https://unpkg.com/@supabase/supabase-js';
              el.crossOrigin = 'anonymous';
              el.defer = true;
              el.dataset.supabaseGlobal = 'true';
              document.head.appendChild(el);
          }
          const timeout = setTimeout(() => {
              // Check if it's a client instance (has channel method) or library (has createClient)
              if (window.supabase) {
                  if (typeof window.supabase.channel === 'function') {
                      resolve(window.supabase);
                  } else if (typeof window.supabase.createClient === 'function') {
                      // Library loaded but no client - return null
                      console.warn('Supabase library loaded but no client instance available');
                      resolve(null);
                  } else {
                      reject(new Error('Supabase loaded but invalid format'));
                  }
              } else {
                  reject(new Error('Supabase load timeout'));
              }
          }, 8000);
          el.onload = () => {
              clearTimeout(timeout);
              // Check if it's a client instance or library
              if (window.supabase && typeof window.supabase.channel === 'function') {
                  resolve(window.supabase);
              } else if (window.supabase && typeof window.supabase.createClient === 'function') {
                  console.warn('Supabase library loaded but no client instance available');
                  resolve(null);
              } else {
                  reject(new Error('Supabase loaded but invalid format'));
              }
          };
          el.onerror = () => {
              clearTimeout(timeout);
              reject(new Error('Supabase script failed to load'));
          };
      }).catch((err) => {
          console.warn('Supabase script load failed:', err);
          setGlobalChatStatus('Supabase client failed to load.', true);
          return null;
      });
      return supabaseScriptLoadPromise;
  }

  // Cleanup is now handled by Worker - no client-side cleanup needed

  async function initGlobalChatClient() {
    // Worker-only chat system - no Supabase
    try {
        suppressChatToast = true;
        
        // Step 1: Load from local cache (instant) - ONLY if Worker history hasn't loaded yet
        // Once Worker history has loaded, it's the single source of truth and cache should not be loaded again
        let loadedMessages = null;
        if (!workerHistoryLoaded) {
            const cachedMessages = loadChatCache();
            if (cachedMessages && cachedMessages.length > 0) {
                cachedMessages.forEach(m => {
                    appendGlobalChatMessage(m);
                    lastSupabaseChatTs = Math.max(lastSupabaseChatTs, getMessageTimestamp(m));
                });
                console.log(`Loaded ${cachedMessages.length} messages from cache`);
                loadedMessages = cachedMessages;
            }
        } else {
            console.log('⏭️ Skipping cache load - Worker history already loaded (single source of truth)');
        }
        
        // Step 2: Connect to Cloudflare Worker WebSocket and request snapshot
        connectChatWorker();
        
        // Step 3: Also try HTTP snapshot endpoint as fallback - ONLY if Worker history hasn't loaded
        // Once Worker history has loaded via WebSocket, it's the authoritative source
        if (!workerHistoryLoaded) {
            const serverMessages = await requestServerSnapshot();
            
            if (serverMessages && serverMessages.length > 0) {
                // Clear existing messages and replace with server snapshot
                const existingIds = new Set();
                document.querySelectorAll('[data-message-id]').forEach(el => {
                    const id = el.getAttribute('data-message-id');
                    if (id) existingIds.add(id);
                });
                
                // Only add messages not already rendered
                serverMessages.forEach(m => {
                    if (!existingIds.has(m.id)) {
                        appendGlobalChatMessage(m);
                        lastSupabaseChatTs = Math.max(lastSupabaseChatTs, getMessageTimestamp(m));
                    }
                });
                
                // Update cache with authoritative server data
                saveChatCache(serverMessages);
                console.log(`Loaded ${serverMessages.length} messages from server snapshot`);
                loadedMessages = serverMessages; // Server snapshot takes precedence over cache
            }
        } else {
            console.log('⏭️ Skipping HTTP snapshot - Worker history already loaded via WebSocket');
        }
        
        // Don't re-enable toasts yet - wait for Worker history to load first
        // suppressChatToast will be set to false after Worker history arrives or after a timeout
        
        // Check for users with reserved names and compute unread count
        // Only do this if we actually loaded messages (not if Worker history already loaded)
        // Worker history handler will handle this separately when it loads
        if (!workerHistoryLoaded && loadedMessages) {
            // Check for reserved names
            const uniqueUsers = new Set(loadedMessages.map(m => m.user_id).filter(Boolean));
            uniqueUsers.forEach(userId => {
                if (userId !== '%Owner%' && containsReservedName(userId)) {
                    // If this is the current user, notify them
                    if (userId === globalChatUsername) {
                        setGlobalChatStatus('Your name contains reserved words. Please change it to continue chatting.', true);
                        showChatNotice('Your name contains "Owner", "Admin", "Mod", or similar words. Please change it.', true);
                    }
                }
            });
            
            // Compute unread since last seen from loaded messages
            const seenCutoff = lastGlobalChatSeenTs || 0;
            let unreadCount = 0;
            if (seenCutoff > 0) {
                unreadCount = loadedMessages.reduce((acc, m) => {
                    const ts = getMessageTimestamp(m);
                    const isMine = (m.user_id || '') === globalChatUsername;
                    return acc + (!isMine && ts > seenCutoff ? 1 : 0);
                }, 0);
            }
            
            if (!globalChatIsOpen) {
                globalChatUnread = unreadCount;
                updateChatBadge();
            } else {
                markChatSeen();
            }
        }
        
        // Only set flags if Worker history hasn't loaded yet (Worker handler will set them)
        if (!workerHistoryLoaded) {
            chatHistoryBootstrapped = true;
            suppressChatToast = false;
        }
        
        // Reactions are now local-only (Worker reaction support coming soon)
        reactionListNodes.forEach((node, msgId) => renderReactions(msgId, node));
        
        // Voice discovery (if enabled)
        if (VOICE_DISCOVERY_ENABLED) {
            try { ensureVoiceDiscoveryObserver(); } catch (_) {}
        }
        
    } catch (err) {
        console.error('Failed to load chat history:', err);
        setGlobalChatStatus('Failed to load chat history.', true);
        // Only set flags if Worker history hasn't loaded yet
        if (!workerHistoryLoaded) {
            suppressChatToast = false;
            chatHistoryBootstrapped = true;
        }
    }
    
    // Fallback: If Worker history hasn't loaded after 3 seconds, enable toasts anyway
    // This prevents toasts from being permanently disabled if Worker is slow
    setTimeout(() => {
        if (!workerHistoryLoaded) {
            if (suppressChatToast) {
                suppressChatToast = false;
            }
            if (!chatHistoryBootstrapped) {
                chatHistoryBootstrapped = true;
            }
        }
    }, 3000);
    
    return true; // Return success indicator (no client object needed)
}

  function ensureChatRealtime() {
      // Worker-only system: Connect to Cloudflare Worker WebSocket
      connectChatWorker();
  }

  // -------- Chat moderation --------
  function normalizeChatText(raw) {
      if (!raw) return '';
      const map = {
          '@': 'a', '4': 'a',
          '3': 'e',
          '1': 'i', '!': 'i', 'l': 'i', '|': 'i',
          '0': 'o',
          '$': 's', '5': 's',
          '7': 't', '+': 't',
          '2': 'z',
          '8': 'b',
          '9': 'g'
      };
      const lowered = raw.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      let out = '';
      for (const ch of lowered) {
          if (map[ch]) {
              out += map[ch];
          } else if (/[a-z]/.test(ch)) {
              out += ch;
          }
      }
      // Drop whitespace/punctuation to catch split-up abuse
      out = out.replace(/[^a-z]/g, '');
      // Collapse repeats to catch obfuscation like nniiiggg
      out = out.replace(/(.)\1{1,}/g, '$1$1');
      return out;
  }

  function stripVowels(text) {
      return text.replace(/[aeiouy]/g, '');
  }

  async function moderateWithAI(text) {
      try {
          const resp = await fetch(AI_MODERATE_ENDPOINT, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text })
          });
          if (!resp.ok) {
              if (resp.status === 429) {
                  return { ok: false, error: 'rate_limited' };
              }
              return { ok: false, error: 'moderation_failed' };
          }
          const data = await resp.json();
          return { ok: true, flagged: !!data.flagged };
      } catch (err) {
          console.warn('AI moderation request failed', err);
          return { ok: false, error: 'network' };
      }
  }

  function setChatSendingUi(isSending) {
      if (globalChatSendBtn) {
          globalChatSendBtn.disabled = isSending;
          globalChatSendBtn.style.opacity = isSending ? '0.65' : '1';
          globalChatSendBtn.style.cursor = isSending ? 'not-allowed' : 'pointer';
          globalChatSendBtn.textContent = isSending ? 'Sending…' : 'Send';
      }
      if (globalChatInput) {
          globalChatInput.disabled = isSending;
      }
  }

  function isBlockedMessage(text) {
      const raw = (text || '').toLowerCase();
      const rawTight = raw.replace(/[^a-z]/g, ''); // remove spaces/punct for raw check
      const norm = normalizeChatText(text);
      if (!norm) return false;
      const normTight = norm; // already stripped to letters
      const candidates = [raw, rawTight, normTight].filter(Boolean);
      const vowellessCandidates = candidates.map(stripVowels);
      const all = [...candidates, ...vowellessCandidates];
      const checkLists = (lists, candidate) => lists.some(term => candidate.includes(term));
      for (const c of all) {
          if (checkLists(BLOCKED_TERMS, c)) return true;
          if (BLOCKED_PATTERNS.some(re => re.test(c))) return true;
          if (checkLists(BLOCKED_VIOLENCE, c)) return true;
          if (BLOCKED_VIOLENCE_PATTERNS.some(re => re.test(c))) return true;
      }
      return false;
  }

  async function sendGlobalChatMessage() {
      // ✅ HARD GUARD: Prevent duplicate sends
      if (globalChatSending) return;
      globalChatSending = true;
      
      if (!globalChatInput) {
          setTimeout(() => { globalChatSending = false; }, 50);
          return;
      }
      const text = (globalChatInput.value || '').trim();
      if (!text) {
          setTimeout(() => { globalChatSending = false; }, 50);
          return;
      }

      // Check message length limit (750 characters)
      if (text.length > 750) {
          setGlobalChatStatus('Message too long. Maximum 750 characters allowed.', true);
          showChatNotice('Message too long. Maximum 750 characters allowed.', true);
          setTimeout(() => { globalChatSending = false; }, 50);
          return;
      }
      const dedupSig = text.replace(/\s+/g, ' ').toLowerCase();
      if (dedupSig && dedupSig === lastGlobalChatMessageSig) {
          setGlobalChatStatus('Duplicate message blocked.', true);
          showChatNotice('You already sent that message.', true);
          setTimeout(() => { globalChatSending = false; }, 50);
          return;
      }
      
      setChatSendingUi(true);
      try {
          if (!isValidChatName(globalChatUsername)) {
              setGlobalChatStatus('Please set a display name before chatting.', true);
              if (globalChatNameInput) {
                  globalChatNameInput.focus();
              }
              showChatNotice('Set a display name first (not the default).', true);
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          if (isNameBlocked(globalChatUsername)) {
              setGlobalChatStatus('Display name blocked. Please change it before chatting.', true);
              showChatNotice('Display name blocked. Please change it before chatting.', true);
              if (globalChatNameInput) globalChatNameInput.focus();
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          // Check for reserved names (but allow %Owner% as special case)
          if (globalChatUsername !== '%Owner%' && containsReservedName(globalChatUsername)) {
              setGlobalChatStatus('You cannot use "Owner", "Admin", "Mod", or similar words in your name. Please change it.', true);
              showChatNotice('You cannot use "Owner", "Admin", "Mod", or similar words in your name. Please change it.', true);
              if (globalChatNameInput) globalChatNameInput.focus();
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          if (isBlockedMessage(text)) {
              showChatNotice('Message blocked for inappropriate content.', true);
              setGlobalChatStatus('Message blocked for inappropriate content.', true);
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          // Check for phone numbers
          if (containsPhoneNumber(text)) {
              showChatNotice('Phone numbers are not allowed in chat messages.', true);
              setGlobalChatStatus('Phone numbers are not allowed in chat messages.', true);
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          // Check for addresses
          if (containsAddress(text)) {
              showChatNotice('Addresses are not allowed in chat messages.', true);
              setGlobalChatStatus('Addresses are not allowed in chat messages.', true);
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          const aiCheck = await moderateWithAI(text);
          if (!aiCheck.ok) {
              setGlobalChatStatus('AI moderation unavailable. Please try again shortly.', true);
              showChatNotice('AI moderation is temporarily unavailable. Please try again in a moment.', true);
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          if (aiCheck.flagged) {
              setGlobalChatStatus('Message blocked by AI moderation.', true);
              showChatNotice('Message blocked by AI moderation.', true);
              setTimeout(() => { globalChatSending = false; }, 50);
              return;
          }
          setGlobalChatStatus('Sending...');
          
          // Generate temporary ID for optimistic message (will be replaced by Worker's real ID)
          const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const now = new Date().toISOString();
          
          // Create optimistic message object
          const optimisticMessage = {
              id: tempId,
              user_id: globalChatUsername,
              content: JSON.stringify({ text: text, state: null }),
              created_at: now
          };
          
          // Show message immediately (optimistic UI) - deduplication will prevent duplicates when Worker echoes back
          appendGlobalChatMessage(optimisticMessage);
          // ✅ REQUIRED: Register optimistic message in index so removeMessageById() works
          if (globalChatBox && globalChatBox.lastElementChild) {
              messageNodeIndex.set(tempId, globalChatBox.lastElementChild);
          }
          // ✅ Track this optimistic message for reliable replacement
          lastOptimisticTempId = tempId;
          scrollGlobalChatToBottom();
          
          // Clear input immediately for better UX
          globalChatInput.value = '';
          
          // ✅ PRIMARY: Send to Cloudflare Worker WebSocket (no Supabase cost)
          if (chatWorkerWs && chatWorkerWs.readyState === WebSocket.OPEN) {
              try {
                  console.log('📤 Sending message via Chat Worker WebSocket...');
                  
                  // Send in the format Worker expects: { type: "chat", name: username, text }
                  chatWorkerWs.send(JSON.stringify({
                      type: 'chat',
                      name: globalChatUsername,
                      text: text
                  }));
                  
                  console.log('✅ Message sent via Worker WebSocket');
                  
                  setGlobalChatStatus('Sent!');
                  lastGlobalChatMessageSig = dedupSig;
                  
                  // ✅ Reset sending flag after a short delay to allow for rapid successive sends
                  setTimeout(() => {
                      globalChatSending = false;
                      setChatSendingUi(false);
                  }, 50);
                  
                  return; // Success via Worker WebSocket
              } catch (err) {
                  console.error('❌ Chat Worker send failed:', err);
                  setGlobalChatStatus('Failed to send message.', true);
                  setTimeout(() => {
                      globalChatSending = false;
                      setChatSendingUi(false);
                  }, 50);
                  return; // Don't fallback to Supabase - Worker is primary
              }
          } else {
              console.warn('⚠️ Chat Worker WebSocket not connected (state:', chatWorkerWs?.readyState, ')');
              setGlobalChatStatus('Not connected to chat server. Please refresh.', true);
              
              // Try to reconnect
              if (!chatWorkerConnected) {
                  connectChatWorker();
              }
              setTimeout(() => {
                  globalChatSending = false;
                  setChatSendingUi(false);
              }, 50);
              return; // Don't send via Supabase - Worker is required
          }
      } catch (err) {
          // Handle any unexpected errors
          console.error('Unexpected error in sendGlobalChatMessage:', err);
          setTimeout(() => {
              globalChatSending = false;
              setChatSendingUi(false);
          }, 50);
      }
  }

  function openGlobalChatPanel() {
      if (!globalChatPanel) return;
      ensureChatBadge();
      if (globalChatModal) globalChatModal.style.display = 'flex';
      globalChatPanel.style.display = 'flex';
      globalChatIsOpen = true;
      setGlobalChatStatus('Loading chat...');
      applyChatTheme(activeChatTheme);
      initGlobalChatClient();
      autoDetectState();
      scrollGlobalChatToBottom();
      setTimeout(scrollGlobalChatToBottom, 200);
      markChatSeen();
  }

  globalChatToggle?.addEventListener('click', (e) => {
      if (e) {
          e.preventDefault();
          e.stopPropagation();
      }
      markChatSeen(); // user is navigating to chat; count as seen
      openGameInBlank('/pages/chat-only.html');
  });

  document.addEventListener('DOMContentLoaded', () => {
      const allowed = !IS_CHAT_ONLY || isChatAgeVerified();
      if (allowed) {
          bootstrapChatExperienceForPage();
      } else {
          // Even if chat is not allowed, initialize voice activity banner for join/leave messages
          ensureVoiceActivityBanner();
          // Notifications use Cloudflare only, but Supabase is still used for participant discovery
          if (VOICE_DISCOVERY_ENABLED) {
              try { ensureVoiceDiscoveryObserver(); } catch (_) {}
          }
          // Supabase presence DISABLED - using only Cloudflare for participant discovery
          // Presence sync multiplies messages by subscribers (causing massive usage)
          // initGlobalChatClient().then((client) => {
          //     try { ensureVoiceActivityChannel(client); } catch (_) {}
          // });
      }
  });
  
  // ✅ GLOBAL VOICE PRESENCE INITIALIZATION
  // This ensures voice discovery (notifications) work on ALL pages, not just VC page
  // Discovery is separate from participation - you can see who's in voice without joining
  function initGlobalVoicePresence() {
      // Initialize banner immediately
      ensureVoiceActivityBanner();
      
      // ✅ Connect to Cloudflare voice discovery (observer mode - for notifications only)
      // This works on ALL pages and doesn't require joining voice
      if (VOICE_DISCOVERY_ENABLED) {
          try {
              ensureVoiceDiscoveryObserver(); // Observer mode = notifications only, no participation
          } catch (err) {
              console.warn('Failed to initialize Cloudflare voice discovery:', err);
          }
      }
      
      // ✅ Initialize Firebase listeners for voice participants (fallback/legacy)
      // This also works on ALL pages and doesn't require joining voice
      const initFirebaseListener = () => {
          try {
              // Check if Firebase is available via multiple methods
              const db = (typeof window !== 'undefined' && window.firebaseDb) || 
                        (typeof getFirebaseDb === 'function' && getFirebaseDb()) ||
                        (typeof window !== 'undefined' && window.db);
              
              if (db && voiceFirebaseListeners.length === 0) {
                  startVoiceFirebaseListener();
              }
          } catch (err) {
              console.warn('Failed to initialize Firebase voice listener:', err);
          }
      };
      
      // Try immediately and with retries (Firebase may not be ready yet)
      initFirebaseListener();
      setTimeout(initFirebaseListener, 100);
      setTimeout(initFirebaseListener, 500);
      setTimeout(initFirebaseListener, 1000);
      setTimeout(initFirebaseListener, 2000);
      
      // Also listen for firebaseReady event
      if (typeof window !== 'undefined') {
          const onFirebaseReady = () => {
              setTimeout(initFirebaseListener, 100);
          };
          window.addEventListener('firebaseReady', onFirebaseReady, { once: false });
      }
  }
  
  // ✅ Initialize voice presence globally (only once, on all pages)
  // This ensures notifications work everywhere, not just on VC page
  if (!window.__voicePresenceInitialized) {
      window.__voicePresenceInitialized = true;
      // Run immediately - don't wait for DOMContentLoaded
      initGlobalVoicePresence();
      
      // Also retry after a short delay in case dependencies aren't ready
      setTimeout(() => {
          if (VOICE_DISCOVERY_ENABLED && !voiceDiscoveryWs) {
              try { ensureVoiceDiscoveryObserver(); } catch (_) {}
          }
      }, 500);
  }

  // Sync unread clearing across tabs/windows
  window.addEventListener('storage', (e) => {
      if (e.key === 'globalChatLastSeenTs') {
          const newTs = Number(e.newValue || 0) || 0;
          if (newTs > lastGlobalChatSeenTs) {
              lastGlobalChatSeenTs = newTs;
              globalChatUnread = 0;
              updateChatBadge();
          }
      }
  });

  // ----- Blog hero injection -----
  function initBlogHero() {
      const main = document.querySelector('.blog-main');
      if (!main) return;
      const hero = document.createElement('section');
      hero.className = 'blog-hero';
      const h1 = document.querySelector('.blog-container h1') || document.querySelector('h1');
      const title = (h1 && h1.textContent.trim()) || document.title || 'Nebulo Blog';
      const metaDesc = document.querySelector('meta[name=\"description\"]')?.getAttribute('content') || 'Tips, guides, and game picks from Nebulo.';
      const date = new Date();
      const dateStr = date.toLocaleDateString(undefined, { month: 'long', day: 'numeric', year: 'numeric' });
      hero.innerHTML = `
        <div class="blog-hero__title"><i class="fas fa-pen-nib"></i><span>${title}</span></div>
        <p class="blog-hero__subtitle">${metaDesc}</p>
        <div class="blog-hero__meta">
          <span class="blog-hero__pill"><i class="fas fa-calendar-alt"></i> ${dateStr}</span>
          <span class="blog-hero__pill"><i class="fas fa-newspaper"></i> Nebulo Blog</span>
        </div>
      `;
      main.parentNode.insertBefore(hero, main);
  }
  document.addEventListener('DOMContentLoaded', initBlogHero);

  // Replace blog headers with the main site header for consistency
  function replaceBlogHeader() {
      const isBlogPage = document.querySelector('.blog-main');
      if (!isBlogPage) return;
      const existingHeader = document.querySelector('header');
      if (existingHeader) existingHeader.remove();
      const existingNav = document.querySelector('nav.main-navigation');
      if (existingNav) existingNav.remove();

      const headerHTML = `
      <header class="site-header">
        <div class="site-header__inner">
          <a href="../index.html" class="brand-link">
            <span class="brand-logo">
              <img src="../images/logoshs.png" alt="Nebulo Logo">
            </span>
            <span class="brand-copy">
              <span class="brand-name">Nebulo</span>
              <span class="brand-tagline">Play | Create | Connect</span>
            </span>
          </a>
          <div class="header-actions primary-actions">
            <button id="globalChatToggle" class="header-action-btn is-primary" title="Open global chat">
              <i class="fas fa-comments"></i>
              <span>Global Chat</span>
            </button>
            <button id="openDrawingBtnHeader" class="header-action-btn" title="Drawing">
              <i class="fas fa-paint-brush"></i>
              <span>Drawing</span>
            </button>
            <a href="../blog/blog.html" class="header-action-btn" title="Blog">
              <i class="fas fa-newspaper"></i>
              <span>Blog</span>
            </a>
            <button id="requestGamesBtn" class="header-action-btn is-ghost" title="Request Games or Apps">
              <i class="fas fa-plus"></i>
              <span>Request Games/Apps</span>
            </button>
          </div>
          <div class="header-actions quick-actions">
            <button id="youtubeWatcherBtn" class="header-icon-btn youtube-watcher-btn" title="Watch YouTube unblocked" aria-label="Watch YouTube unblocked">
              <i class="fab fa-youtube"></i>
            </button>
            <button id="movieBtn" class="header-icon-btn header-thumb-btn" title="Open Movies" aria-label="Open Movies">
              <img src="https://frogiesarcade.win/stuff/apps/movies.jpg" alt="Movies">
            </button>
            <button id="discordBtn" class="header-icon-btn discord" title="Join Discord" aria-label="Join Discord">
              <i class="fab fa-discord"></i>
            </button>
          </div>
        </div>
      </header>`;

      const navHTML = `
      <nav class="main-navigation">
        <div class="nav-container">
          <a href="../index.html" class="nav-item nav-home">
            <i class="fas fa-home"></i>
            <span>Home</span>
          </a>
          <div class="nav-item nav-dropdown">
            <a href="all-games.html" class="nav-link">
              <i class="fas fa-gamepad"></i>
              <span>All Games</span>
            </a>
            <div class="nav-dropdown-content">
              <a href="all-games.html?category=action">
                <i class="fas fa-fist-raised"></i> Action Games
              </a>
              <a href="all-games.html?category=racing">
                <i class="fas fa-car"></i> Racing Games
              </a>
              <a href="all-games.html?category=puzzle">
                <i class="fas fa-puzzle-piece"></i> Puzzle Games
              </a>
              <a href="../pages/games-new.html">
                <i class="fas fa-star"></i> New Games
              </a>
            </div>
          </div>
          <button id="openDrawingBtn" class="nav-item nav-button nav-featured">
            <i class="fas fa-paint-brush"></i>
            <span>Drawing</span>
          </button>
          <a href="../pages/movies.html" class="nav-item">
            <i class="fas fa-film"></i>
            <span>Movies</span>
          </a>
          <a href="../pages/contact-us.html" class="nav-item">
            <i class="fas fa-envelope"></i>
            <span>Contact</span>
          </a>
        </div>
      </nav>`;

      const frag = document.createElement('div');
      frag.innerHTML = headerHTML + navHTML;
      const first = document.body.firstChild;
      document.body.insertBefore(frag.firstElementChild, first);
      document.body.insertBefore(frag.lastElementChild, document.body.children[1]);
  }
  document.addEventListener('DOMContentLoaded', replaceBlogHeader);

  // Global footer injection for all pages
  function resolvePathPrefix() {
      const segments = (window.location.pathname || '').split('/').filter(Boolean);
      if (segments.length <= 1) return '';
      return '../'.repeat(segments.length - 1);
  }

  function buildFooterMarkup(prefix, year) {
      return `
    <div class="footer-inner">
      <div class="footer-brand">
        <img src="${prefix}images/logoshs.png" alt="Nebulo logo">
        <div>
          <h4>Nebulo</h4>
          <p>Unblocked-friendly hub for games, chat, and tools that still feel fast on low-end devices.</p>
        </div>
      </div>
      <div class="footer-col">
        <h5>Explore</h5>
        <ul>
          <li><a href="${prefix}index.html"><i class="fas fa-home"></i>Home</a></li>
          <li><a href="${prefix}index.html#gamesGridContainer"><i class="fas fa-gamepad"></i>Play Games</a></li>
          <li><a href="${prefix}pages/recently-played.html"><i class="fas fa-history"></i>Recently Played</a></li>
          <li><a href="${prefix}blog/blog.html"><i class="fas fa-newspaper"></i>Blog</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <h5>Support</h5>
        <ul>
          <li><a href="${prefix}pages/contact-us.html"><i class="fas fa-envelope"></i>Contact</a></li>
          <li><a href="${prefix}pages/about-us.html"><i class="fas fa-users"></i>About Nebulo</a></li>
          <li><a href="${prefix}ads.txt"><i class="fas fa-ad"></i>Ads.txt</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <h5>Legal</h5>
        <ul>
          <li><a href="${prefix}pages/privacy-policy.html"><i class="fas fa-shield-alt"></i>Privacy Policy</a></li>
          <li><a href="${prefix}pages/privacy-policy.html#data-rights"><i class="fas fa-user-shield"></i>Your Choices</a></li>
          <li><a href="${prefix}pages/contact-us.html"><i class="fas fa-question-circle"></i>Report an Issue</a></li>
        </ul>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; ${year} Nebulo. Built for quick sessions anywhere.</p>
    </div>`;
  }

  function injectGlobalFooter() {
      const prefix = resolvePathPrefix();
      const footerYear = new Date().getFullYear();
      let footer = document.querySelector('.site-footer');
      if (!footer) {
          footer = document.createElement('footer');
          footer.className = 'site-footer';
          document.body.appendChild(footer);
      }
      footer.classList.add('visible');
      footer.innerHTML = buildFooterMarkup(prefix, footerYear);
  }
  document.addEventListener('DOMContentLoaded', injectGlobalFooter);
  // ✅ Ensure event listeners are only attached ONCE
  if (!window.globalChatInitialized) {
      window.globalChatInitialized = true;
      
      closeGlobalChat?.addEventListener('click', () => {
          if (globalChatPanel) globalChatPanel.style.display = 'none';
          if (globalChatModal) globalChatModal.style.display = 'none';
           globalChatIsOpen = false;
          setGlobalChatStatus('');
          // Mark as seen when closing an open chat
          markChatSeen();
      });
      globalChatSendBtn?.addEventListener('click', sendGlobalChatMessage);
      globalChatInput?.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
              e.preventDefault(); // ✅ REQUIRED: Prevent form submission
              sendGlobalChatMessage();
          }
      });
      
      // Prevent closing by clicking outside; only the X closes
      globalChatModal?.addEventListener('click', (e) => {
          if (e.target === globalChatModal) {
              e.stopPropagation();
          }
      });
      globalChatSettingsBtn?.addEventListener('click', () => {
          if (globalChatSettingsModal) {
              globalChatSettingsModal.style.display = globalChatSettingsModal.style.display === 'block' ? 'none' : 'block';
          }
      });
      closeGlobalChatSettings?.addEventListener('click', () => {
          if (globalChatSettingsModal) globalChatSettingsModal.style.display = 'none';
      });
  }

  document.addEventListener('click', (e) => {
      if (globalChatEmojiPicker && !globalChatEmojiPicker.contains(e.target) && !globalChatEmojiBtn?.contains(e.target)) {
          globalChatEmojiPicker.style.display = 'none';
      }
      document.querySelectorAll('.react-picker').forEach(p => {
          if (!p.contains(e.target) && !p.previousSibling?.contains?.(e.target)) {
              p.style.display = 'none';
          }
      });
      // Typing state removed - no longer using Supabase typing table
  });

  // Leaderboard loader
  function loadLeaderboardBackend(type) {
      if(!leaderboardContent) return;
      loadLeaderboard(type || 'active');
  }
let chatBackendReady = false;
let backendChatListenersAttached = false;
let chatPollInterval = null;
const backendChatMessageIds = new Set();
let counterPollInterval = null;

  function createVisitorId() {
    const timestamp = Date.now();
    const perf = typeof performance !== 'undefined' ? Math.floor(performance.now() * 1000) : Math.floor(Math.random() * 1000000);
    const random = Math.random().toString(36).substring(2, 15);
    return `visitor_${timestamp}_${perf}_${random}`.replace(/[.#$\\[\\]]/g, '_');
  }

  // Movies button (shows modal overlay instead of new tab)
  const movieBtn = document.getElementById('movieBtn');
  if (movieBtn) {
      movieBtn.addEventListener('click', () => {
          const modal = document.getElementById('moviesIframeOverlay');
          if (modal) {
              modal.style.display = 'flex';
          }
      });
  }
  
  // Movies modal event handlers
  const closeMoviesIframe = document.getElementById('closeMoviesIframe');
  if (closeMoviesIframe) {
      closeMoviesIframe.addEventListener('click', () => {
          const modal = document.getElementById('moviesIframeOverlay');
          if (modal) {
              modal.style.display = 'none';
          }
      });
  }

  // Additional popup blocking for movies iframe
  const moviesIframe = document.getElementById('moviesIframe');
  if (moviesIframe) {
      // Override window.open in the iframe context
      moviesIframe.addEventListener('load', () => {
          try {
              const iframeWindow = moviesIframe.contentWindow;
              if (iframeWindow) {
                  const originalOpen = iframeWindow.open;
                  iframeWindow.open = function() {
                      console.warn('Blocked popup attempt from movies iframe');
                      return null;
                  };
              }
          } catch (e) {
              // Cross-origin iframe, can't access contentWindow
              console.log('Movies iframe loaded (cross-origin protection active)');
          }
      });
  }

  const refreshMoviesBtn = document.getElementById('refreshMoviesBtn');
  if (refreshMoviesBtn) {
      refreshMoviesBtn.addEventListener('click', () => {
          const iframe = document.getElementById('moviesIframe');
          if (iframe) {
              iframe.src = iframe.src; // Reload the iframe
          }
      });
  }

  // Close modal when clicking outside the iframe content
  const moviesIframeOverlay = document.getElementById('moviesIframeOverlay');
  if (moviesIframeOverlay) {
      moviesIframeOverlay.addEventListener('click', (e) => {
          if (e.target === moviesIframeOverlay) {
              moviesIframeOverlay.style.display = 'none';
          }
      });
  }

  // Proxy button - opens proxy in iframe overlay
  const proxyBtn = document.getElementById('proxyBtn');
  if (proxyBtn) {
      proxyBtn.addEventListener('click', () => {
          const modal = document.getElementById('proxyIframeOverlay');
          if (modal) {
              modal.style.display = 'flex';
          }
      });
  }

  // Proxy modal event handlers
  const closeProxyIframe = document.getElementById('closeProxyIframe');
  if (closeProxyIframe) {
      closeProxyIframe.addEventListener('click', () => {
          const modal = document.getElementById('proxyIframeOverlay');
          if (modal) {
              modal.style.display = 'none';
          }
      });
  }

  const refreshProxyBtn = document.getElementById('refreshProxyBtn');
  if (refreshProxyBtn) {
      refreshProxyBtn.addEventListener('click', () => {
          const iframe = document.getElementById('proxyIframe');
          if (iframe) {
              iframe.src = iframe.src; // Reload the iframe
          }
      });
  }

  // Close proxy modal when clicking outside the iframe content
  const proxyIframeOverlay = document.getElementById('proxyIframeOverlay');
  if (proxyIframeOverlay) {
      proxyIframeOverlay.addEventListener('click', (e) => {
          if (e.target === proxyIframeOverlay) {
              proxyIframeOverlay.style.display = 'none';
          }
      });
  }

  // Handle messages from proxy iframe
  window.addEventListener('message', (event) => {
      if (event.data === 'closeProxy') {
          const modal = document.getElementById('proxyIframeOverlay');
          if (modal) {
              modal.style.display = 'none';
          }
      }
  });

  // Ensure game page back buttons navigate out of wrappers
  document.querySelectorAll('.premium-back-btn').forEach(btn => {
      btn.setAttribute('target', '_top');
      btn.setAttribute('rel', 'noopener');
  });
  // Enhanced YouTube Video Watcher with modern UI and features
  const youtubeBtn = document.getElementById('youtubeWatcherBtn');

  // YouTube API configuration
  const YOUTUBE_API_KEY = 'AIzaSyBn1apVsFafY2-2a2QPeslX17XR0gWE9qs'; // Use existing Firebase API key
  const YOUTUBE_API_URL = 'https://www.googleapis.com/youtube/v3';
  const YOUTUBE_API_FALLBACK_KEY = ''; // Fallback API key (leave empty if not available)
  const YOUTUBE_API_FALLBACK_ENABLED = false; // Disable fallback if key is invalid

  // YouTube history storage
  const YOUTUBE_HISTORY_KEY = 'youtubeWatchHistory';
  let youtubeHistory = JSON.parse(localStorage.getItem(YOUTUBE_HISTORY_KEY)) || [];

  // Enhanced YouTube ID extraction with better pattern matching
  function extractYouTubeId(raw) {
      if (!raw) return '';
      const value = raw.trim();
      console.log('[YouTube Debug] Raw input:', value);
      
      // Direct ID paste
      const directMatch = value.match(/^[a-zA-Z0-9_-]{11}$/);
      if (directMatch) {
          console.log('[YouTube Debug] Detected direct ID:', directMatch[0]);
          return directMatch[0];
      }

      // Parse as URL and handle common host/path patterns
      try {
          const url = new URL(value.startsWith('http') ? value : `https://${value}`);
          const host = url.hostname.replace(/^www\./, '').toLowerCase();
          console.log('[YouTube Debug] Parsed URL host/path:', host, url.pathname, url.search);
          
          // youtu.be/<id>
          if (host === 'youtu.be') {
              const pathId = url.pathname.split('/').filter(Boolean)[0];
              if (pathId) {
                  console.log('[YouTube Debug] Matched youtu.be id:', pathId);
                  return pathId;
              }
          }
          
          // youtube.com variants (desktop, mobile, music, nocookie)
          const youtubeHosts = new Set([
              'youtube.com',
              'm.youtube.com',
              'music.youtube.com',
              'youtube-nocookie.com'
          ]);
          if (youtubeHosts.has(host)) {
              const vParam = url.searchParams.get('v');
              if (vParam && /^[a-zA-Z0-9_-]{11}$/.test(vParam)) {
                  console.log('[YouTube Debug] Found v param id:', vParam);
                  return vParam;
              }
              
              const segments = url.pathname.split('/').filter(Boolean);
              if (segments.length >= 2) {
                  const [prefix, id] = segments;
                  if (['embed', 'shorts', 'live'].includes(prefix) && /^[a-zA-Z0-9_-]{11}$/.test(id)) {
                      console.log('[YouTube Debug] Matched path segment id:', id, 'via', prefix);
                      return id;
                  }
              }
          }
      } catch (_) {
          // Fall through to regex fallback
      }

      // Loose fallback search for any 11-char video id inside the string
      const fallback = value.match(/([a-zA-Z0-9_-]{11})/);
      if (!fallback) {
          console.warn('[YouTube Debug] No video ID detected in input.');
      } else {
          console.log('[YouTube Debug] Fallback matched ID:', fallback[1]);
      }
      return fallback ? fallback[1] : '';
  }

  // Fetch video info from YouTube API with fallback
  async function fetchYouTubeVideoInfo(videoId) {
      try {
          // Try primary API key first
          let response = await fetch(`${YOUTUBE_API_URL}/videos?part=snippet,contentDetails&id=${videoId}&key=${YOUTUBE_API_KEY}`);
          let data = await response.json();

          // If primary key fails and fallback is enabled, try fallback key
          if (YOUTUBE_API_FALLBACK_ENABLED && YOUTUBE_API_FALLBACK_KEY &&
              (!data.items || data.items.length === 0) && response.status === 403) {
              console.warn('Primary YouTube API key failed, trying fallback key');
              response = await fetch(`${YOUTUBE_API_URL}/videos?part=snippet,contentDetails&id=${videoId}&key=${YOUTUBE_API_FALLBACK_KEY}`);
              data = await response.json();
          }

          if (data.items && data.items.length > 0) {
              const video = data.items[0];
              return {
                  id: videoId,
                  title: video.snippet.title,
                  thumbnail: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.default.url,
                  channel: video.snippet.channelTitle,
                  duration: formatDuration(video.contentDetails.duration),
                  publishedAt: video.snippet.publishedAt
              };
          }
          return null;
      } catch (error) {
          console.error('Error fetching YouTube video info:', error);
          return null;
      }
  }

  // Search YouTube videos with fallback API key - DISABLED as per user request
  async function searchYouTubeVideos(query, maxResults = 10) {
      // Search functionality disabled as per user request
      console.warn('YouTube search is disabled. Use direct URL entry instead.');
      return [];
  }

  // Format duration from ISO 8601 to readable format
  function formatDuration(isoDuration) {
      try {
          const match = isoDuration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
          if (!match) return '0:00';

          const hours = parseInt(match[1]) || 0;
          const minutes = parseInt(match[2]) || 0;
          const seconds = parseInt(match[3]) || 0;

          if (hours > 0) {
              return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          }
          return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      } catch {
          return '0:00';
      }
  }

  // Add video to history
  function addToYouTubeHistory(video) {
      // Remove duplicate if exists
      youtubeHistory = youtubeHistory.filter(v => v.id !== video.id);

      // Add new video to beginning
      youtubeHistory.unshift({
          ...video,
          timestamp: Date.now()
      });

      // Keep only last 20 videos
      if (youtubeHistory.length > 20) {
          youtubeHistory = youtubeHistory.slice(0, 20);
      }

      localStorage.setItem(YOUTUBE_HISTORY_KEY, JSON.stringify(youtubeHistory));
  }

  // Create YouTube modal
  function createYouTubeModal() {
      // Check if modal already exists
      if (document.getElementById('youtubeModal')) return;

      const modal = document.createElement('div');
      modal.id = 'youtubeModal';
      modal.className = 'youtube-modal';
      modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          z-index: 10000;
          display: none;
          justify-content: center;
          align-items: center;
          backdrop-filter: blur(5px);
      `;

      modal.innerHTML = `
          <div class="youtube-modal-content" style="
              width: 90%;
              max-width: 800px;
              max-height: 90vh;
              background: linear-gradient(135deg, #1a1a2a, #0f0f1a);
              border-radius: 16px;
              box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
              overflow: hidden;
              display: flex;
              flex-direction: column;
              animation: slideUp 0.3s ease-out;
          ">
              <div class="youtube-modal-header" style="
                  padding: 20px 24px;
                  background: linear-gradient(135deg, #FFD700, #FFA500);
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                  border-bottom: 1px solid rgba(255, 215, 0, 0.2);
              ">
                  <h2 style="margin: 0; color: #000; font-size: 24px; font-weight: 700;">
                      <i class="fab fa-youtube" style="margin-right: 10px;"></i>
                      Watch YouTube Videos
                  </h2>
                  <button id="closeYouTubeModal" style="
                      background: none;
                      border: none;
                      font-size: 24px;
                      cursor: pointer;
                      color: #000;
                      padding: 5px;
                      border-radius: 50%;
                      transition: all 0.2s;
                  " title="Close">
                      <i class="fas fa-times"></i>
                  </button>
              </div>

              <div class="youtube-modal-tabs" style="
                  display: flex;
                  padding: 0 20px;
                  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                  background: rgba(255, 255, 255, 0.02);
              ">
                  <button class="youtube-tab-btn active" data-tab="url" style="
                      flex: 1;
                      padding: 12px 0;
                      background: none;
                      border: none;
                      color: rgba(255, 255, 255, 0.7);
                      font-size: 14px;
                      font-weight: 600;
                      cursor: pointer;
                      transition: all 0.3s;
                      border-bottom: 2px solid transparent;
                  ">
                      <i class="fas fa-link" style="margin-right: 8px;"></i>
                      Direct URL
                  </button>
                  <button class="youtube-tab-btn" data-tab="history" style="
                      flex: 1;
                      padding: 12px 0;
                      background: none;
                      border: none;
                      color: rgba(255, 255, 255, 0.7);
                      font-size: 14px;
                      font-weight: 600;
                      cursor: pointer;
                      transition: all 0.3s;
                      border-bottom: 2px solid transparent;
                  ">
                      <i class="fas fa-history" style="margin-right: 8px;"></i>
                      History
                  </button>
              </div>

              <div class="youtube-modal-body" style="
                  flex: 1;
                  overflow-y: auto;
                  padding: 20px;
                  position: relative;
              ">
                  <!-- Video Embed Container -->
                  <div id="youtubeEmbedContainer" style="display: none; position: relative; width: 100%; height: 400px; background: #000; border-radius: 12px; overflow: hidden; margin-bottom: 20px;">
                      <iframe id="youtubeEmbedIframe" src="" style="width: 100%; height: 100%; border: 0;" allowfullscreen allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen"></iframe>
                      <button id="youtubeFullscreenBtn" style="
                          position: absolute;
                          top: 10px;
                          right: 10px;
                          background: rgba(0,0,0,0.7);
                          border: none;
                          border-radius: 8px;
                          color: #fff;
                          padding: 8px 12px;
                          cursor: pointer;
                          font-size: 14px;
                          z-index: 10;
                          transition: all 0.3s;
                      " title="Fullscreen">
                          <i class="fas fa-expand"></i>
                      </button>
                      <button id="youtubeCloseEmbedBtn" style="
                          position: absolute;
                          top: 10px;
                          left: 10px;
                          background: rgba(0,0,0,0.7);
                          border: none;
                          border-radius: 8px;
                          color: #fff;
                          padding: 8px 12px;
                          cursor: pointer;
                          font-size: 14px;
                          z-index: 10;
                          transition: all 0.3s;
                      " title="Close Video">
                          <i class="fas fa-times"></i>
                      </button>
                  </div>

                  <!-- URL Tab -->
                  <div id="youtubeUrlTab" class="youtube-tab-content active" style="display: block;">
                      <div style="margin-bottom: 20px;">
                          <label for="youtubeUrlInput" style="display: block; margin-bottom: 8px; color: rgba(255, 255, 255, 0.8); font-weight: 600;">
                              YouTube Video URL
                          </label>
                          <input type="text" id="youtubeUrlInput" placeholder="https://www.youtube.com/watch?v=dQw4w9WgXcQ"
                              style="width: 100%; padding: 14px 18px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; color: rgba(255, 255, 255, 0.9); font-size: 15px; transition: all 0.3s;"
                              spellcheck="false">
                          <p style="margin: 8px 0 0 0; font-size: 12px; color: rgba(255, 255, 255, 0.5);">
                              <i class="fas fa-info-circle" style="margin-right: 6px;"></i>
                              Paste any YouTube URL or video ID
                          </p>
                      </div>

                      <div id="youtubePreview" style="display: none; margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.03); border-radius: 12px; border: 1px solid rgba(255, 215, 0, 0.2);">
                          <div style="display: flex; gap: 15px;">
                              <div style="flex: 0 0 120px; height: 90px; background-size: cover; background-position: center; border-radius: 8px; background: rgba(255, 255, 255, 0.05);" id="youtubePreviewThumbnail"></div>
                              <div style="flex: 1; min-width: 0;">
                                  <div style="font-weight: 600; color: #FFD700; margin-bottom: 5px; font-size: 15px;" id="youtubePreviewTitle">Loading...</div>
                                  <div style="font-size: 13px; color: rgba(255, 255, 255, 0.7); margin-bottom: 5px;" id="youtubePreviewChannel"></div>
                                  <div style="font-size: 12px; color: rgba(255, 255, 255, 0.5);" id="youtubePreviewDuration"></div>
                              </div>
                          </div>
                      </div>

                      <div style="display: flex; margin-top: 20px;">
                          <button id="youtubeWatchBtn" style="
                              width: 100%;
                              padding: 14px;
                              background: linear-gradient(135deg, #28a745, #20c997);
                              border: none;
                              border-radius: 12px;
                              color: #fff;
                              font-size: 15px;
                              font-weight: 600;
                              cursor: pointer;
                              transition: all 0.3s;
                              opacity: 1;
                          ">
                              <i class="fas fa-play" style="margin-right: 8px;"></i>
                              Watch Now
                          </button>
                      </div>
                  </div>

                  <!-- Search Tab - REMOVED as per user request -->

                  <!-- History Tab -->
                  <div id="youtubeHistoryTab" class="youtube-tab-content" style="display: none;">
                      <div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                          <h3 style="margin: 0; color: rgba(255, 255, 255, 0.9); font-size: 18px; font-weight: 600;">Recently Watched</h3>
                          <button id="clearYouTubeHistory" style="
                              background: rgba(255, 255, 255, 0.05);
                              border: 1px solid rgba(255, 255, 255, 0.2);
                              border-radius: 8px;
                              padding: 6px 12px;
                              color: rgba(255, 255, 255, 0.7);
                              font-size: 12px;
                              cursor: pointer;
                              transition: all 0.3s;
                          " title="Clear History">
                              <i class="fas fa-trash" style="margin-right: 6px;"></i>
                              Clear
                          </button>
                      </div>

                      <div id="youtubeHistoryList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;"></div>

                      <div id="youtubeHistoryEmpty" style="${youtubeHistory.length === 0 ? 'display: block;' : 'display: none;'} text-align: center; padding: 40px 0; color: rgba(255, 255, 255, 0.5);">
                          <i class="fas fa-history" style="font-size: 32px; margin-bottom: 15px; display: block;"></i>
                          <p>No videos watched yet.</p>
                          <p style="font-size: 13px; margin-top: 10px;">Videos you watch will appear here.</p>
                      </div>
                  </div>
              </div>
          </div>

          <style>
              @keyframes slideUp {
                  from {
                      transform: translateY(20px);
                      opacity: 0;
                  }
                  to {
                      transform: translateY(0);
                      opacity: 1;
                  }
              }

              @keyframes spin {
                  to { transform: rotate(360deg); }
              }

              .youtube-modal-content::-webkit-scrollbar {
                  width: 8px;
              }

              .youtube-modal-content::-webkit-scrollbar-track {
                  background: rgba(255, 255, 255, 0.05);
                  border-radius: 10px;
              }

              .youtube-modal-content::-webkit-scrollbar-thumb {
                  background: rgba(255, 255, 255, 0.2);
                  border-radius: 10px;
              }

              .youtube-modal-content::-webkit-scrollbar-thumb:hover {
                  background: rgba(255, 255, 255, 0.3);
              }

              .youtube-video-card {
                  background: rgba(255, 255, 255, 0.03);
                  border-radius: 12px;
                  overflow: hidden;
                  cursor: pointer;
                  transition: all 0.3s;
                  border: 1px solid transparent;
              }

              .youtube-video-card:hover {
                  background: rgba(255, 255, 255, 0.05);
                  border-color: rgba(255, 215, 0, 0.2);
                  transform: translateY(-2px);
              }

              .youtube-video-thumbnail {
                  width: 100%;
                  height: 112px;
                  background-size: cover;
                  background-position: center;
                  position: relative;
              }

              .youtube-video-duration {
                  position: absolute;
                  bottom: 5px;
                  right: 5px;
                  background: rgba(0, 0, 0, 0.7);
                  color: #fff;
                  padding: 2px 6px;
                  border-radius: 4px;
                  font-size: 11px;
                  font-weight: 600;
              }

              .youtube-video-info {
                  padding: 12px;
              }

              .youtube-video-title {
                  font-size: 13px;
                  font-weight: 600;
                  color: rgba(255, 255, 255, 0.9);
                  margin-bottom: 4px;
                  display: -webkit-box;
                  -webkit-line-clamp: 2;
                  -webkit-box-orient: vertical;
                  overflow: hidden;
              }

              .youtube-video-channel {
                  font-size: 11px;
                  color: rgba(255, 255, 255, 0.6);
                  display: -webkit-box;
                  -webkit-line-clamp: 1;
                  -webkit-box-orient: vertical;
                  overflow: hidden;
              }
          </style>
      `;

      document.body.appendChild(modal);

      // Add CSS animations to head if not already present
      const style = document.createElement('style');
      style.textContent = `
          @keyframes slideUp {
              from {
                  transform: translateY(20px);
                  opacity: 0;
              }
              to {
                  transform: translateY(0);
                  opacity: 1;
              }
          }

          @keyframes spin {
              to { transform: rotate(360deg); }
          }
      `;
      document.head.appendChild(style);

      // Initialize modal functionality
      initializeYouTubeModal();
  }

  // Initialize YouTube modal functionality
  function initializeYouTubeModal() {
      const modal = document.getElementById('youtubeModal');
      const closeBtn = modal?.querySelector('#closeYouTubeModal') || document.getElementById('closeYouTubeModal');
      const urlInput = modal?.querySelector('#youtubeUrlInput') || document.getElementById('youtubeUrlInput');
      const previewBtn = modal?.querySelector('#youtubePreviewBtn') || document.getElementById('youtubePreviewBtn');
      const watchBtn = modal?.querySelector('#youtubeWatchBtn') || document.getElementById('youtubeWatchBtn');
      const searchInput = modal?.querySelector('#youtubeSearchInput') || document.getElementById('youtubeSearchInput');
      const searchBtn = modal?.querySelector('#youtubeSearchBtn') || document.getElementById('youtubeSearchBtn');
      const searchResults = modal?.querySelector('#youtubeSearchResults') || document.getElementById('youtubeSearchResults');
      const searchLoading = modal?.querySelector('#youtubeSearchLoading') || document.getElementById('youtubeSearchLoading');
      const searchEmpty = modal?.querySelector('#youtubeSearchEmpty') || document.getElementById('youtubeSearchEmpty');
      const historyList = modal?.querySelector('#youtubeHistoryList') || document.getElementById('youtubeHistoryList');
      const historyEmpty = modal?.querySelector('#youtubeHistoryEmpty') || document.getElementById('youtubeHistoryEmpty');
      const clearHistoryBtn = modal?.querySelector('#clearYouTubeHistory') || document.getElementById('clearYouTubeHistory');
      const previewContainer = modal?.querySelector('#youtubePreview') || document.getElementById('youtubePreview');
      const previewThumbnail = modal?.querySelector('#youtubePreviewThumbnail') || document.getElementById('youtubePreviewThumbnail');
      const previewTitle = modal?.querySelector('#youtubePreviewTitle') || document.getElementById('youtubePreviewTitle');
      const previewChannel = modal?.querySelector('#youtubePreviewChannel') || document.getElementById('youtubePreviewChannel');
      const previewDuration = modal?.querySelector('#youtubePreviewDuration') || document.getElementById('youtubePreviewDuration');

      // Ensure YouTube URLs are rewritten to yout-ube variants
      const toDashYouTube = (raw) => {
          if (!raw) return '';
          try {
              const u = new URL(raw.startsWith('http') ? raw : `https://${raw}`);
              const replacedHost = u.hostname
                  .replace('youtube-nocookie.com', 'yout-ube-nocookie.com')
                  .replace('youtube.com', 'yout-ube.com')
                  .replace('youtu.be', 'yout-ube.be');
              u.hostname = replacedHost;
              return u.toString();
          } catch (_) {
              // fallback simple replacement
              return raw.replace(/youtube/g, 'yout-ube').replace(/youtu\\.be/g, 'yout-ube.be');
          }
      };

      // Keep the Watch button in sync with the latest usable input/dataset
      const updateWatchButtonState = () => {
          if (!watchBtn) return;
          // Always allow clicking; validation is handled inside the click handler
          watchBtn.disabled = false;
          watchBtn.style.opacity = '1';
          watchBtn.style.pointerEvents = 'auto';
      };

      // Start with the button disabled until we have a valid URL/id
      updateWatchButtonState();
      console.log('[YouTube Debug] Modal initialized, history size:', youtubeHistory.length);

      // Tab switching
      document.querySelectorAll('.youtube-tab-btn').forEach(btn => {
          btn.addEventListener('click', () => {
              const tab = btn.dataset.tab;

              // Update active tab
              document.querySelectorAll('.youtube-tab-btn').forEach(b => {
                  b.classList.remove('active');
                  b.style.color = 'rgba(255, 255, 255, 0.7)';
                  b.style.borderBottomColor = 'transparent';
              });
              btn.classList.add('active');
              btn.style.color = '#FFD700';
              btn.style.borderBottomColor = '#FFD700';

              // Show correct tab content
              document.querySelectorAll('.youtube-tab-content').forEach(content => {
                  content.style.display = 'none';
              });
              document.getElementById(`youtube${tab.charAt(0).toUpperCase() + tab.slice(1)}Tab`).style.display = 'block';
          });
      });

      // Close modal
      function closeYouTubeModal() {
          modal.style.display = 'none';
          // Reset form
          urlInput.value = '';
          previewContainer.style.display = 'none';
          if (previewBtn) {
              previewBtn.disabled = true;
              previewBtn.style.opacity = '0.5';
          }
          if (watchBtn) {
              watchBtn.dataset.videoId = '';
              watchBtn.dataset.videoInfo = '';
              updateWatchButtonState();
          }
          // Close embed if open
          const embedContainer = modal?.querySelector('#youtubeEmbedContainer');
          const embedIframe = modal?.querySelector('#youtubeEmbedIframe');
          const urlTab = modal?.querySelector('#youtubeUrlTab');
          if (embedContainer && embedIframe && urlTab) {
              embedContainer.style.display = 'none';
              embedIframe.src = '';
              urlTab.style.display = 'block';
          }
      }

      closeBtn.addEventListener('click', closeYouTubeModal);

      // Close when clicking outside
      modal.addEventListener('click', (e) => {
          if (e.target === modal) {
              closeYouTubeModal();
          }
      });

      // URL input validation
      urlInput.addEventListener('input', () => {
          const url = urlInput.value.trim();
          const isValid = extractYouTubeId(url) !== '';
          console.log('[YouTube Debug] Input change:', { url, isValid });
          if (previewBtn) {
              previewBtn.disabled = !isValid;
              previewBtn.style.opacity = isValid ? '1' : '0.5';
          }
          // Enable watch button directly if URL is valid
          updateWatchButtonState();
      });

      // If preview button exists (legacy), keep it functional; otherwise rely on Watch Now
      if (previewBtn) previewBtn.addEventListener('click', async () => {
          const url = urlInput.value.trim();
          const videoId = extractYouTubeId(url);

          if (!videoId) {
              notifications.show('Invalid YouTube URL', 'error', 2000);
              return;
          }

          // Show loading state
          previewContainer.style.display = 'block';
          previewTitle.textContent = 'Loading video info...';
          previewChannel.textContent = '';
          previewDuration.textContent = '';
          previewThumbnail.style.backgroundImage = 'none';
          previewThumbnail.style.background = 'rgba(255, 255, 255, 0.05)';

          try {
              // Use YouTube's standard thumbnail URL format instead of API
              const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;

              // Create basic video info without API calls
              const videoInfo = {
                  id: videoId,
                  title: 'YouTube Video',
                  thumbnail: thumbnailUrl,
                  channel: 'YouTube',
                  duration: '0:00',
                  publishedAt: new Date().toISOString()
              };

              // Set thumbnail
              previewThumbnail.style.backgroundImage = `url(${thumbnailUrl})`;

              // Show success message
              previewTitle.textContent = 'Video ready!';
              previewChannel.textContent = 'YouTube Video';
              previewDuration.textContent = 'Duration: Unknown';

              // Enable watch button
              watchBtn.disabled = false;
              watchBtn.style.opacity = '1';
              watchBtn.dataset.videoId = videoId;
              watchBtn.dataset.videoInfo = JSON.stringify(videoInfo);

              // Show success notification
              notifications.show('Video ready! Click \"Watch Now\" to open.', 'success', 3000);

          } catch (error) {
              console.error('Error previewing video:', error);
              notifications.show('Error loading video. Please try again.', 'error', 2000);
              previewTitle.textContent = 'Error loading video';
              previewChannel.textContent = 'Please try again';
              previewDuration.textContent = '';
          }
      });

      // Watch button
      watchBtn.addEventListener('click', () => {
          updateWatchButtonState();
          console.log('[YouTube Debug] Watch button clicked', {
              urlInput: urlInput.value,
              datasetId: watchBtn.dataset.videoId,
              datasetInfo: watchBtn.dataset.videoInfo,
              liveDomValue: document.getElementById('youtubeUrlInput')?.value
          });

          // Get video ID either from button data (if preview was clicked) or directly from URL input
          let videoId = watchBtn.dataset.videoId;
          let videoInfo = JSON.parse(watchBtn.dataset.videoInfo || '{}');
          let directUrlFallback = '';

          const rawInputUrl = (modal?.querySelector('#youtubeUrlInput')?.value || '').trim() || (urlInput?.value || '').trim();

          // If no video ID in button data, extract directly from URL input
          if (!videoId) {
              const effectiveUrl = rawInputUrl;
              videoId = extractYouTubeId(effectiveUrl);
              console.log('[YouTube Debug] Extracted from input:', videoId, 'raw:', effectiveUrl);

              // If still no videoId, fall back to opening whatever was typed
              if (!videoId) {
                  directUrlFallback = effectiveUrl;
                  if (!directUrlFallback) {
                      notifications.show('Paste a YouTube URL first', 'error', 2000);
                      urlInput?.focus();
                      updateWatchButtonState();
                      return;
                  }
                  // Normalize without validation; add protocol if missing
                  if (!/^https?:\/\//i.test(directUrlFallback)) {
                      directUrlFallback = `https://${directUrlFallback}`;
                  }
                  console.log('[YouTube Debug] Fallback to direct URL open:', directUrlFallback);
              }

              // Create basic video info without API call
              videoInfo = {
                  id: videoId || directUrlFallback,
                  title: 'YouTube Video',
                  thumbnail: videoId ? `https://img.youtube.com/vi/${videoId}/hqdefault.jpg` : '',
                  channel: 'YouTube',
                  duration: '0:00',
                  publishedAt: new Date().toISOString()
              };

              // Persist on the button for subsequent clicks during this session
              if (videoId) {
                  watchBtn.dataset.videoId = videoId;
              }
              watchBtn.dataset.videoInfo = JSON.stringify(videoInfo);
              updateWatchButtonState();
          }

          // Add to history
          addToYouTubeHistory(videoInfo);

          // Build the embed URL
          let embedUrl = '';
          if (videoId) {
              embedUrl = `https://www.youtube-nocookie.com/embed/${videoId}?autoplay=1&iv_load_policy=3`;
          } else if (directUrlFallback) {
              // For direct URLs, try to convert to embed
              try {
                  const url = new URL(directUrlFallback);
                  if (url.hostname.includes('youtube.com') || url.hostname.includes('youtu.be')) {
                      const extractedId = extractYouTubeId(directUrlFallback);
                      if (extractedId) {
                          embedUrl = `https://www.youtube-nocookie.com/embed/${extractedId}?autoplay=1&iv_load_policy=3`;
                      }
                  }
              } catch (_) {
                  // If conversion fails, use the direct URL
                  embedUrl = directUrlFallback;
              }
          }

          if (!embedUrl) {
              notifications.show('Unable to create embed URL', 'error', 2000);
              return;
          }

          // Show embed container and hide URL tab
          const embedContainer = modal?.querySelector('#youtubeEmbedContainer');
          const embedIframe = modal?.querySelector('#youtubeEmbedIframe');
          const urlTab = modal?.querySelector('#youtubeUrlTab');

          if (embedContainer && embedIframe && urlTab) {
              embedIframe.src = embedUrl;
              embedContainer.style.display = 'block';
              urlTab.style.display = 'none';

              // Switch to URL tab in tabs navigation
              document.querySelectorAll('.youtube-tab-btn').forEach(btn => {
                  btn.classList.remove('active');
                  btn.style.color = 'rgba(255, 255, 255, 0.7)';
                  btn.style.borderBottomColor = 'transparent';
              });
              const urlTabBtn = document.querySelector('.youtube-tab-btn[data-tab="url"]');
              if (urlTabBtn) {
                  urlTabBtn.classList.add('active');
                  urlTabBtn.style.color = '#FFD700';
                  urlTabBtn.style.borderBottomColor = '#FFD700';
              }
          }

          // Show success notification
          notifications.show(`Now watching: ${videoInfo.title || 'YouTube Video'}`, 'success', 3000);
      });

      // Search functionality - REMOVED as per user request
      // Add null checks to prevent errors when search elements don't exist
      if (searchBtn && searchInput && searchResults && searchLoading && searchEmpty) {
        searchBtn.addEventListener('click', async () => {
          const query = searchInput.value.trim();

          if (!query) {
              notifications.show('Please enter a search term', 'error', 2000);
              return;
          }

          // Show loading state
          searchResults.innerHTML = '';
          searchLoading.style.display = 'block';
          searchEmpty.style.display = 'none';

          try {
              const results = await searchYouTubeVideos(query);

              if (results.length > 0) {
                  searchResults.innerHTML = results.map(video => `
                      <div class="youtube-video-card" data-video-id="${video.id}">
                          <div class="youtube-video-thumbnail" style="background-image: url(${video.thumbnail});">
                              <span class="youtube-video-duration">Loading...</span>
                          </div>
                          <div class="youtube-video-info">
                              <div class="youtube-video-title">${video.title}</div>
                              <div class="youtube-video-channel">${video.channel}</div>
                          </div>
                      </div>
                  `).join('');

                  // Load durations for each video
                  results.forEach(async (video) => {
                      try {
                          const info = await fetchYouTubeVideoInfo(video.id);
                          if (info) {
                              const card = document.querySelector(`.youtube-video-card[data-video-id="${video.id}"] .youtube-video-duration`);
                              if (card) card.textContent = info.duration;
                          }
                      } catch (e) {
                          console.error('Error loading duration for video:', video.id, e);
                      }
                  });

                  searchEmpty.style.display = 'none';
              } else {
                  searchEmpty.style.display = 'block';
              }
          } catch (error) {
              console.error('Error searching YouTube:', error);
              if (error.message.includes('403') || error.message.includes('quota')) {
                  notifications.show('YouTube API quota exceeded. Please try again later or use direct URL entry.', 'error', 4000);
              } else {
                  notifications.show('Error searching YouTube. Please check your connection.', 'error', 2000);
              }
              searchEmpty.style.display = 'block';
          } finally {
              searchLoading.style.display = 'none';
          }
        });
      }

      // Search on Enter key - REMOVED as per user request
      if (searchInput && searchBtn) {
          searchInput.addEventListener('keypress', (e) => {
              if (e.key === 'Enter') {
                  searchBtn.click();
              }
          });
      }

      // Video card click handler - REMOVED as per user request
      if (searchResults) {
          searchResults.addEventListener('click', (e) => {
              const card = e.target.closest('.youtube-video-card');
              if (card) {
                  const videoId = card.dataset.videoId;
                  urlInput.value = `https://www.youtube.com/watch?v=${videoId}`;
                  previewBtn.click();
                  // Switch to URL tab
                  document.querySelector('.youtube-tab-btn[data-tab="url"]').click();
              }
          });
      }

      // History card click handler
      historyList.addEventListener('click', (e) => {
          const card = e.target.closest('.youtube-video-card');
          if (card) {
              const videoId = card.dataset.videoId;
              urlInput.value = `https://www.youtube.com/watch?v=${videoId}`;
              if (previewBtn) {
                  previewBtn.click();
              }
              // Switch to URL tab
              document.querySelector('.youtube-tab-btn[data-tab="url"]').click();
              updateWatchButtonState();
          }
      });

      // Clear history
      clearHistoryBtn.addEventListener('click', () => {
          if (youtubeHistory.length === 0) return;

          if (confirm('Clear all YouTube watch history?')) {
              youtubeHistory = [];
              localStorage.setItem(YOUTUBE_HISTORY_KEY, JSON.stringify(youtubeHistory));
              renderYouTubeHistory();
              notifications.show('History cleared', 'success', 2000);
          }
      });

      // Render history
      function renderYouTubeHistory() {
          if (youtubeHistory.length === 0) {
              historyEmpty.style.display = 'block';
              historyList.innerHTML = '';
              return;
          }

          historyEmpty.style.display = 'none';
          historyList.innerHTML = youtubeHistory.map(video => `
              <div class="youtube-video-card" data-video-id="${video.id}">
                  <div class="youtube-video-thumbnail" style="background-image: url(${video.thumbnail});">
                      <span class="youtube-video-duration">${video.duration}</span>
                  </div>
                  <div class="youtube-video-info">
                      <div class="youtube-video-title">${video.title}</div>
                      <div class="youtube-video-channel">${video.channel}</div>
                  </div>
              </div>
          `).join('');
      }

      // Initialize history
      renderYouTubeHistory();

      // Add event listeners for embed controls
      const embedContainer = modal?.querySelector('#youtubeEmbedContainer');
      const embedIframe = modal?.querySelector('#youtubeEmbedIframe');
      const fullscreenBtn = modal?.querySelector('#youtubeFullscreenBtn');
      const closeEmbedBtn = modal?.querySelector('#youtubeCloseEmbedBtn');
      const urlTab = modal?.querySelector('#youtubeUrlTab');

      // Fullscreen button
      if (fullscreenBtn && embedIframe) {
          fullscreenBtn.addEventListener('click', () => {
              if (embedIframe.requestFullscreen) {
                  embedIframe.requestFullscreen().catch(err => console.warn('Fullscreen failed:', err));
              } else if (embedIframe.webkitRequestFullscreen) {
                  embedIframe.webkitRequestFullscreen();
              } else if (embedIframe.mozRequestFullScreen) {
                  embedIframe.mozRequestFullScreen();
              } else if (embedIframe.msRequestFullscreen) {
                  embedIframe.msRequestFullscreen();
              }
          });
      }

      // Close embed button
      if (closeEmbedBtn && embedContainer && urlTab) {
          closeEmbedBtn.addEventListener('click', () => {
              embedContainer.style.display = 'none';
              embedIframe.src = '';
              urlTab.style.display = 'block';
          });
      }
  }

  // Open YouTube modal
  function openYouTubeModal() {
      createYouTubeModal();
      const modal = document.getElementById('youtubeModal');
      if (modal) {
          modal.style.display = 'flex';
      }
  }

  // Enhanced YouTube button click handler - Open video in new tab
  function openYoutubePrompt(evt) {
      if (evt) {
          evt.preventDefault();
          evt.stopImmediatePropagation();
      }

      const videoUrl = 'https://138.199.12.69/3ba2a780b01d4d3f8095b5cb30704704/_rhsw51sx://2LD.~C33~sx.xe3/';
      window.open(videoUrl, '_blank');
  }

  // Initialize YouTube button
  youtubeBtn?.addEventListener('click', openYoutubePrompt, true);

  // Ensure buttons are bound even if earlier init paths are skipped
  document.addEventListener('DOMContentLoaded', () => {
      if (youtubeBtn && !youtubeBtn.hasAttribute('data-handler-attached-dom')) {
          youtubeBtn.setAttribute('data-handler-attached-dom', 'true');
          youtubeBtn.addEventListener('click', openYoutubePrompt, true);
          console.log('[YouTube Debug] Bound youtube watcher button on DOMContentLoaded');
      }
      if (typeof initRandomGameButton === 'function') {
          initRandomGameButton();
          console.log('[RandomGame Debug] initRandomGameButton forced on DOMContentLoaded');
      }
  });

  // Also handle navigation YouTube button if it exists
  const navYouTubeBtn = document.getElementById('navYouTubeBtn');
  navYouTubeBtn?.addEventListener('click', (e) => {
      e.preventDefault();
      openYoutubePrompt(e);
  }, true);

  // Discord button -> open Discord invite
  const discordBtn = document.getElementById('discordBtn');
  if (discordBtn) {
      discordBtn.addEventListener('click', () => {
          window.open('https://discord.gg/ezgfEWd7d2', '_blank', 'noopener,noreferrer');
      });
  }

  // Request Games button -> open custom form in about:blank
  const requestGamesBtn = document.getElementById('requestGamesBtn');
  if (requestGamesBtn) {
      requestGamesBtn.addEventListener('click', () => {
          const html = `<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Request Games - Nebulo</title>
   <style>
       body {
           margin: 0;
           padding: 20px;
           font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
           background: linear-gradient(135deg, #0f0f1a, #1a1a2a);
           color: #ffffff;
           min-height: 100vh;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
       }
       .container {
           max-width: 800px;
           width: 100%;
           text-align: center;
       }
       h1 {
           color: #FFD700;
           margin-bottom: 20px;
           font-size: 2.5rem;
           text-shadow: 0 2px 10px rgba(255,215,0,0.5);
       }
       .form-container {
           background: rgba(255,255,255,0.05);
           border-radius: 16px;
           padding: 30px;
           box-shadow: 0 8px 32px rgba(0,0,0,0.3);
           border: 1px solid rgba(255,215,0,0.2);
       }
       .back-btn {
           position: absolute;
           top: 20px;
           left: 20px;
           background: rgba(255,215,0,0.1);
           border: 1px solid rgba(255,215,0,0.3);
           color: #FFD700;
           padding: 10px 20px;
           border-radius: 8px;
           cursor: pointer;
           font-weight: 600;
           text-decoration: none;
           transition: all 0.3s ease;
       }
       .back-btn:hover {
           background: rgba(255,215,0,0.2);
           transform: translateY(-2px);
       }
   </style>
</head>
<body>
   <a href="javascript:window.close()" class="back-btn">← Back to Games</a>
   <div class="container">
       <h1>Request a Game</h1>
       <div class="form-container">
           <div class="powr-form-builder" id="ec881caf_1765587411"></div>
           <script src="https://www.powr.io/powr.js?platform=html"></script>
       </div>
   </div>
</body>
</html>`;
          const win = window.open('about:blank', '_blank');
          if (win) {
              win.document.open();
              win.document.write(html);
              win.document.close();
          }
      });
  }

  let db = null;
  const firebaseReadyCallbacks = [];
  function onFirebaseReady(callback) {
      if (typeof callback !== 'function') return;
      if (db) {
          callback();
      } else {
          firebaseReadyCallbacks.push(callback);
      }
  }
  function notifyFirebaseReady() {
      while (firebaseReadyCallbacks.length) {
          const readyCallback = firebaseReadyCallbacks.shift();
          try {
              readyCallback();
          } catch (error) {
              console.error('Firebase ready callback error:', error);
          }
      }
  }
  
  // Initialize Firebase when SDK is ready
  console.time('firebaseInit');
  let firebaseInitAttempts = 0;
  const MAX_FIREBASE_INIT_ATTEMPTS = 50; // 5 seconds max (50 * 100ms)
  let firebaseConnectionState = 'disconnected';
  let connectionCheckInterval = null;
  if (backendApi) {
    db = backendApi.database();
    firebaseConnectionState = 'connected';
    notifyFirebaseReady();
    console.timeEnd('firebaseInit');
  }

  function initializeFirebase() {
    if (firebaseInitAttempts === 0) {
      console.time('firebaseInit');
    }
    if (backendApi) {
      firebaseConnectionState = 'connected';
      if (!db) db = backendApi.database();
      notifyFirebaseReady();
      console.timeEnd('firebaseInit');
      return;
    }
    firebaseInitAttempts++;

    // Check if Firebase SDK is loaded
    if (typeof firebase === 'undefined') {
      if (firebaseInitAttempts < MAX_FIREBASE_INIT_ATTEMPTS) {
        setTimeout(initializeFirebase, 100);
      } else {
        console.warn('Firebase SDK failed to load after multiple attempts. Running in offline mode.');
        firebaseConnectionState = 'offline';
        db = null;
        console.timeEnd('firebaseInit');
      }
      return;
    }

    try {
      // Check if Firebase is already initialized
      if (firebase.apps.length === 0) {
        firebase.initializeApp(firebaseConfig);
      }
      db = firebase.database();
      firebaseConnectionState = 'connecting';
      console.log('Firebase initialized successfully');
      notifyFirebaseReady();

      // Set up connection monitoring
      setupFirebaseConnectionMonitoring();

      // Test connection (only if db is available)
      if (db) {
        try {
          db.ref('.info/connected').once('value', (snapshot) => {
            if (snapshot.val() === true) {
              firebaseConnectionState = 'connected';
              console.log('Firebase connected');
              console.timeEnd('firebaseInit');
            } else {
              firebaseConnectionState = 'disconnected';
              console.warn('Firebase not connected, using offline mode');
              console.timeEnd('firebaseInit');
            }
          }).catch(err => {
            firebaseConnectionState = 'error';
            console.warn('Firebase connection test failed:', err);
            console.warn('Running in offline mode - some features may be limited');
            console.timeEnd('firebaseInit');
          });
        } catch (err) {
          firebaseConnectionState = 'error';
          console.warn('Firebase connection test error:', err);
          console.timeEnd('firebaseInit');
        }
      }
    } catch (error) {
      firebaseConnectionState = 'error';
      console.error('Firebase initialization error:', error);
      console.warn('Running in offline mode - some features may be limited');
      db = null;
      console.timeEnd('firebaseInit');
    }
  }
  
  // Firebase connection monitoring and recovery
  function setupFirebaseConnectionMonitoring() {
    if (!db) return;

    // Monitor connection state
    db.ref('.info/connected').on('value', (snapshot) => {
      const connected = snapshot.val();
      const previousState = firebaseConnectionState;

      if (connected === true) {
        firebaseConnectionState = 'connected';
        if (previousState !== 'connected') {
          console.log('Firebase reconnected');
          // Reinitialize features that depend on connection
          reinitializeFirebaseFeatures();
        }
      } else {
        firebaseConnectionState = 'disconnected';
        if (previousState === 'connected') {
          console.warn('Firebase disconnected - switching to offline mode');
        }
      }
    });

    // Periodic connection health check
    connectionCheckInterval = setInterval(() => {
      if (db && firebaseConnectionState === 'connected') {
        // Quick ping to ensure connection is still healthy
        db.ref('.info/serverTimeOffset').once('value').then(() => {
          // Connection is healthy
        }).catch(err => {
          console.warn('Firebase connection health check failed:', err);
          firebaseConnectionState = 'error';
        });
      }
    }, 30000); // Check every 30 seconds
  }

  // Reinitialize features when connection is restored
  function reinitializeFirebaseFeatures() {
    try {
      if (typeof chatInitialized === 'undefined') {
        return;
      }
      // Reinitialize visitor counter if needed
      // Online presence now handled via heartbeat, not Firebase refs
      if (totalRef) {
        updateCounter();
      }

      // Reinitialize chat if it was initialized
      if (chatInitialized && db) {
        // Chat listeners should automatically reconnect, but we can log it
        console.log('Chat connection restored');
      }

      console.log('Firebase features reinitialized after reconnection');
    } catch (error) {
      console.error('Error reinitializing Firebase features:', error);
    }
  }

  // Cleanup function for page unload
  function cleanupOnUnload() {
      try {
          // Clean up Firebase listeners
          cleanupChatListeners();

          // Clean up Firebase connection monitoring
          if (connectionCheckInterval) {
              clearInterval(connectionCheckInterval);
              connectionCheckInterval = null;
          }

          // Clean up animation frames
          // Note: Canvas animations should already be cleaned up by their own pause logic

          // Clean up presence (heartbeat-based, no Firebase online refs)
          if (backendApi && chatBackendReady) {
              backendApi.stopTypingIndicator();
          }
          if (backendApi) {
              // Stop heartbeat presence (handles offline gracefully)
              stopBackendPresence();
          }

      } catch (error) {
          console.error('Error during cleanup:', error);
      }
  }

  // Performance monitoring (can be enabled for debugging)
  let performanceMonitor = {
      enabled: false,
      fps: 0,
      frameCount: 0,
      lastTime: performance.now(),
      memoryUsage: null,

      start: function() {
          this.enabled = true;
          this.lastTime = performance.now();
          this.frameCount = 0;
          this.monitor();
      },

      stop: function() {
          this.enabled = false;
      },

      monitor: function() {
          if (!this.enabled) return;

          const now = performance.now();
          this.frameCount++;

          // Calculate FPS every second
          if (now - this.lastTime >= 1000) {
              this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
              this.frameCount = 0;
              this.lastTime = now;

              // Check memory usage if available
              if (performance.memory) {
                  this.memoryUsage = {
                      used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                      total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                      limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                  };
              }

              console.log(`[Performance] FPS: ${this.fps}${this.memoryUsage ? ` | Memory: ${this.memoryUsage.used}MB/${this.memoryUsage.total}MB` : ''} | Firebase: ${firebaseConnectionState}`);
          }

          requestAnimationFrame(() => this.monitor());
      }
  };

  // Enable performance monitoring in development (can be triggered manually)
  // Uncomment the next line to enable: performanceMonitor.start();

  // Set up cleanup using pagehide/visibilitychange (no unload to satisfy permissions policy)
  window.addEventListener('pagehide', cleanupOnUnload);
  document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') cleanupOnUnload();
  });

  // ================= Security & Anti-Abuse System =================
  const SecuritySystem = {
      // Whitelist for known legitimate scripts and domains
      whitelist: {
          domains: [
              'firebaseio.com',
              'googleapis.com',
              'gstatic.com',
              'googletagmanager.com',
              'google-analytics.com',
              'doubleclick.net',
              'googlesyndication.com',
              'facebook.com',
              'facebook.net',
              'twitter.com',
              'linkedin.com',
              'youtube.com',
              'vimeo.com'
          ],
          functions: [
              'setTimeout',
              'setInterval',
              'clearTimeout',
              'clearInterval',
              'requestAnimationFrame',
              'cancelAnimationFrame'
          ]
      },

      // Rate limiting
      requestTracker: new Map(),
      blockedIPs: new Set(),
      suspiciousPatterns: new Set(),

      // Rate limiting configuration
      rateLimits: {
          firebaseRequests: { max: 100, window: 60000 }, // 100 requests per minute
          chatMessages: { max: 10, window: 30000 }, // 10 messages per 30 seconds
          gameLoads: { max: 50, window: 60000 }, // 50 game loads per minute
          apiCalls: { max: 200, window: 60000 } // 200 API calls per minute
      },

      // Initialize security system
      init: function() {
          this.setupRequestInterception();
          this.setupInputValidation();
          this.loadBlockedIPs();
          this.startSecurityMonitoring();
          console.log('Security system initialized');
      },

      // Intercept and monitor all requests
      setupRequestInterception: function() {
          const originalFetch = window.fetch;
          const originalXMLHttpRequest = window.XMLHttpRequest;

          // Override fetch
          window.fetch = async function(...args) {
              const url = args[0];
              if (SecuritySystem.shouldBlockRequest(url)) {
                  console.warn('Blocked suspicious request:', url);
                  throw new Error('Request blocked by security system');
              }

              SecuritySystem.trackRequest('apiCalls', url);
              return originalFetch.apply(this, args);
          };

          // Override XMLHttpRequest
          window.XMLHttpRequest = function() {
              const xhr = new originalXMLHttpRequest();
              const originalOpen = xhr.open;
              xhr.open = function(method, url) {
                  if (SecuritySystem.shouldBlockRequest(url)) {
                      console.warn('Blocked suspicious XMLHttpRequest:', url);
                      throw new Error('Request blocked by security system');
                  }
                  SecuritySystem.trackRequest('apiCalls', url);
                  return originalOpen.apply(this, arguments);
              };
              return xhr;
          };
      },

      // Check if request should be blocked
      shouldBlockRequest: function(url) {
          // Only block clearly malicious URLs, not legitimate ones
          const maliciousPatterns = [
              /javascript:\s*eval/i,
              /vbscript:/i,
              /data:text\/html.*<script/i,
              /data:text\/javascript.*eval/i,
              /blob:.*eval/i
          ];

          if (typeof url === 'string') {
              // Allow common legitimate domains
              const allowedDomains = [
                  'firebaseio.com',
                  'googleapis.com',
                  'gstatic.com',
                  'googletagmanager.com',
                  'google-analytics.com',
                  'doubleclick.net',
                  'googlesyndication.com'
              ];

              // Check if it's a legitimate domain
              try {
                  const urlObj = new URL(url);
                  if (this.whitelist.domains.some(domain => urlObj.hostname.includes(domain))) {
                      return false;
                  }
              } catch (e) {
                  // Invalid URL, check for malicious patterns
              }

              // Check for malicious patterns
              for (const pattern of maliciousPatterns) {
                  if (pattern.test(url)) {
                      this.suspiciousPatterns.add(url);
                      return true;
                  }
              }
          }

          return false;
      },

      // Track requests for rate limiting
      trackRequest: function(type, url) {
          if (!this.rateLimits[type]) return;

          const now = Date.now();
          const key = `${type}_${this.getClientIP()}`;

          if (!this.requestTracker.has(key)) {
              this.requestTracker.set(key, []);
          }

          const requests = this.requestTracker.get(key);
          // Remove old requests outside the window
          const windowStart = now - this.rateLimits[type].window;
          const recentRequests = requests.filter(time => time > windowStart);

          if (recentRequests.length >= this.rateLimits[type].max) {
              console.warn(`Rate limit exceeded for ${type}, blocking request`);
              this.blockIP(this.getClientIP(), `Rate limit exceeded for ${type}`);
              return false;
          }

          recentRequests.push(now);
          this.requestTracker.set(key, recentRequests);
          return true;
      },

      // Get approximate client IP (limited on client-side)
      getClientIP: function() {
          // This is a simplified version - in reality you'd need server-side help
          return 'client_' + (navigator.userAgent + navigator.language + screen.width + screen.height).slice(0, 50);
      },

      // Block an IP/client
      blockIP: function(ip, reason) {
          this.blockedIPs.add(ip);
          localStorage.setItem('blocked_clients', JSON.stringify(Array.from(this.blockedIPs)));
          console.warn(`Client blocked: ${ip}, reason: ${reason}`);

          // Show warning to user (only if notifications is available)
          try {
              if (window.notifications && typeof window.notifications.show === 'function') {
                  window.notifications.show('Access temporarily restricted due to suspicious activity', 'error', 5000);
              }
          } catch (e) {
              // Silently fail if notifications not available yet
          }
      },

      // Load blocked IPs from storage
      loadBlockedIPs: function() {
          try {
              const blocked = localStorage.getItem('blocked_clients');
              if (blocked) {
                  this.blockedIPs = new Set(JSON.parse(blocked));
              }
          } catch (e) {
              console.error('Error loading blocked clients:', e);
          }
      },

      // Input validation and sanitization
      setupInputValidation: function() {
          // Only override truly dangerous functions, not common browser APIs
          const dangerousFunctions = ['eval', 'Function'];

          dangerousFunctions.forEach(func => {
              if (window[func] && typeof window[func] === 'function') {
                  const original = window[func];
                  window[func] = function(...args) {
                      // Check for suspicious code patterns
                      const code = args.join('');
                      if (SecuritySystem.containsSuspiciousCode(code)) {
                          console.error(`Blocked suspicious ${func} call`);
                          SecuritySystem.blockIP(SecuritySystem.getClientIP(), `Suspicious ${func} usage`);
                          return;
                      }
                      return original.apply(this, args);
                  };
              }
          });

          // Monitor setTimeout/setInterval for malicious patterns only (whitelist common usage)
          ['setTimeout', 'setInterval'].forEach(func => {
              if (window[func] && typeof window[func] === 'function') {
                  const original = window[func];
                  window[func] = function(...args) {
                      // Only check string code, not function references
                      const code = args[0];
                      if (typeof code === 'string' && code.length > 0 && SecuritySystem.containsMaliciousCode(code)) {
                          console.error(`Blocked malicious ${func} call`);
                          SecuritySystem.blockIP(SecuritySystem.getClientIP(), `Malicious ${func} usage`);
                          return;
                      }
                      return original.apply(this, args);
                  };
              }
          });
      },

      // Check for suspicious code patterns (less aggressive)
      containsSuspiciousCode: function(code) {
          const patterns = [
              /eval\s*\(/i,
              /Function\s*\(\s*['"]/i,
              /document\.cookie\s*=/i,
              /atob\s*\(\s*['"]/i,
              /btoa\s*\(\s*['"]/i,
              /crypto\./i,
              /WebSocket\s*\(/i,
              /postMessage\s*\(/i,
              /XMLHttpRequest\s*\(\s*\)\s*\.\s*open\s*\(\s*['"]POST['"]/i
          ];

          return patterns.some(pattern => pattern.test(code));
      },

      // Check for truly malicious code patterns (more specific)
      containsMaliciousCode: function(code) {
          const maliciousPatterns = [
              // XSS attempts
              /<script[^>]*>.*?<\/script>/gi,
              /javascript:\s*eval/i,
              /vbscript:/i,
              /onload\s*=\s*['"]\s*eval/i,
              /onerror\s*=\s*['"]\s*eval/i,
              // Code injection
              /document\.write\s*\(\s*['"]/i,
              /innerHTML\s*\+=\s*['"]/i,
              // Cookie theft
              /document\.cookie\s*=\s*['"]/i,
              // Malicious redirects
              /location\.href\s*=\s*['"]\s*http/i,
              // Base64 encoded scripts
              /atob\s*\(\s*['"][A-Za-z0-9+/=]{100,}/i
          ];

          return maliciousPatterns.some(pattern => pattern.test(code));
      },

      // Security monitoring
      startSecurityMonitoring: function() {
          // Monitor for unusual activity
          setInterval(() => {
              this.performSecurityCheck();
          }, 30000); // Check every 30 seconds

          // Monitor console for suspicious activity (less intrusive)
              const originalConsole = console;
              ['log', 'warn', 'error'].forEach(method => {
                  const original = originalConsole[method];
                  originalConsole[method] = function(...args) {
                      // Only check for obvious sensitive data patterns
                      const message = args.join(' ');
                      if (/\b(password|token|key|secret|apikey)\s*[:=]\s*['"]\w+/i.test(message)) {
                          console.warn('Potential sensitive data logging detected');
                      }
                      return original.apply(this, args);
                  };
              });
      },

      // Perform security checks
      performSecurityCheck: function() {
          // Check for excessive memory usage (potential memory leak attacks)
          if (performance.memory) {
              const memoryUsage = performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize;
              if (memoryUsage > 0.9) {
                  console.warn('High memory usage detected, potential memory attack');
                  this.blockIP(this.getClientIP(), 'High memory usage');
              }
          }

          // Check for excessive Firebase requests
          const firebaseRequests = Array.from(this.requestTracker.entries())
              .filter(([key]) => key.startsWith('firebaseRequests_'))
              .reduce((total, [, requests]) => total + requests.length, 0);

          if (firebaseRequests > 500) {
              console.warn('Excessive Firebase requests detected');
              this.blockIP(this.getClientIP(), 'Excessive Firebase requests');
          }

          // Clean up old request tracking data
          const now = Date.now();
          for (const [key, requests] of this.requestTracker.entries()) {
              const recentRequests = requests.filter(time => now - time < 300000); // Keep last 5 minutes
              if (recentRequests.length === 0) {
                  this.requestTracker.delete(key);
              } else {
                  this.requestTracker.set(key, recentRequests);
              }
          }
      },

      // CSRF protection
      generateCSRFToken: function() {
          return btoa(Math.random().toString()).substr(10, 15);
      },

      // Bot detection
      detectBot: function() {
          const indicators = [
              navigator.webdriver, // Selenium, Puppeteer, etc.
              navigator.plugins.length === 0, // Headless browsers
              navigator.languages.length === 0,
              window.outerHeight === 0,
              window.outerWidth === 0,
              /HeadlessChrome/.test(navigator.userAgent),
              /PhantomJS/.test(navigator.userAgent),
              /Selenium/.test(navigator.userAgent)
          ];

          return indicators.some(indicator => indicator);
      }
  };

  // Disable aggressive bot/memory blocking for now (frontend testing)
  // setTimeout(() => SecuritySystem.init(), 100);
  // if (SecuritySystem.detectBot()) {
  //     console.warn('Bot-like behavior detected');
  //     SecuritySystem.blockIP(SecuritySystem.getClientIP(), 'Bot detection');
  // }

  // Start initialization (backend only; no Firebase fallback)
  if (backendApi) {
      db = backendApi.database();
      firebaseConnectionState = 'connected';
      notifyFirebaseReady();
  } else {
      firebaseConnectionState = 'disconnected';
      notifyFirebaseReady();
      console.warn('Backend not available; running in frontend-only mode.');
  }

  // Initial visitor count constant
  const INITIAL_VISITOR_COUNT = 127349;

  // Firebase references (initialized when Firebase is ready)
  let totalRef = null;
  // Removed onlineDbRef - using heartbeat presence instead (no Firebase online/offline refs)
  // let onlineDbRef = null;

  // Increment visitor count on every page load (including refreshes)
  onFirebaseReady(() => {
    if (!db) return;

    // Initialize references now that db is available
    totalRef = db.ref('totalVisitors');
    // Removed: onlineDbRef = db.ref('online');
    // Online presence now handled via heartbeat (startBackendPresence)

    // Increment total visitor count
    totalRef.transaction(val => {
        const currentVal = val || INITIAL_VISITOR_COUNT;
        // If count is less than initial, set to initial first
        if (currentVal < INITIAL_VISITOR_COUNT) {
            return INITIAL_VISITOR_COUNT + 1;
        }
        return currentVal + 1;
    }).catch(error => {
        console.error('Error updating visitor count:', error);
    });

    // Start listening for changes to update the display
    updateCounter();
  });
  
  // Static game category mapping (hardcoded in codebase)
  // Maps game titles to their assigned categories
  const STATIC_GAME_CATEGORIES = {
    "2 Player Crazy Racer": "racing",
    "8 Ball Pool Billiard": "puzzle",
    "Agent Smith": "shooting",
    "Airplane Racer": "racing",
    "Alien Sky Invasion": "adventure",
    "American Touchdown": "sports",
    "Apocalypse Truck": "action",
    "Archer Hero": "strategy",
    "ArmedForces.io": "shooting",
    "Army Combat": "shooting",
    "Army Driver": "action",
    "ATV Highway Traffic": "racing",
    "Baby Beauty Salon": "simulation",
    "Bandits Multiplayer PvP": "action",
    "Basket Hoop": "sports",
    "Basketball io": "sports",
    "Basketball King": "sports",
    "Basketball Slam Dunk": "sports",
    "Battle Royale Simulator": "simulation",
    "Beat Rush": "action",
    "Block Blast": "puzzle",
    "Block Builder Survival": "adventure",
    "Block World": "adventure",
    "Blocky Blast": "none",
    "Blocky Parkour Ninja": "strategy",
    "Burnout City": "racing",
    "Burnout Drift Hunter": "racing",
    "Bus Subway Runner": "action",
    "Cake Match Puzzle": "puzzle",
    "Capybara Clicker Pro": "strategy",
    "Car Football": "action",
    "Car Wash": "simulation",
    "Cat Simulator": "simulation",
    "Chess FreezeNova": "strategy",
    "City Simulator": "simulation",
    "City Stunts": "action",
    "Click Master Pro": "simulation",
    "CobraZ.io Classic": "adventure",
    "Color Rush": "new",
    "Crazy Ball Adventures": "adventure",
    "Crazy Car Arena": "action",
    "Crazy Drifter": "racing",
    "Crazy Hill Climb": "strategy",
    "Crazy Karts": "action",
    "Crazy Moto Racing": "racing",
    "Crazy Parking Fury": "racing",
    "Crazy Stickman Physics": "action",
    "Cross the Road": "strategy",
    "Crown Defense": "strategy",
    "Curve Rush": "new",
    "Dark Ninja Hanjo": "action",
    "Darkness Survivors": "none",
    "Davo": "simulation",
    "Deer Hunter": "shooting",
    "Dino Chaos Idle": "none",
    "Dinosaur Game": "action",
    "Dockyard Tank Parking": "none",
    "Dont Fall io": "strategy",
    "Draw Here": "puzzle",
    "Draw the Bird Path": "puzzle",
    "Draw The Bridge": "strategy",
    "Draw the Car Path": "puzzle",
    "Draw the Truck Bridge": "none",
    "Drift Fury": "racing",
    "Drift Hunters Pro": "racing",
    "Drift King": "racing",
    "Drift Rider": "racing",
    "Edys Car Simulator": "racing",
    "Egg Car Racing": "racing",
    "Egg Helix": "strategy",
    "Escape Car": "adventure",
    "Escape Road": "new",
    "Evil Santa": "new",
    "F1 Drift Racer": "racing",
    "Farming Island": "adventure",
    "Fast Food Manager": "simulation",
    "Fast Food Rush": "simulation",
    "Find It": "puzzle",
    "Fire and Water": "puzzle",
    "First Day of School": "none",
    "Football King": "sports",
    "Formula 1 Driver": "racing",
    "Fort Drifter": "racing",
    "Four Colors": "puzzle",
    "FPS Strike": "shooting",
    "Fun Party Makeup": "simulation",
    "Funny Shooter Bro": "shooting",
    "Futuristic Racer": "racing",
    "Galactic Sniper": "shooting",
    "Geometry Dash Lite": "new",
    "Geometry Dasher Escape": "puzzle",
    "Geometry Dasher FreezeNova": "new",
    "Get On Top": "strategy",
    "Golf Hit": "new",
    "Guerrillas io": "shooting",
    "Head Basketball": "sports",
    "Head Soccer 2022": "sports",
    "Head Soccer Football": "sports",
    "Hero Dragon Power": "action",
    "Hero Rush Tower Defense": "strategy",
    "Highway Cars": "adventure",
    "Highway Moto": "adventure",
    "Highway Racer 2": "racing",
    "Highway Racer Pro": "racing",
    "Highway Traffic": "racing",
    "Hill Climb Cars": "none",
    "Holiday Clicker": "action",
    "Hook Wars": "action",
    "Hover Racer": "racing",
    "Hover Racer Pro": "racing",
    "Idle Dev Startup": "simulation",
    "Idle Restaurant": "simulation",
    "Italian Brainrot Clicker 2": "new",
    "Jacks Village": "adventure",
    "Jeep Driver": "action",
    "Jeep Racing": "racing",
    "Jul Moto Racing ": "racing",
    "Julie Beauty Salon": "simulation",
    "Kawaii Shooter": "shooting",
    "Kick the Alien": "action",
    "Kick The Dummy": "adventure",
    "Kick the Pirate": "none",
    "Kick the Zombie": "action",
    "Kingdom Attack": "adventure",
    "Kingdom Battle 3D": "action",
    "Kings io": "strategy",
    "Legendary Sniper": "shooting",
    "Legends Arena": "none",
    "Limousine Simulator": "simulation",
    "Love Tester": "simulation",
    "Love Tester Story": "simulation",
    "Mad Doctor": "strategy",
    "Madalin Stunt Cars Pro": "action",
    "Mafia Getaway Cars": "racing",
    "Mahjong": "strategy",
    "Masked Forces Zombie Survival": "shooting",
    "Masked Special Forces": "shooting",
    "Mech Shooter": "shooting",
    "Mini Cars Racing": "racing",
    "Mini Shooters": "shooting",
    "Mob City": "shooting",
    "Monster Survivors": "adventure",
    "Monster Truck Booster": "racing",
    "Monster Truck City Parking": "action",
    "Monster Truck Mountain Climb": "racing",
    "Monster Truck Race Arena": "racing",
    "Monster Truck Racing": "action",
    "Moto Trials": "action",
    "Motorbike Stunt Simulator": "simulation",
    "Motorbike Traffic": "racing",
    "Mr Space Bullet": "shooting",
    "Music Battle 3D": "simulation",
    "Night Shift Security": "puzzle",
    "Nova Billiard": "puzzle",
    "Nova Clicker": "simulation",
    "Nova Craft": "adventure",
    "Nuts and Bolts Puzzle": "puzzle",
    "Offroad Rally": "adventure",
    "Owl and Rabbit Fashion": "none",
    "Paradise Girls": "none",
    "Paw Clicker": "action",
    "Perfect First Date": "simulation",
    "Pets Beauty Salon": "simulation",
    "Pinball Simulator": "simulation",
    "Pixel Driver": "action",
    "Police Chase Drifter": "action",
    "Police Traffic": "racing",
    "Poop Clicker": "simulation",
    "Powerslide Kart Simulator": "simulation",
    "Precision Sniper": "shooting",
    "Princess Beauty Salon": "none",
    "Princess Influencer Salon": "simulation",
    "Princesses Prom Night": "simulation",
    "Pyramid Solitaire": "puzzle",
    "Racing Cars": "racing",
    "Racing Cars 2": "racing",
    "Real Flight Simulator": "simulation",
    "Rescue Helicopter": "adventure",
    "Retro Bowl": "new",
    "Romantic Secret Kiss": "simulation",
    "Rome Simulator": "strategy",
    "Rooftop Duel": "shooting",
    "Run 3 Space": "new",
    "Secret Sniper Agent": "shooting",
    "Shortcut Race": "racing",
    "Skateboard Marathon": "action",
    "Skibidi Toilet io": "simulation",
    "Slime Rancher": "action",
    "Clash Royale": "strategy",
    "Slope Rider": "new",
    "Snake": "simulation",
    "Snake Football": "sports",
    "Snake Wars": "action",
    "Solitaire": "strategy",
    "Solitaire Adventure": "puzzle",
    "Soul Essence Adventure": "adventure",
    "Space Crew Mystery": "action",
    "SpartaHoppers": "simulation",
    "Speed Drift Racing": "racing",
    "Speedrun Parkour": "strategy",
    "Squid Race Simulator": "racing",
    "Stack Fire Ball": "strategy",
    "State io Wars": "adventure",
    "Steal Brainrots": "new",
    "Stick Guys Defense": "strategy",
    "Stickman City Adventure": "simulation",
    "Stickman Destruction": "action",
    "Stickman Parkour": "action",
    "Storm City Mafia": "shooting",
    "Stunt Simulator 2": "simulation",
    "Subway Idle 3D": "simulation",
    "Super Car Driving": "action",
    "Super Mini Racing": "racing",
    "Supercars Drift": "racing",
    "Survival Craft": "strategy",
    "Survival Island": "adventure",
    "Survival Karts": "racing",
    "Sweet Sugar Match": "none",
    "Tactical Shooter Online": "shooting",
    "Tank Arena": "action",
    "Tank Racing": "racing",
    "Tap Road": "new",
    "Taxi Simulator": "simulation",
    "The Farmer": "simulation",
    "Tile Match": "puzzle",
    "Tiny Crash Fighters": "action",
    "ToonZ io": "shooting",
    "Tractor Farming Simulator": "simulation",
    "Traffic Road": "new",
    "Train Racing": "racing",
    "Trains io": "simulation",
    "Treasure Hunter": "none",
    "Troll Level": "puzzle",
    "Truck Racing": "racing",
    "Undead Corridor": "shooting",
    "Unicorn Beauty Salon": "none",
    "Urban Sniper": "shooting",
    "Wacky Flip": "new",
    "War of Ships io": "strategy",
    "War Simulator": "simulation",
    "WarStrike": "shooting",
    "Wasteland Shooters": "shooting",
    "Wedding Beauty Salon": "simulation",
    "Witch Beauty Salon": "simulation",
    "Zombie Road": "action",
    "Zombie Sniper": "shooting",
    "Zombie War Defense": "action"
  };
  
  // Initialize game categories from static mapping
  // This ensures categories are available for all users without Firebase/localStorage
  let gameCategories = {};

  // Load game categories from static mapping
  function initializeGameCategories() {
    console.time('gameCategoriesInit');
    // Convert static title-based mapping to embed-based mapping for lookup
    // We'll need to match by title when categorizing
    gameCategories = STATIC_GAME_CATEGORIES;
    console.log('Game categories initialized from static mapping');
    console.timeEnd('gameCategoriesInit');
    
    // Re-categorize if games are already loaded
    if (typeof categorizeAllGames === 'function' && typeof gameSites !== 'undefined' && gameSites && gameSites.length > 0) {
      categorizeAllGames();
      if (document.getElementById('featuredGamesSections')) {
        renderFeaturedSections();
      }
    }
  }
  
  // Generate a unique visitor ID (persistent across sessions) and keep it Firebase-safe
  let visitorId = (backendApi && backendApi.visitorId) || localStorage.getItem('visitorId') || sessionStorage.getItem('visitorId');
  if (visitorId) {
    const sanitized = visitorId.replace(/[.#$\[\]]/g, '_');
    if (sanitized !== visitorId) {
      console.warn('Resetting invalid visitorId', visitorId);
      visitorId = sanitized;
    }
  }
  if (!visitorId) {
    visitorId = createVisitorId();
  }
  try { localStorage.setItem('visitorId', visitorId); } catch (e) {}
  try { sessionStorage.setItem('visitorId', visitorId); } catch (e) {}
  if (backendApi) {
    backendApi.visitorId = visitorId;
  }
  console.log('Visitor ID:', visitorId);
  let backendPresenceInterval = null;
  let backendPresenceStarted = false;

  function startBackendPresence() {
      if (!backendApi || !visitorId || backendPresenceStarted) return;
      backendPresenceStarted = true;
      const ping = () => backendApi.setOnline(visitorId, username || 'Anonymous').catch(() => {});
      ping();
      backendApi.incrementVisitors().catch(() => {});
      backendPresenceInterval = setInterval(ping, 20000);
  }

  function stopBackendPresence() {
      if (backendPresenceInterval) {
          clearInterval(backendPresenceInterval);
          backendPresenceInterval = null;
      }
      if (backendApi && visitorId) {
          backendApi.setOffline(visitorId).catch(() => {});
      }
      backendPresenceStarted = false;
  }

  // Load profile from backend if available to avoid re-prompting existing users
  async function loadBackendProfile() {
      if (!backendApi || backendFriendsDisabled || SOCIAL_FEATURES_ENABLED === false) return;
      try {
          const existing = await backendApi.getUserProfile(visitorId);
          if (existing && (existing.username || existing.avatar || existing.avatarImage)) {
              userProfile = {
                  ...createDefaultUserProfile(),
                  ...userProfile,
                  ...existing,
                  profileCreated: true
              };
              try { localStorage.setItem('userProfile', JSON.stringify(userProfile)); } catch (_) {}
              updateProfileDisplay();
          }
      } catch (err) {
          console.warn('Could not load backend profile', err);
          if (String(err).includes('404')) {
              disableBackend('profile endpoint missing (404)');
          }
      }
  }

  // Basic profile defaults (needed before any backend pre-connect)
  let userProfileData = JSON.parse(localStorage.getItem('userProfile')) || { profileCreated: false };
  let username = (userProfileData.profileCreated && userProfileData.username) ? userProfileData.username : ('Guest' + Math.floor(Math.random()*1000));
  let userColor = ['#007bff','#ff4500','#32cd32','#ffa500','#9932cc'][Math.floor(Math.random()*5)];
  if (backendApi) {
      startBackendPresence();
  }

  // Warm up backend connection early so chat/online data is ready before opening chat
  console.time('backendInit');
  if (backendApi) {
      ensureBackendChatConnection(username).catch(err => {
          console.warn('Backend preconnect failed:', err?.message || err);
      }).finally(() => {
          console.timeEnd('backendInit');
          if (typeof window.markBackendReady === 'function') window.markBackendReady();
          loadBackendProfile();
      });
  } else {
      console.timeEnd('backendInit');
  }

  // Set online presence and ensure initial visitor count once Firebase is ready
  onFirebaseReady(() => {
    if (!db) return;

    // Online presence now handled via heartbeat (startBackendPresence)
    // Removed Firebase online/offline refs to avoid backend errors

    // Ensure visitor count never drops below INITIAL_VISITOR_COUNT
    db.ref('totalVisitors').once('value').then(snap => {
      const currentCount = snap.val() || 0;
      if (currentCount < INITIAL_VISITOR_COUNT) {
        db.ref('totalVisitors').set(INITIAL_VISITOR_COUNT).catch(error => {
          console.error('Error setting initial visitor count:', error);
        });
      }
    }).catch(error => {
      console.error('Error checking visitor count:', error);
    });
  });
  // Initialize games arrays early to avoid temporal dead zone issues
  let gameSites = [];
  let allGamesFromJSON = [];
  let categorizedGames = {};
  let gameStats = {};
  let gameStatsListener = null;
  let gameRatings = {};
  let gameRatingsListener = null;
  let backendFriendsDisabled = false;
  if (SOCIAL_FEATURES_ENABLED === false) {
      backendFriendsDisabled = true;
  }

  // Helper: build game page path from title
  function getGamePagePathFromTitle(title) {
      if (!title) return null;
      const slug = String(title).toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
      if (!slug) return null;
      const filename = `game-${slug}.html`;
      const inPages = window.location.pathname.includes('/pages/') || window.location.pathname.includes('/games/');
      return inPages ? `../games/${filename}` : `games/${filename}`;
  }

  // Helper: pick a random playable game from gameSites
  function getRandomPlayableGame() {
      console.log('[RandomGame Debug] getRandomPlayableGame invoked');
      let source = Array.isArray(gameSites) && gameSites.length > 0 ? gameSites : [];
      if (source.length === 0 && Array.isArray(allGamesFromJSON) && allGamesFromJSON.length > 0) {
          source = allGamesFromJSON;
      }
      if (source.length === 0) {
          console.warn('[RandomGame Debug] No game sources available yet.');
          return null;
      }

      const isValidTarget = (value) => {
          const s = String(value || '').trim();
          if (!s) return false;
          if (s.startsWith('#')) return false;
          if (s.toLowerCase().startsWith('javascript:')) return false;
          try {
              new URL(s, window.location.href);
              return true;
          } catch (_) {
              return false;
          }
      };

      const playable = source.filter(g => {
          if (!g || isDisabledGame(g)) return false;
          // Accept if we have an embed or we can build a local page path from title
          const gamePath = getGamePagePathFromTitle(g.title);
          if (gamePath && isValidTarget(gamePath)) return true;
          if (g.embed && isValidTarget(g.embed)) return true;
          return false;
      });
      console.log('[RandomGame Debug] Playable count:', playable.length, 'from', source.length);
      if (playable.length === 0) {
          console.warn('[RandomGame Debug] No playable games found after filtering.');
          return null;
      }
      const idx = Math.floor(Math.random() * playable.length);
      return playable[idx];
  }

  // Wire up the main Random Game button
  function initRandomGameButton() {
      const randomGameBtn = document.getElementById('randomGameBtn');
      if (!randomGameBtn || randomGameBtn.hasAttribute('data-handler-attached')) return;
      randomGameBtn.setAttribute('data-handler-attached', 'true');
      randomGameBtn.addEventListener('click', async (e) => {
          console.log('[RandomGame Debug] Button clicked', {
              gameSitesLen: Array.isArray(gameSites) ? gameSites.length : 'n/a',
              allGamesFromJSONLen: Array.isArray(allGamesFromJSON) ? allGamesFromJSON.length : 'n/a'
          });
          if (e) {
              e.preventDefault();
              e.stopPropagation();
          }
          // Prevent multiple rapid clicks (but don't rely on the disabled state for navigation)
          const now = Date.now();
          const lastTs = Number(randomGameBtn.dataset.lastClickTs || 0) || 0;
          if (now - lastTs < 600) return;
          randomGameBtn.dataset.lastClickTs = String(now);

          let game = null;
          try {
              game = getRandomPlayableGame();
          } catch (err) {
              console.error('[RandomGame Debug] Error during getRandomPlayableGame:', err);
          }
          console.log('[RandomGame Debug] Initial pick:', game);

          // If games aren't loaded yet, try to load them on-demand
          if (!game && typeof loadGamesFromJSON === 'function') {
              try {
                  console.log('[RandomGame Debug] Loading games JSON on-demand');
                  await loadGamesFromJSON();
                  game = getRandomPlayableGame();
                  console.log('[RandomGame Debug] Pick after loading JSON:', game);
              } catch (err) {
                  console.error('Failed to load games for random pick:', err);
              }
          }

          if (!game) {
              alert('No games available right now. Please try again in a moment.');
              console.warn('[RandomGame Debug] No game selected even after JSON load attempt.');
              return;
          }
          const gamePath = getGamePagePathFromTitle(game.title);
          console.log('[RandomGame Debug] Target title:', game.title, 'Path:', gamePath, 'Embed:', game.embed);
          // Use the same navigation path as clicking a game tile (reliable even with popup blockers/sandbox wrappers)
          try {
              if (typeof openGamePageOrInline === 'function' && (game.embed || gamePath)) {
                  openGamePageOrInline(game.embed || gamePath, game.title || 'Game');
                  return;
              }
          } catch (err) {
              console.warn('[RandomGame Debug] openGamePageOrInline failed, falling back:', err);
          }

          // Fallback: navigate current tab directly
          const targetUrl = gamePath || game.embed;
          if (targetUrl) {
              try {
                  window.location.href = new URL(targetUrl, window.location.href).href;
              } catch (_) {
                  window.location.href = targetUrl;
              }
          }
      });
  }

  // Mobile sidebar toggle functionality
  document.addEventListener('DOMContentLoaded', function() {
      const mobileMenuBtn = document.getElementById('mobileMenuBtn');
      const categorySidePanel = document.getElementById('categorySidePanel');

      if (mobileMenuBtn && categorySidePanel) {
          mobileMenuBtn.addEventListener('click', function() {
              categorySidePanel.classList.toggle('open');
          });
      }
  });
  
  // Pagination for all-games page
  let gamesDisplayedCount = 0;
  let allGamesList = [];
  const GAMES_PER_PAGE = 50;
  
  // Chat Moderation System
  let bannedUsers = {};
  let userMessageCounts = {}; // Track message frequency for spam detection
  let lastMessageTime = {}; // Track last message time per user
  const MAX_MESSAGES_PER_MINUTE = 5; // Rate limit
  const MIN_TIME_BETWEEN_MESSAGES = 2000; // 2 seconds minimum between messages
  const SPAM_DETECTION_WINDOW = 60000; // 1 minute window
  
  // Profanity filter - common words (you can expand this list)
  let PROFANITY_WORDS = [];
  let moderationSettings = {
      profanityFilterEnabled: true,
      spamDetectionEnabled: true,
      rateLimitEnabled: true,
      maxCapsRatio: 0.7,
      maxLinksPerMessage: 2,
      maxRepeatedChars: 4,
      maxMessagesPerMinute: 5,
      minTimeBetweenMessages: 2000
  };
  let moderationStats = {
      blockedMessages: 0,
      totalBans: 0,
      spamDetected: 0,
      activeUsers: 0
  };
  
  // Load moderation settings from Firebase
  if (db) {
      db.ref('moderationSettings').on('value', (snapshot) => {
          if (snapshot.exists()) {
              moderationSettings = { ...moderationSettings, ...snapshot.val() };
              updateModerationUI();
          }
      });
      
      db.ref('profanityWords').on('value', (snapshot) => {
          PROFANITY_WORDS = snapshot.val() || [];
          updateProfanityWordsList();
      });
      
      db.ref('moderationStats').on('value', (snapshot) => {
          if (snapshot.exists()) {
              moderationStats = { ...moderationStats, ...snapshot.val() };
              updateModerationStats();
          }
      });
  }
  
  // Check if message contains profanity (case-insensitive)
  function containsProfanity(text) {
      if (!moderationSettings.profanityFilterEnabled) return false;
      const lowerText = text.toLowerCase().trim();
      return PROFANITY_WORDS.some(word => {
          const lowerWord = word.toLowerCase().trim();
          if (!lowerWord) return false;
          // Check for whole word or as part of the text (case-insensitive)
          return lowerText.includes(lowerWord);
      });
  }
  
  // Check for spam patterns
  function isSpam(text) {
      if (!moderationSettings.spamDetectionEnabled) return false;
      
      // Check for repeated characters
      const repeatPattern = new RegExp(`(.)\\1{${moderationSettings.maxRepeatedChars},}`);
      if (repeatPattern.test(text)) return true;
      
      // Check for excessive caps
      if (text.length > 10) {
          const capsRatio = (text.match(/[A-Z]/g) || []).length / text.length;
          if (capsRatio > moderationSettings.maxCapsRatio) return true;
      }
      
      // Check for excessive links
      const linkCount = (text.match(/https?:\/\//g) || []).length;
      if (linkCount > moderationSettings.maxLinksPerMessage) return true;
      
      return false;
  }
  
  // Check rate limiting
  function checkRateLimit(uid) {
      if (!moderationSettings.rateLimitEnabled) return { allowed: true };
      
      const now = Date.now();
      const userMessages = userMessageCounts[uid] || [];
      
      // Remove messages outside the time window
      const recentMessages = userMessages.filter(time => now - time < SPAM_DETECTION_WINDOW);
      userMessageCounts[uid] = recentMessages;
      
      // Check if user is sending too many messages
      if (recentMessages.length >= moderationSettings.maxMessagesPerMinute) {
          return { allowed: false, reason: 'Too many messages. Please wait a moment.' };
      }
      
      // Check minimum time between messages
      const lastTime = lastMessageTime[uid] || 0;
      if (now - lastTime < moderationSettings.minTimeBetweenMessages) {
          return { allowed: false, reason: 'Please wait before sending another message.' };
      }
      
      return { allowed: true };
  }
  
  // Check if user is banned
  function isUserBanned(uid) {
      if (!bannedUsers[uid]) return false;
      const banData = bannedUsers[uid];
      
      // Check if ban has expired
      if (banData.expiresAt && Date.now() > banData.expiresAt) {
          delete bannedUsers[uid];
          if (db) {
              db.ref(`bannedUsers/${uid}`).remove();
          }
          return false;
      }
      
      return true;
  }

  async function refreshBannedUsersFromBackend() {
      if (!backendApi) return;
      try {
          const banned = await backendApi.getBannedUsers();
          const bannedMap = {};
          (banned || []).forEach(user => {
              if (user.uid) {
                  bannedMap[user.uid] = user;
              }
          });
          bannedUsers = bannedMap;
      } catch (error) {
          console.warn('Failed to refresh banned users from backend:', error);
      }
  }

  async function isUserBannedAsync(uid) {
      if (backendApi) {
          try {
              const banned = await backendApi.isBanned(uid);
              if (banned) return true;
          } catch (error) {
              console.warn('Backend ban check failed:', error);
          }
      }
      return isUserBanned(uid);
  }
  
  // Load banned users from Firebase
  if (db) {
      db.ref('bannedUsers').on('value', (snapshot) => {
          bannedUsers = snapshot.val() || {};
      });
  }
  
  // Utils object - must be defined before background effects and other features
  const Utils = {
    debounce: function(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    throttle: function(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
  };
  
  function updateCounter() {
      const onlineEl = document.getElementById('onlineCount');
      const totalEl = document.getElementById('totalCount');
      if (!onlineEl && !totalEl) return;

      // Prefer backend polling
      if (backendApi) {
        const pollCounters = async () => {
          try {
            if (onlineEl) {
              const onlineUsers = await backendApi.getOnlineUsers();
              onlineEl.textContent = Array.isArray(onlineUsers) ? onlineUsers.length : 0;
            }
            if (totalEl) {
              const total = await backendApi.getTotalVisitors();
              const totalVal = total?.totalVisitors || INITIAL_VISITOR_COUNT;
              totalEl.textContent = totalVal.toLocaleString();
            }
          } catch (err) {
            console.warn('Counter poll failed', err);
          }
        };
        pollCounters();
        if (counterPollInterval) clearInterval(counterPollInterval);
        counterPollInterval = setInterval(pollCounters, 5000);
        return;
      }

      // Legacy Firebase fallback - removed onlineDbRef to avoid backend errors
      // Online presence now handled via heartbeat (backendApi)
      if (!totalRef) return;
      
      // Online count will come from backend heartbeat system
      // If you need online count, query backend API instead of Firebase
      // For now, we only show total visitors (online count removed)

      totalRef.on('value', snap => {
        const total = snap.val() || INITIAL_VISITOR_COUNT;
        if (totalEl) {
          totalEl.textContent = total.toLocaleString();
        }
      });
    }
  
  // Format number with commas for display
  function formatNumber(num) {
    return num.toLocaleString();
  }
  var chatMessages = document.getElementById('chatMessages');
  let chatLoadingOverlay = null;
  const chatInput = document.getElementById('chatInput');
  const typingIndicator = document.getElementById('typingIndicator');
  // Prevent any chat forms from submitting and reloading the page (delegate in case chat is injected)
  document.addEventListener('submit', (e) => {
    if (e.target && (e.target.closest('#chatContainer') || e.target.closest('#fullscreenChatContainer'))) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, true);
  let typing = false;
  if (chatInput) {
      chatInput.addEventListener('input', () => {
          if (!typing) {
              typing = true;
          }
          if (backendApi) {
              ensureBackendChatConnection().then(connected => {
                  if (connected && backendApi) {
                      backendApi.setTypingIndicator();
                  }
              });
          } else if (db) {
              db.ref('chatTyping/'+visitorId).set(username).catch(error => console.error('Error setting typing:', error));
          }
          clearTimeout(stopTyping.timeout);
          stopTyping.timeout = setTimeout(stopTyping, 2000);
      });
  }
  function stopTyping(){
      typing = false;
      if (backendApi && chatBackendReady) {
          backendApi.stopTypingIndicator();
      } else if (db) {
          db.ref('chatTyping/'+visitorId).remove().catch(error => console.error('Error removing typing:', error));
      }
  }
  
  function updateTypingIndicatorText(names) {
      if (!typingIndicator) return;
      const list = (names || []).filter(name => name && name !== username);
      if (list.length > 0) {
          typingIndicator.innerText = list.join(', ') + ' is typing...';
      } else {
          typingIndicator.innerText = '';
      }
  }
  
  // Send message with moderation and security
  if (chatInput) {
      chatInput.addEventListener('keypress', e => {
          if(e.key === 'Enter' && chatInput.value.trim() !== ''){
              e.preventDefault();
              sendChatMessage(chatInput);
          }
      });
  }
  function escapeHtml(str = '') {
      return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
  }

  function linkifyText(text = '') {
      const escaped = escapeHtml(text);
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      return escaped.replace(urlRegex, (url) => {
          const safeUrl = url.replace(/"/g, '%22');
          return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" style="color:#FFD700; text-decoration:underline;">${safeUrl}</a>`;
      });
  }

  function renderChatMessage(msg, msgId, snapshot) {
      const msgDiv = document.createElement('div');
      msgDiv.setAttribute('data-msg-id', msgId);
      msgDiv.style.marginBottom='6px';
      msgDiv.style.display='flex';
      msgDiv.style.gap='10px';
      msgDiv.style.alignItems='flex-start';
      // Add golden ring for %Owner% messages
      const isOwner = (msg.user === '%Owner%' || msg.user_id === '%Owner%');
      if (isOwner) {
          msgDiv.style.border = '2px solid #FFD700';
          msgDiv.style.borderRadius = '12px';
          msgDiv.style.padding = '8px';
          msgDiv.style.boxShadow = '0 0 0 2px rgba(255, 215, 0, 0.3), 0 0 10px rgba(255, 215, 0, 0.2)';
          msgDiv.style.background = 'rgba(255, 215, 0, 0.05)';
      }
      const avatarDiv = document.createElement('div');
      avatarDiv.style.width='32px';
      avatarDiv.style.height='32px';
      avatarDiv.style.borderRadius='50%';
      avatarDiv.style.flexShrink='0';
      avatarDiv.style.overflow='hidden';
      avatarDiv.style.display='flex';
      avatarDiv.style.alignItems='center';
      avatarDiv.style.justifyContent='center';
      avatarDiv.style.fontSize='20px';
      avatarDiv.style.background='linear-gradient(135deg, #FFD700, #FFA500)';
      const messageAvatarImage = msg.avatarImage || msg.avatar_image || msg.avatarUrl || msg.avatarURL;
      if(messageAvatarImage) {
          avatarDiv.style.backgroundImage = `url(${messageAvatarImage})`;
          avatarDiv.style.backgroundSize = 'cover';
          avatarDiv.style.backgroundPosition = 'center';
          avatarDiv.textContent = '';
      } else {
          avatarDiv.textContent = msg.avatar || '👤';
      }
      msgDiv.appendChild(avatarDiv);
      
      const leftDiv = document.createElement('div');
      leftDiv.style.flex='1';
      let content = linkifyText(msg.text || '');
      if(msg.file) {
          if(msg.file.type && msg.file.type.startsWith('image/')) {
              const safeImg = escapeHtml(msg.file.data);
              content = `<img src="${safeImg}" style="max-width:200px; max-height:200px; border-radius:8px; margin-top:5px;" /><br>${content}`;
          } else {
              const safeFile = escapeHtml(msg.file.data);
              const safeName = escapeHtml(msg.file.name || 'download');
              content = `${content} <a href="${safeFile}" download="${safeName}" style="color:#FFD700;">Download</a>`;
          }
      }
      if(msg.link) {
          const safeLink = escapeHtml(msg.link);
          content = `${content}<br><a href="${safeLink}" target="_blank" rel="noopener noreferrer" style="color:#FFD700; text-decoration:underline;">${safeLink}</a>`;
      }
      
      const safeUser = escapeHtml(msg.user || 'Unknown');
      const timeStr = msg.time ? new Date(msg.time).toLocaleTimeString() : '';
      leftDiv.innerHTML = `<span style="color:${msg.color}; font-weight:bold;">${safeUser}</span>: ${content} 
                           <small style="color:rgba(255,255,255,0.5); font-size:11px;">${timeStr}</small>`;
      leftDiv.style.maxWidth='none';
      leftDiv.style.width='auto';
      leftDiv.style.minWidth='0';
      leftDiv.style.flex='1 1 auto';
      leftDiv.style.wordWrap='break-word';
      leftDiv.style.whiteSpace='pre-wrap';
      leftDiv.style.overflowWrap='break-word';
      if(msg.uid === visitorId && snapshot){
          const delBtn = document.createElement('button');
          delBtn.innerHTML='?-';
        delBtn.className = 'chat-delete-btn';
        delBtn.style.cssText = 'border:none; background:rgba(255,0,0,0.2); color:#ff4444; cursor:pointer; padding:4px 8px; border-radius:4px; font-size:14px; margin-left:8px; transition:all 0.2s;';
        delBtn.onclick = (e) => {
            e.stopPropagation();
            if(confirm('Delete this message?')) {
                snapshot.ref.remove().catch(err => {
                    console.error('Error deleting message:', err);
                    if (typeof notifications !== 'undefined' && notifications.show) {
                        notifications.show('Error deleting message', 'error', 2000);
                    }
                });
            }
        };
        delBtn.onmouseenter = () => {
            delBtn.style.background = 'rgba(255,0,0,0.4)';
            delBtn.style.transform = 'scale(1.1)';
        };
        delBtn.onmouseleave = () => {
            delBtn.style.background = 'rgba(255,0,0,0.2)';
            delBtn.style.transform = 'scale(1)';
        };
          leftDiv.appendChild(delBtn);
      } else if (msgId && msg.uid === visitorId) {
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Delete';
          delBtn.style.cssText = 'border:none; background:rgba(255,0,0,0.2); color:#ff4444; cursor:pointer; padding:4px 8px; border-radius:4px; font-size:12px; margin-left:8px; transition:all 0.2s;';
          delBtn.onclick = (e) => {
              e.stopPropagation();
              if(confirm('Delete this message?')) {
                  const base = BACKEND_API_URL.replace(/\/api$/, '');
                  fetch(`${base}/api/admin/chat/${encodeURIComponent(msgId)}?password=${encodeURIComponent(ADMIN_PASSWORD)}`, { method:'DELETE' })
                    .then(r => { if(!r.ok) throw new Error('HTTP '+r.status); })
                    .then(() => msgDiv.remove())
                    .catch(err => {
                        console.error('Error deleting message:', err);
                        if (typeof notifications !== 'undefined' && notifications.show) {
                            notifications.show('Error deleting message', 'error', 2000);
                        } else { alert('Error deleting message'); }
                    });
              }
          };
          delBtn.onmouseenter = () => {
              delBtn.style.background = 'rgba(255,0,0,0.35)';
              delBtn.style.transform = 'scale(1.05)';
          };
          delBtn.onmouseleave = () => {
              delBtn.style.background = 'rgba(255,0,0,0.2)';
              delBtn.style.transform = 'scale(1)';
          };
          leftDiv.appendChild(delBtn);
      }
  
      msgDiv.appendChild(leftDiv);
      const reactionsDiv = document.createElement('div');
      reactionsDiv.className = 'emoji-reactions';
      reactionsDiv.style.cssText = 'display:flex; gap:5px; margin-top:5px; flex-wrap:wrap; width:100%;';
      msgDiv.appendChild(reactionsDiv);
      
      if (chatMessages) {
          chatMessages.appendChild(msgDiv);
          if(chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight < 50){
              chatMessages.scrollTop = chatMessages.scrollHeight;
          }
      }
      if(msg.reactions) {
          updateMessageReactions(msgId, msg.reactions);
      }
  }
  // Chat will be loaded lazily when chat is opened (see toggleChatBtn handler below)
  var chatInitialized = false;
  let chatListeners = {
      childAdded: null,
      childChanged: null,
      typingAdded: null,
      typingRemoved: null
  };

  // Clean up chat listeners
  function cleanupChatListeners() {
      try {
          stopBackendChatPolling();
          backendChatListenersAttached = false;
          chatBackendReady = false;
          if (chatListeners.childAdded && db) {
              db.ref('chat').off('child_added', chatListeners.childAdded);
              chatListeners.childAdded = null;
          }
          if (chatListeners.childChanged && db) {
              db.ref('chat').off('child_changed', chatListeners.childChanged);
              chatListeners.childChanged = null;
          }
          if (chatListeners.typingAdded && db) {
              db.ref('chatTyping').off('child_added', chatListeners.typingAdded);
              chatListeners.typingAdded = null;
          }
          if (chatListeners.typingRemoved && db) {
              db.ref('chatTyping').off('child_removed', chatListeners.typingRemoved);
              chatListeners.typingRemoved = null;
          }
      } catch (error) {
          console.error('Error cleaning up chat listeners:', error);
      }
  }
  
  function stopBackendChatPolling() {
      if (chatPollInterval) {
          clearInterval(chatPollInterval);
          chatPollInterval = null;
      }
  }

  async function pollBackendChat(initial = false) {
      if (!backendApi || !chatMessages) return;
      // Skip polling if chat UI is hidden/minimized
      if (chatMessages.offsetParent === null) return;
      try {
          // Fetch from public endpoint
          const recent = await backendApi.getRecentChat(50, true);
          if (!Array.isArray(recent)) {
              console.warn('Chat response was not an array:', recent);
              throw new Error('Invalid chat response');
          }
          // Start with whatever we got back
          let messagesToRender = recent;

          if (initial) {
              backendChatMessageIds.clear();
              // Only clear when we actually have messages to render; otherwise keep whatever is showing
              if (messagesToRender.length > 0) {
                  chatMessages.innerHTML = '';
              }
          }

          recent.sort((a, b) => (a.time || 0) - (b.time || 0));
          let added = false;

          // Fallback: if empty on first load, hit admin endpoint to load DB history (requires password set)
          if (messagesToRender.length === 0 && initial && !chatHistoryBootstrapped) {
              const password = '12344321';
              try {
                  const adminUrl = `${BACKEND_API_URL.replace(/\/api$/, '')}/api/admin/chat?password=${encodeURIComponent(password)}&limit=100`;
                  const adminRes = await fetch(adminUrl, { cache: 'no-store' });
                  const adminJson = adminRes.ok ? await adminRes.json() : null;
                  if (adminJson && Array.isArray(adminJson.messages)) {
                      messagesToRender = adminJson.messages.reverse(); // admin returns newest first
                      chatHistoryBootstrapped = true;
                  }
              } catch (e) {
                  // silent fallback failure
              }
          }

          // If we had previously shown the empty-state message, clear it before rendering new messages
          if (messagesToRender.length > 0 && chatMessages && chatMessages.textContent.includes('No chat messages yet')) {
              chatMessages.innerHTML = '';
          }

          messagesToRender.forEach(msg => {
              if (!msg || !msg.id) return;
              const isNew = !backendChatMessageIds.has(msg.id);
              backendChatMessageIds.add(msg.id);
              if (isNew) {
                  renderChatMessage(msg, msg.id, null);
                  added = true;
              } else {
                  updateMessageReactions(msg.id, msg.reactions || {});
              }
          });

          // If nothing came back, show a friendly empty state
          if (messagesToRender.length === 0 && chatMessages && initial) {
              chatMessages.innerHTML = '<p style="padding:12px; color:rgba(255,255,255,0.6); text-align:center;">No chat messages yet.</p>';
          }

          syncChatMessages();
          if ((initial || added) && chatMessages) {
              chatMessages.scrollTop = chatMessages.scrollHeight;
          }
          chatBackendReady = true;
          if (chatLoadingOverlay) chatLoadingOverlay.style.display = 'none';
      } catch (error) {
          console.warn('Backend chat poll failed:', error);
          chatBackendReady = false;
          if (chatLoadingOverlay) chatLoadingOverlay.style.display = 'none';
          if (initial && chatMessages) {
              chatMessages.innerHTML = '<p style="padding:12px; color:rgba(255,255,255,0.6); text-align:center;">Chat is unavailable right now. Retrying...</p>';
          }
      }
  }

  function attachBackendChatListeners() {
      if (!backendApi || backendChatListenersAttached) return;
      backendChatListenersAttached = true;
      // show loading overlay until we get initial payload
      if (chatMessages) {
          if (!chatLoadingOverlay) {
              chatLoadingOverlay = document.createElement('div');
              chatLoadingOverlay.id = 'chatLoadingOverlay';
              chatLoadingOverlay.style.cssText = 'position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(5,6,12,0.8); color:#FFD700; font-size:22px; font-weight:700; z-index:5;';
              chatLoadingOverlay.textContent = 'Loading chat messages...';
              chatMessages.style.position = 'relative';
              chatMessages.appendChild(chatLoadingOverlay);
          } else {
              chatLoadingOverlay.style.display = 'flex';
          }
      }
      // Start polling loop
      pollBackendChat(true);
      stopBackendChatPolling();
      chatPollInterval = setInterval(() => pollBackendChat(false), 8000);
  }

async function ensureBackendChatConnection() {
      if (!backendApi) return false;
      if (chatBackendReady) return true;
      if (!backendChatListenersAttached) {
          attachBackendChatListeners();
      }
      await backendApi.connect(username);
      chatBackendReady = true;
      refreshBannedUsersFromBackend();
      return true;
  }
  
  async function initializeChat() {
      if(chatInitialized || !chatMessages) return;
      chatInitialized = true;

      // Clean up any existing listeners first
      cleanupChatListeners();
      if (chatMessages) {
          chatMessages.innerHTML = '';
      }

      // Prefer backend chat first
      if (backendApi) {
      const connected = await ensureBackendChatConnection();
      if (connected) {
          // Force an immediate fetch of recent history so past chats appear right away
          await pollBackendChat(true);
          return;
      }
      console.warn('Backend chat unavailable, skipping chat initialization.');
      chatInitialized = false;
      return;
      }

      console.warn('Backend not available; chat disabled.');
      if (chatMessages) {
          chatMessages.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.6);">Chat is disabled.</p>';
      }
      chatInitialized = false;
      return;
  }

  function sendReaction(msgId, emoji) {
      if (backendApi && chatBackendReady) {
          backendApi.addReaction(msgId, emoji).then((data) => {
              if (data && data.reactions) {
                  updateMessageReactions(msgId, data.reactions);
              }
          }).catch(err => console.warn('Reaction failed', err));
      } else if (db) {
          db.ref(`chat/${msgId}/reactions/${emoji}`).transaction(count => (count || 0) + 1);
      }
  }

  function updateMessageReactions(msgId, reactions) {
      const msgDiv = document.querySelector(`[data-msg-id="${msgId}"]`);
      if(!msgDiv) return;
      let reactionsDiv = msgDiv.querySelector('.emoji-reactions');
      if(!reactionsDiv) {
          reactionsDiv = document.createElement('div');
          reactionsDiv.className = 'emoji-reactions';
          reactionsDiv.style.cssText = 'display:flex; gap:5px; margin-top:5px; flex-wrap:wrap; width:100%;';
          msgDiv.appendChild(reactionsDiv);
      }
      reactionsDiv.innerHTML = Object.entries(reactions).map(([emoji, count]) => 
          `<button class="reactBtn" data-msg="${msgId}" data-emoji="${emoji}" style="padding:4px 8px; background:rgba(255,215,0,0.1); border:1px solid rgba(255,215,0,0.3); border-radius:4px; color:#FFD700; cursor:pointer; font-size:12px;">${emoji} ${count}</button>`
      ).join('') + `<button class="addReactionBtn" data-msg="${msgId}" style="padding:4px 8px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,215,0,0.2); border-radius:4px; color:rgba(255,255,255,0.7); cursor:pointer; font-size:12px;">+ React</button>`;
      
      reactionsDiv.querySelectorAll('.reactBtn').forEach(btn => {
          btn.addEventListener('click', () => {
              sendReaction(btn.dataset.msg, btn.dataset.emoji);
          });
      });
      
      reactionsDiv.querySelector('.addReactionBtn')?.addEventListener('click', () => {
          const emoji = prompt('Enter emoji:');
          if(emoji) {
              sendReaction(msgId, emoji);
          }
      });
  }

  // Change Name/Color popup
// Change Name/Color popup
  // Change name button (works for both regular and fullscreen)
  function openNameColorPopup() {
    const popup = document.getElementById('chatNameColorPopup');
    if (popup) {
        const usernameInput = document.getElementById('chatPopupUsername');
        const colorInput = document.getElementById('chatPopupColor');
        if (usernameInput) usernameInput.value = username;
        if (colorInput) colorInput.value = userColor;
        popup.style.display = 'block';
    } else {
        notifications.show('Name/Color popup not found', 'error', 2000);
    }
  }
  
  // Get popup elements
  const chatNameColorPopup = document.getElementById('chatNameColorPopup');
  const chatPopupUsername = document.getElementById('chatPopupUsername');
  const chatPopupColor = document.getElementById('chatPopupColor');
  const chatSaveNameColor = document.getElementById('chatSaveNameColor');
  const chatPopupCloseBtn = document.getElementById('chatPopupCloseBtn');
  const changeNameBtn = document.getElementById('changeNameBtn');
  
  // Close name/color popup
  if (chatPopupCloseBtn) {
      chatPopupCloseBtn.addEventListener('click', () => {
          if (chatNameColorPopup) {
              chatNameColorPopup.style.display = 'none';
          }
      });
  }
  
  // Close popup when clicking outside
  if (chatNameColorPopup) {
      chatNameColorPopup.addEventListener('click', (e) => {
          if (e.target === chatNameColorPopup) {
              chatNameColorPopup.style.display = 'none';
          }
      });
  }
  
  // Update openNameColorPopup function to use actual elements
  if (chatNameColorPopup && chatPopupUsername && chatPopupColor) {
    openNameColorPopup = function() {
      chatPopupUsername.value = username;
      chatPopupColor.value = userColor;
      chatNameColorPopup.style.display = 'block';
    };
  }
  
  // Connect change name button (only once, remove duplicates)
  if (changeNameBtn) {
    // Remove any existing listeners by cloning
    const newBtn = changeNameBtn.cloneNode(true);
    changeNameBtn.parentNode.replaceChild(newBtn, changeNameBtn);
    const updatedBtn = document.getElementById('changeNameBtn');
    if (updatedBtn) {
        updatedBtn.addEventListener('click', openNameColorPopup);
    }
  }
  // fullscreenNameBtn will be connected after it's declared (see line ~1244)
  if (chatSaveNameColor) {
      chatSaveNameColor.addEventListener('click', () => {
          if(chatPopupUsername.value.trim() !== '') username = chatPopupUsername.value.trim();
          userColor = chatPopupColor.value;
          chatNameColorPopup.style.display = 'none';
      });
  }
  document.querySelectorAll('.control-section-header').forEach(header => {
    header.addEventListener('click', () => {
      const section = header.parentElement;
      section.classList.toggle('active');
    });
  });
  const iframe = document.getElementById('embeddedSite');
  let zoomLevel = 1;
  let originalSrc = iframe ? iframe.src : '';
  const extraBtn = document.getElementById('extraSiteBtn');
  const privacyBtn = document.getElementById('privacyBtn');
  let onExtra = false;
  let onPrivacy = false;

  // Privacy/Browser button - open browser interface
  if (privacyBtn) {
    privacyBtn.addEventListener('click', () => {
      const win = window.open('about:blank', '_blank');
      if (win) {
        win.location.href = '/pages/browser.html';
      }
    });
  }
  
  const reloadBtn = document.getElementById('reloadBtn');
  if (reloadBtn && iframe) {
      reloadBtn.addEventListener('click', ()=>iframe.src = iframe.src);
  }
  
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const iframeFullscreenBtn = document.getElementById('iframeFullscreenBtn');

  const gamesGridContainer = document.getElementById('gamesGridContainer');
  const searchResultsGrid = document.getElementById('searchResultsGrid');
  const featuredGamesSections = document.getElementById('featuredGamesSections');

  const triggerIframeFullscreen = () => {
      const frame = document.getElementById("embeddedSite");
      if (frame && frame.src && frame.src !== 'about:blank') {
          const container = frame.parentElement;
          if (container && container.requestFullscreen) {
              container.requestFullscreen().catch(err => console.warn('Fullscreen failed:', err));
          } else if (frame.requestFullscreen) {
              frame.requestFullscreen().catch(err => console.warn('Fullscreen failed:', err));
          }
      }
  };

  if (fullscreenBtn) {
      fullscreenBtn.addEventListener("click", triggerIframeFullscreen);
  }
  if (iframeFullscreenBtn) {
      iframeFullscreenBtn.addEventListener('click', () => {
          if (fullscreenBtn) {
              fullscreenBtn.click();
          } else {
              triggerIframeFullscreen();
          }
      });
  }

  // Ensure browser view hides grids for a clean layout
  const setBrowserOnlyMode = (enabled) => {
      if (gamesGridContainer) gamesGridContainer.style.display = enabled ? 'none' : 'block';
      if (searchResultsGrid) searchResultsGrid.style.display = enabled ? 'none' : '';
      if (featuredGamesSections) featuredGamesSections.style.display = enabled ? 'none' : '';
  };
  
  const zoomInBtn = document.getElementById('zoomInBtn');
  if (zoomInBtn && iframe) {
      zoomInBtn.addEventListener('click', ()=>{ zoomLevel += 0.1; iframe.style.transform = `scale(${zoomLevel})`; iframe.style.transformOrigin='top left'; });
  }
  
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  if (zoomOutBtn && iframe) {
      zoomOutBtn.addEventListener('click', ()=>{ zoomLevel = Math.max(0.5, zoomLevel - 0.1); iframe.style.transform = `scale(${zoomLevel})`; iframe.style.transformOrigin='top left'; });
  }
  
  const hideIframeBtn = document.getElementById('hideIframeBtn');
  if (hideIframeBtn && iframe) {
      hideIframeBtn.addEventListener('click', ()=>iframe.style.display='none');
  }
  
  const showIframeBtn = document.getElementById('showIframeBtn');
  if (showIframeBtn && iframe) {
      showIframeBtn.addEventListener('click', ()=>iframe.style.display='block');
  }
  
    if (extraBtn) {
        extraBtn.addEventListener('click', ()=>{
      const iframeContainer = document.getElementById('iframeContainer');
        const gamesGridContainer = document.getElementById('gamesGridContainer');
        const currentSiteTitle = document.getElementById('currentSiteTitle');
        
        if(!onExtra){
            // Show iframe container
          if (iframeContainer) iframeContainer.style.display = 'block';
            if (gamesGridContainer) gamesGridContainer.style.display = 'none';
            if (currentSiteTitle) currentSiteTitle.textContent = 'Extra Site';
            // Pause heavy home visuals while external site is open
            if (typeof pauseHomeVisuals === 'function') pauseHomeVisuals();
            
            // Load the site
            iframe.src = 'about:blank';
            setTimeout(() => {
                iframe.src = 'https://funfrinew.neocities.org/';
            }, 50);
            
            extraBtn.innerHTML='<i class="fas fa-arrow-left"></i> Go Back';
            onExtra=true;
            
            // Scroll to iframe
            setTimeout(() => {
              if (iframeContainer) iframeContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
        } else {
            // Go back to games
          if (iframeContainer) iframeContainer.style.display = 'none';
            if (gamesGridContainer) gamesGridContainer.style.display = 'block';
            iframe.src = originalSrc;
            extraBtn.innerHTML='<i class="fas fa-gamepad"></i> Extra Site';
            onExtra=false;
            // Resume visuals when returning to games grid
            if (typeof resumeHomeVisuals === 'function') resumeHomeVisuals();
        }
        });
    }
  
  // YouTube Video Watcher (enhanced modal with YouTube API integration)
  const youtubeWatcherBtn = document.getElementById('youtubeWatcherBtn');
  youtubeWatcherBtn?.addEventListener('click', openYoutubePrompt, true);

  // Using enhanced YouTube modal with full API integration and features
  
  // ---------------- Popup ----------------
  const popup = document.getElementById('fullscreenPopup');
  const popupDontShowCheckbox = document.getElementById('popupDontShowAgain');
  const POPUP_STORAGE_KEY = 'ggh_hide_welcome_popup';

  function handlePopupClose() {
      if (popupDontShowCheckbox && popupDontShowCheckbox.checked) {
          try {
              localStorage.setItem(POPUP_STORAGE_KEY, 'true');
          } catch (e) {
              console.warn('Unable to store popup preference:', e);
          }
      }
      try {
          popup.classList.remove('show');
      } catch (err) {
          console.warn('Error closing popup:', err);
      }
  }
  // Close when clicking the X button
  if (popup) {
    const closeBtn = popup.querySelector('.closeBtn');
    if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handlePopupClose();
        });
    }
  
  // Close when clicking anywhere on the popup (including the content)
  popup.addEventListener('click', (e) => {
      // Don't close if clicking the close button (it has its own handler)
      if (!e.target.closest('.closeBtn')) {
          handlePopupClose();
      }
  });
  }
  
  function showPopup(){
    // Mobile detection logic
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    if (isMobile) {
        // Show mobile popup instead of regular popup
        const mobilePopup = document.getElementById('mobilePopup');
        if (mobilePopup) {
            try {
                mobilePopup.style.display = 'flex';
                // Add event listeners for mobile popup buttons
                const closeMobilePopup = document.getElementById('closeMobilePopup');
                const continueOnMobileBtn = document.getElementById('continueOnMobileBtn');

                if (closeMobilePopup) {
                    closeMobilePopup.addEventListener('click', () => {
                        mobilePopup.style.display = 'none';
                    });
                }

                if (continueOnMobileBtn) {
                    continueOnMobileBtn.addEventListener('click', () => {
                        mobilePopup.style.display = 'none';
                    });
                }
            } catch (err) {
                console.warn('Error showing mobile popup:', err);
            }
        }
    } else {
        // Show regular popup for desktop
        if (popup) {
            try {
                popup.classList.add('show');
            } catch (err) {
                console.warn('Error showing popup:', err);
            }
        }
    }
  }
  
  const adminBtn = document.getElementById('adminBtn');
  const adminModal = document.getElementById('adminModal');
  const creditsBtn = document.getElementById('creditsBtn');
  const creditsModal = document.getElementById('creditsModal');
  const closeCreditsBtn = document.getElementById('closeCreditsBtn');
  const closeAdminBtn = document.getElementById('closeAdminBtn');
  const adminLoginBtn = document.getElementById('adminLoginBtn');
  const adminPasswordInput = document.getElementById('adminPasswordInput');
  const adminContent = document.getElementById('adminContent');
  const adminPassword = document.getElementById('adminPassword');
  const deleteChatHistoryBtn = document.getElementById('deleteChatHistoryBtn');
  const clearCanvasAdminBtn = document.getElementById('clearCanvasAdminBtn');
  const resetVisitorsBtn = document.getElementById('resetVisitorsBtn');
  const logoutAdminBtn = document.getElementById('logoutAdminBtn');
  
  const ADMIN_PASSWORD = '12344321';
  let isAdminAuthenticated = false;
  
  // Load admin authentication state from localStorage
  const savedAdminState = localStorage.getItem('isAdminAuthenticated');
  if (savedAdminState === 'true') {
      isAdminAuthenticated = true;
  }
  
  // Credits Modal
  creditsBtn?.addEventListener('click', () => {
      if (creditsModal) {
          creditsModal.style.display = 'flex';
      }
  });
  
  closeCreditsBtn?.addEventListener('click', () => {
      if (creditsModal) {
          creditsModal.style.display = 'none';
      }
  });
  
  creditsModal?.addEventListener('click', (e) => {
      if (e.target === creditsModal) {
          creditsModal.style.display = 'none';
      }
  });
  
  adminBtn?.addEventListener('click', () => {
    adminModal.style.display = 'flex';
    adminPasswordInput?.focus();
  });
  
  closeAdminBtn?.addEventListener('click', () => {
    if (adminModal) adminModal.style.display = 'none';
    isAdminAuthenticated = false;
    localStorage.removeItem('isAdminAuthenticated');
    if (adminContent) adminContent.style.display = 'none';
    if (adminPassword) adminPassword.style.display = '';
    if (adminPasswordInput) adminPasswordInput.value = '';
    // Re-render games grid to disable drag-and-drop
    if (typeof renderGamesGrid === 'function') {
        setTimeout(() => renderGamesGrid(), 100);
    }
  });
  
  adminModal?.addEventListener('click', (e) => {
    if(e.target === adminModal) {
      adminModal.style.display = 'none';
      isAdminAuthenticated = false;
      if (adminContent) adminContent.style.display = 'none';
      if (adminPassword) adminPassword.style.display = '';
      if (adminPasswordInput) adminPasswordInput.value = '';
    }
  });
  
  adminLoginBtn?.addEventListener('click', () => {
    if(adminPasswordInput && adminPasswordInput.value === ADMIN_PASSWORD) {
      isAdminAuthenticated = true;
      localStorage.setItem('isAdminAuthenticated', 'true');
      if (adminPassword) adminPassword.style.display = 'none';
      if (adminContent) adminContent.style.display = 'block';
      // Load admin polls when admin panel is opened
      setTimeout(() => {
        loadAdminPolls();
      }, 100);
      loadAdminChatMessages(); // Load chat messages when admin logs in
      // Re-render games grid to enable drag-and-drop
      if (typeof renderGamesGrid === 'function') {
          setTimeout(() => renderGamesGrid(), 100);
      }
    } else {
      alert('Incorrect password');
      if (adminPasswordInput) adminPasswordInput.value = '';
    }
  });
  
  adminPasswordInput?.addEventListener('keypress', (e) => {
    if(e.key === 'Enter' && adminLoginBtn) {
      adminLoginBtn.click();
    }
  });
  
  deleteChatHistoryBtn?.addEventListener('click', () => {
    if(confirm('Delete all chat history? This cannot be undone.')) {
      if (db) {
        db.ref('chat').remove().then(() => {
          alert('Chat history deleted');
          const chatMessages = document.getElementById('chatMessages');
          if (chatMessages) chatMessages.innerHTML = '';
        }).catch(err => alert('Error: ' + err.message));
      }
    }
  });
  
  clearCanvasAdminBtn?.addEventListener('click', () => {
    if(confirm('Clear the drawing canvas? This cannot be undone.')) {
      if (db) {
        db.ref('canvas/strokes').remove().then(() => {
          db.ref('canvas/meta/clear').set({ by: 'admin', time: Date.now() });
          setTimeout(() => { db.ref('canvas/meta/clear').remove(); }, 1500);
          alert('Canvas cleared');
        }).catch(err => alert('Error: ' + err.message));
      }
    }
  });
  
  resetVisitorsBtn?.addEventListener('click', () => {
    if(confirm('Reset total visitors count to 127,349?')) {
      if (db) {
        db.ref('totalVisitors').set(INITIAL_VISITOR_COUNT).then(() => {
          alert('Visitors count reset to 127,349');
          updateCounter(); // Refresh the display
        }).catch(err => alert('Error: ' + err.message));
      }
    }
  });
  
  // Refresh button for chat list
  const refreshChatListBtn = document.getElementById('refreshChatListBtn');
  refreshChatListBtn?.addEventListener('click', () => {
    loadAdminChatMessages();
  });
  
  // Admin polls management
  const refreshPollsListBtn = document.getElementById('refreshPollsListBtn');
  const deleteAllPollsBtn = document.getElementById('deleteAllPollsBtn');
  const adminPollsList = document.getElementById('adminPollsList');
  
  refreshPollsListBtn?.addEventListener('click', () => {
    loadAdminPolls();
  });
  
  deleteAllPollsBtn?.addEventListener('click', () => {
    if(confirm('Are you sure you want to delete ALL polls? This action cannot be undone!')) {
      if(db) {
        db.ref('polls').remove().then(() => {
          notifications.show('All polls deleted successfully!', 'success', 2000);
          loadAdminPolls();
          if(pollsList) loadPolls(); // Also refresh the regular polls list
        }).catch(err => {
          console.error('Error deleting all polls:', err);
          notifications.show('Error deleting polls. Please try again.', 'error', 2000);
        });
      }
    }
  });
  
  // Load polls for admin panel
  function loadAdminPolls() {
    if(!db || !adminPollsList) return;
    
    adminPollsList.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Loading polls...</p>';
    
    db.ref('polls').once('value').then(snap => {
      const polls = snap.val() || {};
      if(Object.keys(polls).length === 0) {
        adminPollsList.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">No polls found.</p>';
        return;
      }
      
      adminPollsList.innerHTML = Object.entries(polls).reverse().map(([id, poll]) => {
        if(!poll || !poll.options) return '';
        // Use summary if available, otherwise calculate from options (backward compatibility)
        const totalVotes = poll.summary?.totalVotes || poll.options.reduce((sum, opt) => sum + (opt.votes || 0), 0);
        const createdDate = new Date(poll.createdAt || Date.now()).toLocaleString();
        
        return `
          <div style="padding:15px; background:rgba(255,255,255,0.05); border-radius:8px; margin-bottom:12px; border:1px solid rgba(255,215,0,0.2);">
            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:10px;">
              <div style="flex:1;">
                <div style="font-weight:600; color:#FFD700; margin-bottom:5px;">${poll.question || 'Untitled Poll'}</div>
                <div style="font-size:11px; color:rgba(255,255,255,0.5);">
                  By ${poll.createdBy || 'Unknown'} • ${createdDate} • ${totalVotes} total votes
                </div>
              </div>
              <button class="adminDeletePollBtn" data-poll-id="${id}" style="padding:6px 12px; background:#dc3545; border:1px solid #dc3545; border-radius:6px; color:#ffffff; cursor:pointer; font-size:12px; font-weight:600; margin-left:10px; transition:all 0.3s ease;" title="Delete this poll">
                <i class="fas fa-trash"></i>
              </button>
            </div>
            <div style="font-size:12px; color:rgba(255,255,255,0.7);">
              Options: ${poll.options ? poll.options.map((opt, i) => `${i + 1}. ${opt.text || 'Option ' + (i + 1)} (${opt.votes || 0} votes)`).join(', ') : 'None'}
            </div>
          </div>
        `;
      }).join('');
      
      // Add delete button handlers
      document.querySelectorAll('.adminDeletePollBtn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const pollId = btn.dataset.pollId;
          if(pollId && confirm('Are you sure you want to delete this poll?')) {
            if(db) {
              db.ref(`polls/${pollId}`).remove().then(() => {
                notifications.show('Poll deleted successfully!', 'success', 2000);
                loadAdminPolls();
                if(pollsList) loadPolls(); // Also refresh the regular polls list
              }).catch(err => {
                console.error('Error deleting poll:', err);
                notifications.show('Error deleting poll. Please try again.', 'error', 2000);
              });
            }
          }
        });
      });
    }).catch(err => {
      console.error('Error loading polls:', err);
      if(adminPollsList) adminPollsList.innerHTML = '<p style="text-align:center; color:rgba(255,0,0,0.7);">Error loading polls. Please try again.</p>';
    });
  }
  
  // Load admin polls when admin panel opens
  if(adminBtn) {
    const originalAdminClick = adminBtn.onclick;
    adminBtn.addEventListener('click', () => {
      // Load admin polls when admin panel is opened
      setTimeout(() => {
        if(adminPollsList && document.getElementById('adminContent')?.style.display !== 'none') {
          loadAdminPolls();
        }
      }, 100);
    });
  }
  
  // Load chat messages for admin panel (including voice messages)
  async function loadAdminChatMessages() {
    const adminChatList = document.getElementById('adminChatList');
    if(!adminChatList) return;
    
    adminChatList.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Loading chat messages...</p>';
    
    const baseUrl = (window.BACKEND_API_URL || 'https://shs-portal-backend.vercel.app/api').replace(/\/$/, '');
    const limitInput = document.getElementById('adminChatLimit');
    const offsetInput = document.getElementById('adminChatOffset');
    const limit = limitInput ? limitInput.value || 50 : 50;
    const offset = offsetInput ? offsetInput.value || 0 : 0;
    const adminUrl = `${baseUrl}/admin/chat?password=${encodeURIComponent(ADMIN_PASSWORD)}&limit=${encodeURIComponent(limit)}&offset=${encodeURIComponent(offset)}`;
    const fallbackUrl = `${baseUrl}/chat/recent?limit=${encodeURIComponent(limit)}&images=1`;

    let msgs = [];
    try {
      const adminRes = await fetch(adminUrl, { headers: { 'x-admin-password': ADMIN_PASSWORD } });
      if (!adminRes.ok) throw new Error(`Admin endpoint ${adminRes.status}`);
      const adminData = await adminRes.json();
      msgs = adminData.messages || adminData || [];
      if (!Array.isArray(msgs)) throw new Error('Unexpected admin payload');
    } catch (adminErr) {
      console.warn('Admin endpoint failed, falling back to public chat feed', adminErr);
      try {
        const fallbackRes = await fetch(fallbackUrl);
        if (!fallbackRes.ok) throw new Error(`Fallback endpoint ${fallbackRes.status}`);
        const fallbackData = await fallbackRes.json();
        msgs = Array.isArray(fallbackData) ? fallbackData : (fallbackData.messages || []);
        if (!Array.isArray(msgs)) throw new Error('Unexpected fallback payload');
      } catch (fallbackErr) {
        console.error('Error loading messages:', fallbackErr);
        adminChatList.innerHTML = '<p style="text-align:center; color:rgba(255,0,0,0.7);">Error loading messages.</p>';
        return;
      }
    }

    if (!msgs.length) {
      adminChatList.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">No messages found.</p>';
      return;
    }

    adminChatList.innerHTML = msgs.map((m) => {
      const time = new Date(m.time || Date.now()).toLocaleString();
      const preview = m.text ? (m.text.length > 80 ? m.text.slice(0,80)+'…' : m.text) : '(no text)';
      const uid = (m.uid||'').toString();
      return `
        <div style="padding:10px; margin-bottom:8px; background:rgba(255,255,255,0.05); border-radius:8px; border-left:3px solid rgba(255,215,0,0.5); display:flex; gap:10px;">
          <div style="flex:1; min-width:0;">
            <div style="font-weight:600; color:#FFD700; margin-bottom:4px; font-size:13px;">
              ${m.user || 'Unknown'}
            </div>
            <div style="font-size:12px; color:rgba(255,255,255,0.85); margin-bottom:4px; word-break:break-word;">${preview}</div>
            <div style="font-size:10px; color:rgba(255,255,255,0.5);">${time} • UID: ${uid.slice(0,8)}…</div>
          </div>
          <div style="display:flex; flex-direction:column; gap:6px; flex-shrink:0;">
            <button class="adminBanUserBtn" data-uid="${uid}" data-username="${m.user || 'Unknown'}" style="padding:6px 10px; background:#ff6b00; border:1px solid #ff6b00; color:#ffffff; border-radius:6px; cursor:pointer; font-size:12px;">Ban</button>
            <button class="adminDeleteChatBtn" data-msg-id="${m.id}" style="padding:6px 10px; background:#dc3545; border:1px solid #dc3545; color:#ffffff; border-radius:6px; cursor:pointer; font-size:12px;">Delete</button>
          </div>
        </div>
      `;
    }).join('');

    adminChatList.querySelectorAll('.adminDeleteChatBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const msgId = btn.dataset.msgId;
        if (!msgId) return;
        if (!confirm('Delete this message?')) return;
        fetch(`${baseUrl}/admin/chat/${encodeURIComponent(msgId)}`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: ADMIN_PASSWORD })
        }).then(r => r.json()).then(() => {
          loadAdminChatMessages();
        }).catch(err => {
          console.error(err);
          alert('Failed to delete message');
        });
      });
    });

    adminChatList.querySelectorAll('.adminBanUserBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const uid = btn.dataset.uid;
        const uname = btn.dataset.username || 'User';
        if (!uid) return;
        const reason = prompt(`Ban ${uname}? Enter reason (optional):`, 'Admin action');
        if (reason === null) return;
        fetch(`${baseUrl}/admin/ban`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: ADMIN_PASSWORD, uid, username: uname, reason })
        }).then(r => r.json()).then(() => {
          alert(`${uname} banned`);
          loadAdminChatMessages();
        }).catch(err => {
          console.error(err);
          alert('Failed to ban user');
        });
      });
    });
  }
  
  logoutAdminBtn?.addEventListener('click', () => {
    isAdminAuthenticated = false;
    localStorage.removeItem('isAdminAuthenticated');
    if (adminContent) adminContent.style.display = 'none';
    if (adminPassword) adminPassword.style.display = '';
    if (adminPasswordInput) adminPasswordInput.value = '';
    alert('Logged out');
    // Re-render games grid to disable drag-and-drop
    if (typeof renderGamesGrid === 'function') {
        setTimeout(() => renderGamesGrid(), 100);
    }
  });
  
  // Moderation Panel Functions
  const openModerationPanelBtn = document.getElementById('openModerationPanelBtn');
  const moderationPanelModal = document.getElementById('moderationPanelModal');
  const closeModerationPanelBtn = document.getElementById('closeModerationPanelBtn');
  
  openModerationPanelBtn?.addEventListener('click', () => {
    if (!isAdminAuthenticated) {
      alert('Please login as admin first');
      return;
    }
    moderationPanelModal.style.display = 'flex';
    loadModerationPanel();
  });
  
  closeModerationPanelBtn?.addEventListener('click', () => {
    moderationPanelModal.style.display = 'none';
  });
  
  moderationPanelModal?.addEventListener('click', (e) => {
    if (e.target === moderationPanelModal) {
      moderationPanelModal.style.display = 'none';
    }
  });
  
  // Game Organizer
  const openGameOrganizerBtn = document.getElementById('openGameOrganizerBtn');
  const gameOrganizerModal = document.getElementById('gameOrganizerModal');
  const closeGameOrganizerBtn = document.getElementById('closeGameOrganizerBtn');
  const organizerViewBtn = document.getElementById('organizerViewBtn');
  const categoryListViewBtn = document.getElementById('categoryListViewBtn');
  const organizerView = document.getElementById('organizerView');
  const categoryListView = document.getElementById('categoryListView');
  
  let currentGameIndex = 0;
  let gamesForOrganizer = [];
  // gameCategories is already declared at the top of the file
  
  // Load game categories from Firebase (shared for all users)
  // This is called when the organizer is opened, but categories are already loaded via initializeGameCategories
  function loadGameCategories() {
    // Categories should already be loaded via initializeGameCategories
    // This function is mainly for refreshing when organizer is opened
    if (db) {
      db.ref('gameCategories').once('value').then(snapshot => {
        const categories = snapshot.val();
        if (categories) {
          gameCategories = categories;
          console.log('Game categories refreshed from Firebase');
          // Re-categorize games with the loaded categories
          if (typeof categorizeAllGames === 'function' && gameSites && gameSites.length > 0) {
            categorizeAllGames();
            // Re-render if needed
            if (document.getElementById('featuredGamesSections')) {
              renderFeaturedSections();
            }
          }
        } else {
          // Fallback to localStorage if Firebase is empty
          loadGameCategoriesFromLocalStorage();
        }
      }).catch(error => {
        console.error('Error loading game categories from Firebase:', error);
        // Fallback to localStorage
        loadGameCategoriesFromLocalStorage();
      });
    } else {
      // Fallback to localStorage if Firebase is not available
      loadGameCategoriesFromLocalStorage();
    }
  }
  
  // Fallback: Load from localStorage
  function loadGameCategoriesFromLocalStorage() {
    try {
      const saved = localStorage.getItem('gameCategories');
      if (saved) {
        gameCategories = JSON.parse(saved);
        // Also save to Firebase if available
        if (db && Object.keys(gameCategories).length > 0) {
          db.ref('gameCategories').set(gameCategories).catch(err => {
            console.error('Error syncing categories to Firebase:', err);
          });
        }
      }
    } catch (e) {
      console.error('Error loading game categories from localStorage:', e);
      gameCategories = {};
    }
  }
  
  // Save game categories to Firebase (shared for all users)
  function saveGameCategories() {
    if (db) {
      db.ref('gameCategories').set(gameCategories).then(() => {
        console.log('Game categories saved to Firebase');
        // Also save to localStorage as backup
        try {
          localStorage.setItem('gameCategories', JSON.stringify(gameCategories));
        } catch (e) {
          console.error('Error saving to localStorage backup:', e);
        }
        // Re-categorize games immediately
        if (typeof categorizeAllGames === 'function') {
          categorizeAllGames();
          // Re-render if needed
          if (document.getElementById('featuredGamesSections')) {
            renderFeaturedSections();
          }
        }
      }).catch(error => {
        console.error('Error saving game categories to Firebase:', error);
        // Fallback to localStorage
        try {
          localStorage.setItem('gameCategories', JSON.stringify(gameCategories));
        } catch (e) {
          console.error('Error saving to localStorage:', e);
        }
      });
    } else {
      // Fallback to localStorage if Firebase is not available
      try {
        localStorage.setItem('gameCategories', JSON.stringify(gameCategories));
      } catch (e) {
        console.error('Error saving game categories:', e);
      }
    }
  }
  
  // Real-time listener is set up in initializeGameCategories() to avoid duplicates
  
  // Helper function to get game key for organizer (uses same logic as main getGameKey)
  function getGameKeyForOrganizer(game) {
    if (game.embed) {
      // Use the same getGameKey function that's used elsewhere
      return getGameKey(game.embed);
    }
    return game.title || 'unknown';
  }
  
  openGameOrganizerBtn?.addEventListener('click', () => {
    if (!isAdminAuthenticated) {
      alert('Please login as admin first');
      return;
    }
    loadGameCategories();
    initializeGameOrganizer();
    gameOrganizerModal.style.display = 'flex';
  });
  
  closeGameOrganizerBtn?.addEventListener('click', () => {
    gameOrganizerModal.style.display = 'none';
  });
  
  gameOrganizerModal?.addEventListener('click', (e) => {
    if (e.target === gameOrganizerModal) {
      gameOrganizerModal.style.display = 'none';
    }
  });
  
  organizerViewBtn?.addEventListener('click', () => {
    organizerView.style.display = 'block';
    categoryListView.style.display = 'none';
    organizerViewBtn.classList.add('active');
    categoryListViewBtn.classList.remove('active');
    organizerViewBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
    organizerViewBtn.style.borderColor = 'rgba(40,167,69,0.5)';
    organizerViewBtn.style.color = '#ffffff';
    categoryListViewBtn.style.background = 'rgba(255,255,255,0.05)';
    categoryListViewBtn.style.borderColor = 'rgba(255,255,255,0.2)';
    categoryListViewBtn.style.color = 'rgba(255,255,255,0.8)';
  });
  
  categoryListViewBtn?.addEventListener('click', () => {
    organizerView.style.display = 'none';
    categoryListView.style.display = 'block';
    categoryListViewBtn.classList.add('active');
    organizerViewBtn.classList.remove('active');
    categoryListViewBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
    categoryListViewBtn.style.borderColor = 'rgba(40,167,69,0.5)';
    categoryListViewBtn.style.color = '#ffffff';
    organizerViewBtn.style.background = 'rgba(255,255,255,0.05)';
    organizerViewBtn.style.borderColor = 'rgba(255,255,255,0.2)';
    organizerViewBtn.style.color = 'rgba(255,255,255,0.8)';
    renderCategoryListView();
  });
  
  function initializeGameOrganizer() {
    // Get all games - wait a bit if games aren't loaded yet
    gamesForOrganizer = gameSites || [];
    currentGameIndex = 0;
    
    if (gamesForOrganizer.length === 0) {
      // Try to wait a bit for games to load
      setTimeout(() => {
        gamesForOrganizer = gameSites || [];
        if (gamesForOrganizer.length === 0) {
          alert('No games loaded. Please wait for games to load and try again.');
          return;
        }
        document.getElementById('totalGamesCount').textContent = gamesForOrganizer.length;
        displayCurrentGame();
      }, 500);
      return;
    }
    
    // Update total count
    const totalCountEl = document.getElementById('totalGamesCount');
    if (totalCountEl) {
      totalCountEl.textContent = gamesForOrganizer.length;
    }
    
    // Display first game
    displayCurrentGame();
  }
  
  function displayCurrentGame() {
    if (gamesForOrganizer.length === 0 || currentGameIndex < 0 || currentGameIndex >= gamesForOrganizer.length) {
      return;
    }
    
    const game = gamesForOrganizer[currentGameIndex];
    const gameTitle = game.title || '';
    // Check both static mapping and localStorage (for temporary edits)
    const currentCategory = STATIC_GAME_CATEGORIES[gameTitle] || gameCategories[gameTitle] || 'None';
    
    // Update card
    const cardImage = document.getElementById('gameCardImage');
    const cardTitle = document.getElementById('gameCardTitle');
    const currentCategorySpan = document.getElementById('currentGameCategory');
    const currentGameIndexSpan = document.getElementById('currentGameIndex');
    
    if (cardImage) {
      cardImage.style.backgroundImage = `url(${game.image || ''})`;
    }
    if (cardTitle) {
      cardTitle.textContent = game.title || 'Unknown Game';
    }
    if (currentCategorySpan) {
      currentCategorySpan.textContent = currentCategory === 'None' ? 'None' : currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1);
      currentCategorySpan.style.color = currentCategory === 'None' ? '#ffc107' : '#28a745';
    }
    if (currentGameIndexSpan) {
      currentGameIndexSpan.textContent = currentGameIndex + 1;
    }
  }
  
  // Category button handlers
  document.querySelectorAll('.category-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      if (gamesForOrganizer.length === 0 || currentGameIndex < 0 || currentGameIndex >= gamesForOrganizer.length) {
        return;
      }
      
      const category = btn.getAttribute('data-category');
      const game = gamesForOrganizer[currentGameIndex];
      const gameTitle = game.title || '';
      
      // Assign category (saved to localStorage for organizer session)
      // Note: Static mapping takes precedence, this is for temporary editing
      gameCategories[gameTitle] = category;
      saveGameCategories();
      
      // Update display
      const currentCategorySpan = document.getElementById('currentGameCategory');
      if (currentCategorySpan) {
        currentCategorySpan.textContent = category.charAt(0).toUpperCase() + category.slice(1);
        currentCategorySpan.style.color = '#28a745';
      }
      
      // Visual feedback
      btn.style.transform = 'scale(0.95)';
      setTimeout(() => {
        btn.style.transform = 'scale(1)';
      }, 150);
      
      // Re-categorize games to reflect the change
      if (typeof categorizeAllGames === 'function') {
        categorizeAllGames();
      }
      
      // Update category list view if it's currently visible
      if (categoryListView && categoryListView.style.display !== 'none') {
        renderCategoryListView();
      }
      
      // Auto-advance to next game after a short delay
      setTimeout(() => {
        nextGame();
      }, 300);
    });
  });
  
  // Navigation handlers
  const prevGameBtn = document.getElementById('prevGameBtn');
  const nextGameBtn = document.getElementById('nextGameBtn');
  const skipGameBtn = document.getElementById('skipGameBtn');
  
  prevGameBtn?.addEventListener('click', () => {
    if (currentGameIndex > 0) {
      currentGameIndex--;
      displayCurrentGame();
    }
  });
  
  nextGameBtn?.addEventListener('click', () => {
    nextGame();
  });
  
  skipGameBtn?.addEventListener('click', () => {
    nextGame();
  });
  
  function nextGame() {
    if (currentGameIndex < gamesForOrganizer.length - 1) {
      currentGameIndex++;
      displayCurrentGame();
    } else {
      // Reached the end
      if (confirm('You\'ve reached the end! Start from the beginning?')) {
        currentGameIndex = 0;
        displayCurrentGame();
      }
    }
  }
  
  // Export categories button handler
  const exportCategoriesBtn = document.getElementById('exportCategoriesBtn');
  const exportCategoriesModal = document.getElementById('exportCategoriesModal');
  const closeExportModalBtn = document.getElementById('closeExportModalBtn');
  const exportCategoriesText = document.getElementById('exportCategoriesText');
  const copyExportBtn = document.getElementById('copyExportBtn');
  
  exportCategoriesBtn?.addEventListener('click', () => {
    generateExportText();
    exportCategoriesModal.style.display = 'flex';
  });
  
  closeExportModalBtn?.addEventListener('click', () => {
    exportCategoriesModal.style.display = 'none';
  });
  
  exportCategoriesModal?.addEventListener('click', (e) => {
    if (e.target === exportCategoriesModal) {
      exportCategoriesModal.style.display = 'none';
    }
  });
  
  copyExportBtn?.addEventListener('click', () => {
    if (exportCategoriesText) {
      exportCategoriesText.select();
      exportCategoriesText.setSelectionRange(0, 99999); // For mobile devices
      document.execCommand('copy');
      
      // Visual feedback
      const originalText = copyExportBtn.innerHTML;
      copyExportBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
      copyExportBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
      setTimeout(() => {
        copyExportBtn.innerHTML = originalText;
        copyExportBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
      }, 2000);
    }
  });
  
  function generateExportText() {
    if (!gamesForOrganizer || gamesForOrganizer.length === 0) {
      gamesForOrganizer = gameSites || [];
    }
    
    if (gamesForOrganizer.length === 0) {
      if (exportCategoriesText) {
        exportCategoriesText.value = 'No games loaded. Please wait for games to load.';
      }
      return;
    }
    
    // Generate export text in a simple format: Game Name | Category
    let exportText = 'GAME CATEGORIES EXPORT\n';
    exportText += '=====================\n\n';
    exportText += 'Format: Game Name | Category\n';
    exportText += 'Categories: action, racing, puzzle, new, strategy, adventure, shooting, sports, simulation\n\n';
    exportText += '---\n\n';
    
    // Sort games alphabetically by title
    const sortedGames = [...gamesForOrganizer].sort((a, b) => {
      const titleA = (a.title || '').toLowerCase();
      const titleB = (b.title || '').toLowerCase();
      return titleA.localeCompare(titleB);
    });
    
    sortedGames.forEach(game => {
      const gameTitle = game.title || 'Unknown Game';
      // Check both static mapping and localStorage (for temporary edits)
      const category = STATIC_GAME_CATEGORIES[gameTitle] || gameCategories[gameTitle] || 'none';
      exportText += `${gameTitle} | ${category}\n`;
    });
    
    exportText += '\n---\n';
    const gamesWithCategories = sortedGames.filter(game => {
      const gameTitle = game.title || '';
      const category = STATIC_GAME_CATEGORIES[gameTitle] || gameCategories[gameTitle];
      return category && category !== 'none';
    }).length;
    exportText += `\nTotal Games: ${sortedGames.length}\n`;
    exportText += `Games with categories: ${gamesWithCategories}\n`;
    exportText += `Games without categories: ${sortedGames.length - gamesWithCategories}\n`;
    
    // Also add a JSON format for easier parsing
    exportText += '\n\n--- JSON FORMAT ---\n';
    const jsonData = {};
    sortedGames.forEach(game => {
      const gameTitle = game.title || 'Unknown Game';
      // Check both static mapping and localStorage (for temporary edits)
      const category = STATIC_GAME_CATEGORIES[gameTitle] || gameCategories[gameTitle] || 'none';
      jsonData[gameTitle] = category;
    });
    exportText += JSON.stringify(jsonData, null, 2);
    
    if (exportCategoriesText) {
      exportCategoriesText.value = exportText;
    }
  }
  
  // Render category list view
  function renderCategoryListView() {
    const container = document.getElementById('categoryListContainer');
    if (!container) return;
    
    const categories = ['action', 'racing', 'puzzle', 'new', 'strategy', 'adventure', 'shooting', 'sports', 'simulation'];
    const categoryNames = {
      action: 'Action',
      racing: 'Racing',
      puzzle: 'Puzzle',
      new: 'New',
      strategy: 'Strategy',
      adventure: 'Adventure',
      shooting: 'Shooting',
      sports: 'Sports',
      simulation: 'Simulation'
    };
    
    container.innerHTML = '';
    
    categories.forEach(category => {
      const categoryGames = [];
      gamesForOrganizer.forEach(game => {
        const gameTitle = game.title || '';
        // Check both static mapping and localStorage (for temporary edits)
        const gameCategory = STATIC_GAME_CATEGORIES[gameTitle] || gameCategories[gameTitle];
        if (gameCategory === category) {
          categoryGames.push(game);
        }
      });
      
      const categoryDiv = document.createElement('div');
      categoryDiv.style.cssText = 'background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:15px; padding:20px;';
      
      const header = document.createElement('div');
      header.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;';
      header.innerHTML = `
        <h3 style="margin:0; color:#FFD700; font-size:18px; font-weight:700;">${categoryNames[category]}</h3>
        <span style="color:rgba(255,255,255,0.6); font-size:14px;">${categoryGames.length} games</span>
      `;
      categoryDiv.appendChild(header);
      
      if (categoryGames.length === 0) {
        const emptyMsg = document.createElement('p');
        emptyMsg.style.cssText = 'text-align:center; color:rgba(255,255,255,0.4); font-size:14px; margin:20px 0;';
        emptyMsg.textContent = 'No games in this category yet';
        categoryDiv.appendChild(emptyMsg);
      } else {
        const gamesGrid = document.createElement('div');
        gamesGrid.style.cssText = 'display:grid; grid-template-columns:repeat(auto-fill, minmax(150px, 1fr)); gap:12px;';
        
        categoryGames.forEach(game => {
          const gameItem = document.createElement('div');
          gameItem.style.cssText = 'background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.1); border-radius:10px; padding:10px; cursor:pointer; transition:all 0.3s ease;';
          gameItem.innerHTML = `
            <div style="width:100%; aspect-ratio:4/3; background-size:cover; background-position:center; background-image:url(${game.image || ''}); border-radius:8px; margin-bottom:8px;"></div>
            <div style="color:rgba(255,255,255,0.9); font-size:12px; font-weight:600; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${game.title || 'Unknown'}</div>
          `;
          gameItem.addEventListener('click', () => {
            // Find game index and switch to organizer view
            const index = gamesForOrganizer.findIndex(g => getGameKeyForOrganizer(g) === getGameKeyForOrganizer(game));
            if (index !== -1) {
              currentGameIndex = index;
              organizerViewBtn.click();
              displayCurrentGame();
            }
          });
          gameItem.addEventListener('mouseenter', () => {
            gameItem.style.background = 'rgba(255,255,255,0.08)';
            gameItem.style.transform = 'translateY(-2px)';
          });
          gameItem.addEventListener('mouseleave', () => {
            gameItem.style.background = 'rgba(255,255,255,0.03)';
            gameItem.style.transform = 'translateY(0)';
          });
          gamesGrid.appendChild(gameItem);
        });
        
        categoryDiv.appendChild(gamesGrid);
      }
      
      container.appendChild(categoryDiv);
    });
  }
  
  // Update moderation UI with current settings
  function updateModerationUI() {
    const profanityToggle = document.getElementById('profanityFilterToggle');
    const spamToggle = document.getElementById('spamDetectionToggle');
    const rateLimitToggle = document.getElementById('rateLimitToggle');
    const capsRatioSlider = document.getElementById('capsRatioSlider');
    const maxLinksSlider = document.getElementById('maxLinksSlider');
    const maxRepeatsSlider = document.getElementById('maxRepeatsSlider');
    const messagesPerMinSlider = document.getElementById('messagesPerMinSlider');
    const minTimeSlider = document.getElementById('minTimeSlider');
    
    if (profanityToggle) profanityToggle.checked = moderationSettings.profanityFilterEnabled;
    if (spamToggle) spamToggle.checked = moderationSettings.spamDetectionEnabled;
    if (rateLimitToggle) rateLimitToggle.checked = moderationSettings.rateLimitEnabled;
    if (capsRatioSlider) {
      capsRatioSlider.value = moderationSettings.maxCapsRatio * 100;
      updateSliderValue('capsRatioValue', capsRatioSlider.value);
    }
    if (maxLinksSlider) {
      maxLinksSlider.value = moderationSettings.maxLinksPerMessage;
      updateSliderValue('maxLinksValue', maxLinksSlider.value);
    }
    if (maxRepeatsSlider) {
      maxRepeatsSlider.value = moderationSettings.maxRepeatedChars;
      updateSliderValue('maxRepeatsValue', maxRepeatsSlider.value);
    }
    if (messagesPerMinSlider) {
      messagesPerMinSlider.value = moderationSettings.maxMessagesPerMinute;
      updateSliderValue('messagesPerMinValue', messagesPerMinSlider.value);
    }
    if (minTimeSlider) {
      minTimeSlider.value = moderationSettings.minTimeBetweenMessages / 1000;
      updateSliderValue('minTimeValue', minTimeSlider.value);
    }
  }
  
  function updateSliderValue(id, value) {
    const element = document.getElementById(id);
    if (element) element.textContent = value;
  }
  
  // Update profanity words list display
  function updateProfanityWordsList() {
    const list = document.getElementById('profanityWordsList');
    if (!list) return;
    
    if (PROFANITY_WORDS.length === 0) {
      list.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5); margin:0; padding:20px;">No words added yet</p>';
      return;
    }
    
    list.innerHTML = PROFANITY_WORDS.map(word => `
      <div style="background:rgba(156,39,176,0.2); border:1px solid rgba(156,39,176,0.4); padding:8px 12px; border-radius:8px; display:flex; align-items:center; gap:10px;">
        <span style="color:#ffffff; font-size:13px;">${word}</span>
        <button class="removeProfanityWordBtn" data-word="${word}" style="background:#dc3545; border:none; color:#ffffff; width:24px; height:24px; border-radius:5px; cursor:pointer; font-size:12px; padding:0;">
          <i class="fas fa-times"></i>
        </button>
      </div>
    `).join('');
    
    // Add remove listeners
    list.querySelectorAll('.removeProfanityWordBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const word = btn.getAttribute('data-word');
        removeProfanityWord(word);
      });
    });
  }
  
  // Add profanity word
  const addProfanityWordBtn = document.getElementById('addProfanityWordBtn');
  const addProfanityWordInput = document.getElementById('addProfanityWordInput');
  
  addProfanityWordBtn?.addEventListener('click', () => {
    const word = addProfanityWordInput?.value.trim().toLowerCase();
    if (!word) return;
    
    if (PROFANITY_WORDS.includes(word)) {
      alert('Word already in list');
      return;
    }
    
    PROFANITY_WORDS.push(word);
    if (db) {
      db.ref('profanityWords').set(PROFANITY_WORDS).then(() => {
        addProfanityWordInput.value = '';
        updateProfanityWordsList();
      });
    } else {
      updateProfanityWordsList();
    }
  });
  
  addProfanityWordInput?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      addProfanityWordBtn?.click();
    }
  });
  
  // Remove profanity word
  function removeProfanityWord(word) {
    PROFANITY_WORDS = PROFANITY_WORDS.filter(w => w !== word);
    if (db) {
      db.ref('profanityWords').set(PROFANITY_WORDS);
    }
    updateProfanityWordsList();
  }
  
  // Settings toggles
  document.getElementById('profanityFilterToggle')?.addEventListener('change', (e) => {
    moderationSettings.profanityFilterEnabled = e.target.checked;
    saveModerationSettings();
  });
  
  document.getElementById('spamDetectionToggle')?.addEventListener('change', (e) => {
    moderationSettings.spamDetectionEnabled = e.target.checked;
    saveModerationSettings();
  });
  
  document.getElementById('rateLimitToggle')?.addEventListener('change', (e) => {
    moderationSettings.rateLimitEnabled = e.target.checked;
    saveModerationSettings();
  });
  
  // Sliders
  document.getElementById('capsRatioSlider')?.addEventListener('input', (e) => {
    moderationSettings.maxCapsRatio = e.target.value / 100;
    updateSliderValue('capsRatioValue', e.target.value);
    saveModerationSettings();
  });
  
  document.getElementById('maxLinksSlider')?.addEventListener('input', (e) => {
    moderationSettings.maxLinksPerMessage = parseInt(e.target.value);
    updateSliderValue('maxLinksValue', e.target.value);
    saveModerationSettings();
  });
  
  document.getElementById('maxRepeatsSlider')?.addEventListener('input', (e) => {
    moderationSettings.maxRepeatedChars = parseInt(e.target.value);
    updateSliderValue('maxRepeatsValue', e.target.value);
    saveModerationSettings();
  });
  
  document.getElementById('messagesPerMinSlider')?.addEventListener('input', (e) => {
    moderationSettings.maxMessagesPerMinute = parseInt(e.target.value);
    updateSliderValue('messagesPerMinValue', e.target.value);
    saveModerationSettings();
  });
  
  document.getElementById('minTimeSlider')?.addEventListener('input', (e) => {
    moderationSettings.minTimeBetweenMessages = parseInt(e.target.value) * 1000;
    updateSliderValue('minTimeValue', e.target.value);
    saveModerationSettings();
  });
  
  // Save moderation settings to Firebase
  function saveModerationSettings() {
    if (db) {
      db.ref('moderationSettings').set(moderationSettings);
    }
  }
  
  // Update banned users list
  function updateBannedUsersList() {
    const list = document.getElementById('bannedUsersList');
    const count = document.getElementById('bannedUsersCount');
    if (!list) return;
    
    const bannedList = Object.entries(bannedUsers);
    if (count) count.textContent = bannedList.length;
    
    if (bannedList.length === 0) {
      list.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5); margin:0; padding:20px;">No banned users</p>';
      return;
    }
    
    list.innerHTML = bannedList.map(([uid, banData]) => {
      const expiresAt = banData.expiresAt ? new Date(banData.expiresAt).toLocaleString() : 'Permanent';
      const bannedAt = new Date(banData.bannedAt).toLocaleString();
      
      return `
        <div style="background:rgba(220,53,69,0.1); border:1px solid rgba(220,53,69,0.3); padding:12px; border-radius:10px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <div style="color:#ff6b6b; font-weight:600; font-size:14px;">${banData.username || 'Unknown'}</div>
              <div style="color:rgba(255,255,255,0.6); font-size:11px; margin-top:4px;">UID: ${uid.substring(0, 12)}...</div>
            </div>
            <button class="unbanUserBtn" data-uid="${uid}" style="background:#28a745; border:none; color:#ffffff; padding:6px 12px; border-radius:6px; cursor:pointer; font-size:12px; font-weight:600;">
              Unban
            </button>
          </div>
          <div style="color:rgba(255,255,255,0.7); font-size:11px;">
            Banned: ${bannedAt} | Expires: ${expiresAt}
          </div>
        </div>
      `;
    }).join('');
    
    // Add unban listeners
    list.querySelectorAll('.unbanUserBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const uid = btn.getAttribute('data-uid');
        if (confirm('Unban this user?')) {
          delete bannedUsers[uid];
          if (db) {
            db.ref(`bannedUsers/${uid}`).remove();
          }
          updateBannedUsersList();
        }
      });
    });
  }
  
  // Update moderation statistics
  function updateModerationStats() {
    const blockedCount = document.getElementById('blockedMessagesCount');
    const totalBans = document.getElementById('totalBansCount');
    const spamDetected = document.getElementById('spamDetectedCount');
    const activeUsers = document.getElementById('activeUsersCount');
    
    if (blockedCount) blockedCount.textContent = moderationStats.blockedMessages || 0;
    if (totalBans) totalBans.textContent = moderationStats.totalBans || Object.keys(bannedUsers).length;
    if (spamDetected) spamDetected.textContent = moderationStats.spamDetected || 0;
    if (activeUsers) {
      // Count unique users who sent messages recently
      const recentUsers = new Set();
      Object.values(userMessageCounts).forEach(messages => {
        messages.forEach(time => {
          if (Date.now() - time < 300000) { // Last 5 minutes
            recentUsers.add(time);
          }
        });
      });
      activeUsers.textContent = recentUsers.size || 0;
    }
  }
  
  // Live chat monitor
  let liveChatMonitorListener = null;
  function startLiveChatMonitor() {
    const monitor = document.getElementById('liveChatMonitor');
    if (!monitor || !db) return;
    
    // Clear existing listener
    if (liveChatMonitorListener) {
      db.ref('chat').off('child_added', liveChatMonitorListener);
    }
    
    liveChatMonitorListener = db.ref('chat').limitToLast(10).on('child_added', (snapshot) => {
      const msg = snapshot.val();
      if (!msg) return;
      
      const time = new Date(msg.time).toLocaleTimeString();
      const isBlocked = containsProfanity(msg.text) || isSpam(msg.text);
      const status = isBlocked ? '<span style="color:#dc3545;">⚠️ BLOCKED</span>' : '<span style="color:#28a745;">✓ Allowed</span>';
      
      const entry = document.createElement('div');
      entry.style.cssText = 'padding:8px 12px; background:rgba(0,0,0,0.3); border-radius:8px; margin-bottom:6px; font-size:12px; border-left:3px solid ' + (isBlocked ? '#dc3545' : '#28a745') + ';';
      entry.innerHTML = `
        <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
          <span style="color:#FFD700; font-weight:600;">${msg.user || 'Unknown'}</span>
          ${status}
        </div>
        <div style="color:rgba(255,255,255,0.8); word-break:break-word;">${msg.text.substring(0, 60)}${msg.text.length > 60 ? '...' : ''}</div>
        <div style="color:rgba(255,255,255,0.5); font-size:10px; margin-top:4px;">${time}</div>
      `;
      
      monitor.insertBefore(entry, monitor.firstChild);
      
      // Keep only last 10 entries
      while (monitor.children.length > 10) {
        monitor.removeChild(monitor.lastChild);
      }
    });
  }
  
  // Load moderation panel
  function loadModerationPanel() {
    updateModerationUI();
    updateProfanityWordsList();
    updateBannedUsersList();
    updateModerationStats();
    startLiveChatMonitor();
    
    // Update banned users when they change
    if (db) {
      db.ref('bannedUsers').on('value', () => {
        updateBannedUsersList();
      });
    }
  }
  
  // Track blocked messages
  function trackBlockedMessage(reason) {
    moderationStats.blockedMessages = (moderationStats.blockedMessages || 0) + 1;
    if (reason === 'spam') {
      moderationStats.spamDetected = (moderationStats.spamDetected || 0) + 1;
    }
    if (db) {
      db.ref('moderationStats').set(moderationStats);
    }
    updateModerationStats();
  }
  
  // ---------------- Enhanced Sparkles ----------------
  // Performance detection
  // Enhanced performance detection
  const isLowPerformance = navigator.hardwareConcurrency <= 2 || 
                          (navigator.deviceMemory && navigator.deviceMemory <= 2) ||
                          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                          (navigator.connection && navigator.connection.effectiveType && ['slow-2g', '2g'].includes(navigator.connection.effectiveType)) ||
                          (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
  let storedLitePref = null;
  try { storedLitePref = localStorage.getItem('liteModePreference'); } catch (_) {}
  const userPrefersLite = storedLitePref === 'on';
  const userPrefersFull = storedLitePref === 'off';
  // Treat existing lite-mode flag as a strong performance hint, but allow user override
  const baseLiteMode = document.documentElement.classList.contains('lite-mode') || isLowPerformance;
  const isLiteMode = userPrefersFull ? false : (userPrefersLite || baseLiteMode);
  if (userPrefersFull) {
      document.documentElement.classList.remove('lite-mode');
  }
  // Apply lag-free mode only on low-end devices (respect manual opt-out)
  const enableLagFree = userPrefersFull ? false : (isLowPerformance || isLiteMode);
  if (enableLagFree) {
      document.documentElement.classList.add('lag-free');
  }
  
  // Flag to pause heavy home visuals (background, snow, etc.)
  // Used for non‑home pages and when a fullscreen game is active.
  window.homeVisualsPaused = false;
  window.disableHeavyHomeVisuals = enableLagFree; // kill heavy visuals on low-end/lite devices (keep snow)
  
  // Helper: detect if we are on the main homepage
  function isHomePage() {
      const path = window.location.pathname.replace(/\\/g, '/');
      return path.endsWith('/') || path.endsWith('/index.html') || path === '' || path === '/index.html';
  }
  
  // Helpers to pause/resume home visuals
  function pauseHomeVisuals() {
      window.homeVisualsPaused = true;
  }
  function resumeHomeVisuals() {
      // Only resume animations on the real homepage; heavy visuals stay off in lite-mode via flags.
      if (!isHomePage()) return;
      window.homeVisualsPaused = false;
  }
  
  // Apply reduced animations for low-performance devices
  if (isLowPerformance && !userPrefersFull) {
      document.documentElement.style.setProperty('--animation-duration', '0.1s');
      document.documentElement.classList.add('low-performance-mode');
      // Also enable lite-mode visuals everywhere for low-performance devices
      document.documentElement.classList.add('lite-mode');
  }
  
  // In lite-mode or on non-home pages, pause home-only visuals to reduce lag
  if (!isHomePage()) {
      pauseHomeVisuals();
  }
  const isTabVisible = () => !document.hidden;
  
  function initSparkles() {
      // Skip entirely when heavy visuals are disabled
      if (window.disableHeavyHomeVisuals) return;
      // In lite-mode, skip sparkles entirely to save CPU/GPU
      if (document.documentElement.classList.contains('lite-mode')) return;
      const canvas = document.getElementById('sparkleCanvas');
      if (!canvas) return; // Sparkle canvas is in popup, may not exist yet
      
      const ctx = canvas.getContext('2d');
      let sparkles = [];
      let ripples = [];
      let animationRunning = true;
      let animationId = null; // Track animation frame ID

      function resizeCanvas() {
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;
      }
    window.addEventListener('resize', Utils.debounce(resizeCanvas, 250));
      resizeCanvas();

  function createSparkle() {
      return {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 2 + 0.5,
          vx: (Math.random() - 0.5) * 0.8,
          vy: (Math.random() - 0.5) * 0.8,
          alpha: Math.random() * 0.5 + 0.3,
          baseAlpha: Math.random() * 0.5 + 0.3,
          color: ['#FFD700', '#FFFFFF', '#FFD700', '#FFFF99'][Math.floor(Math.random() * 4)],
          twinkle: Math.random() * 0.05 + 0.01
      };
  }

  // Further reduced particle count for better performance
  const sparkleCount = isLowPerformance ? 15 : 25;
  for(let i = 0; i < sparkleCount; i++) {
      sparkles.push(createSparkle());
  }

  // Pause animations when tab is hidden
  document.addEventListener('visibilitychange', () => {
      const wasRunning = animationRunning;
      animationRunning = isTabVisible();
      if (!animationRunning && wasRunning) {
          // Stop animation loop when pausing
          if (animationId) {
              cancelAnimationFrame(animationId);
              animationId = null;
          }
      } else if (animationRunning && !wasRunning) {
          // Resume animation loop when unpausing
          animationId = requestAnimationFrame(animateSparkles);
      }
  });
  
  // Add ripple effect on mouse move (throttled and limited)
  let lastRippleTime = 0;
  document.addEventListener('mousemove', (e) => {
    const now = Date.now();
    // Throttle ripples to max 1 per second
    if (now - lastRippleTime > 1000 && Math.random() > 0.98 && ripples.length < 3) {
        lastRippleTime = now;
          ripples.push({
              x: e.clientX,
              y: e.clientY,
              radius: 0,
              maxRadius: 100 + Math.random() * 50,
              alpha: 0.6,
              speed: 2 + Math.random()
          });
      }
  }, { passive: true });
  
  // Performance optimization: frame throttling
  let lastSparkleFrame = 0;
  let sparkleFrameSkip = 0;
  
  function animateSparkles() {
      // Stop completely if home visuals are paused (e.g., fullscreen game)
      if (window.homeVisualsPaused) {
          animationRunning = false;
          if (animationId) {
              cancelAnimationFrame(animationId);
              animationId = null;
          }
          return;
      }
      if (!animationRunning || !isTabVisible()) {
          animationId = null;
          return;
      }
    
    const now = performance.now();
    const deltaTime = now - lastSparkleFrame;
    
    // Throttle to ~20fps for sparkles on low-end, 30fps otherwise
    const targetFPS = isLowPerformance ? 50 : 33;
    if (deltaTime < targetFPS) {
        requestAnimationFrame(animateSparkles);
        return;
    }
    lastSparkleFrame = now;
    
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
    // Draw sparkles (optimized)
    const time = Date.now();
      for(let s of sparkles) {
        // Twinkle effect (cached calculation)
        s.alpha = s.baseAlpha + Math.sin(time * s.twinkle) * 0.3;
          s.alpha = Math.max(0.1, Math.min(0.8, s.alpha));
          
        // Mouse attraction (only calculate if close)
          const dx = mouseX - s.x;
          const dy = mouseY - s.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < 40000) { // 200^2, avoid sqrt
            const dist = Math.sqrt(distSq);
              s.vx += dx * 0.0001;
              s.vy += dy * 0.0001;
          }
          
          // Update position
          s.x += s.vx;
          s.y += s.vy;
          
          // Bounce off edges
          if(s.x < 0 || s.x > canvas.width) s.vx *= -1;
          if(s.y < 0 || s.y > canvas.height) s.vy *= -1;
          
          // Keep in bounds
          s.x = Math.max(0, Math.min(canvas.width, s.x));
          s.y = Math.max(0, Math.min(canvas.height, s.y));
          
        // Optimized drawing (reuse color strings)
        const rgb = s.color === '#FFD700' ? '255, 215, 0' : 
                    s.color === '#FFFF99' ? '255, 255, 153' : '255, 255, 255';
        
        // Simple fill instead of gradient for better performance
          ctx.beginPath();
        ctx.arc(s.x, s.y, s.r * 2, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${rgb}, ${s.alpha * 0.5})`;
          ctx.fill();
          
          // Core sparkle
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${rgb}, ${s.alpha})`;
          ctx.fill();
      }
      
    // Draw and update ripples (limit to 5 max)
    if (ripples.length > 5) ripples = ripples.slice(-5);
      for (let i = ripples.length - 1; i >= 0; i--) {
          const ripple = ripples[i];
          ripple.radius += ripple.speed;
          ripple.alpha -= 0.02;
          
          if (ripple.radius > ripple.maxRadius || ripple.alpha <= 0) {
              ripples.splice(i, 1);
              continue;
          }
          
          ctx.strokeStyle = `rgba(255, 215, 0, ${ripple.alpha})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
          ctx.stroke();
      }
      
      animationId = requestAnimationFrame(animateSparkles);
      }
      animateSparkles();
  }
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
          console.time('initSparkles');
          initSparkles();
          console.timeEnd('initSparkles');
      });
  } else {
      setTimeout(() => {
          console.time('initSparkles');
          initSparkles();
          console.timeEnd('initSparkles');
      }, 100);
  }
  let mouseX = 0, mouseY = 0;
  let mouseTrail = [];
  let clickRipples = [];
  const maxTrailLength = 20;
  
  function initInteractiveBackground() {
        // In lite-mode, skip interactive background entirely to save CPU/GPU
        if (document.documentElement.classList.contains('lite-mode')) return;
      const interactiveBg = document.getElementById('interactiveBackground');
      if (!interactiveBg) return;
      
      const bgCtx = interactiveBg.getContext('2d');
      
      function resizeInteractiveBg() {
          interactiveBg.width = window.innerWidth;
          interactiveBg.height = window.innerHeight;
      }
    window.addEventListener('resize', Utils.debounce(resizeInteractiveBg, 250));
      resizeInteractiveBg();
    let mouseMoved = false;
    let lastBgFrame = 0;
    let animationRunning = true;
    let animationId = null; // Track animation frame ID
    const maxTrailLengthOptimized = isLowPerformance ? 8 : 12;

    const handleMouseMove = (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        mouseMoved = true;
          mouseTrail.push({ x: mouseX, y: mouseY, time: Date.now() });
          if (mouseTrail.length > maxTrailLengthOptimized) {
              mouseTrail.shift();
          }
    };
    document.addEventListener('mousemove', handleMouseMove, { passive: true, capture: true });

      // Pause animations when tab is hidden
      document.addEventListener('visibilitychange', () => {
          const wasRunning = animationRunning;
          animationRunning = isTabVisible();
          if (!animationRunning && wasRunning) {
              // Stop animation loop when pausing
              if (animationId) {
                  cancelAnimationFrame(animationId);
                  animationId = null;
              }
          } else if (animationRunning && !wasRunning) {
              // Resume animation loop when unpausing
              animationId = requestAnimationFrame(animateInteractiveBg);
          }
      });
      
      const handleClick = (e) => {
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.closest('button') || e.target.closest('input')) {
            return;
        }
        if (clickRipples.length < 3) { // Limit ripples
          clickRipples.push({
              x: e.clientX,
              y: e.clientY,
              radius: 0,
              maxRadius: 300,
              alpha: 0.8,
              speed: 5
          });
        }
    };
      document.addEventListener('click', handleClick, { passive: true, capture: true });
    
        function animateInteractiveBg() {
          // Stop completely if home visuals are paused (e.g., fullscreen game)
          if (window.homeVisualsPaused) {
              animationRunning = false;
              if (animationId) {
                  cancelAnimationFrame(animationId);
                  animationId = null;
              }
              return;
          }
          if (!animationRunning || !isTabVisible()) {
              animationId = null;
              return;
          }
        
        const now = performance.now();
        // Throttle to ~20fps on low-end, 30fps otherwise
        const targetFPS = isLowPerformance ? 50 : 33;
        if (now - lastBgFrame < targetFPS) {
            requestAnimationFrame(animateInteractiveBg);
            return;
        }
        lastBgFrame = now;
        
        try {
          bgCtx.clearRect(0, 0, interactiveBg.width, interactiveBg.height);
          
            // Only draw mouse glow if mouse has moved recently
            if (mouseMoved) {
          const gradient = bgCtx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 500);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.08)');
                gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.03)');
          gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
          bgCtx.fillStyle = gradient;
          bgCtx.fillRect(0, 0, interactiveBg.width, interactiveBg.height);
                mouseMoved = false;
            }
          
            // Limit trail length and optimize drawing
            const trailLimit = Math.min(mouseTrail.length, maxTrailLengthOptimized);
            for (let i = 0; i < trailLimit; i++) {
              const point = mouseTrail[i];
              const age = Date.now() - point.time;
                if (age > 800) continue;
              const alpha = Math.max(0, 1 - age / 800);
                const size = 3 * alpha;
              
              bgCtx.beginPath();
              bgCtx.arc(point.x, point.y, size, 0, Math.PI * 2);
                bgCtx.fillStyle = `rgba(255, 215, 0, ${alpha * 0.4})`;
              bgCtx.fill();
          }
          
            // Limit ripples to 3 max
            if (clickRipples.length > 3) clickRipples = clickRipples.slice(-3);
          for (let i = clickRipples.length - 1; i >= 0; i--) {
              const ripple = clickRipples[i];
              ripple.radius += ripple.speed;
              ripple.alpha -= 0.015;
              
              if (ripple.radius > ripple.maxRadius || ripple.alpha <= 0) {
                  clickRipples.splice(i, 1);
                  continue;
              }
              
                // Simplified ripple drawing
              bgCtx.strokeStyle = `rgba(255, 215, 0, ${ripple.alpha})`;
                bgCtx.lineWidth = 2;
              bgCtx.beginPath();
              bgCtx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
              bgCtx.stroke();
            }
            
            // Clean up old trail points
          mouseTrail = mouseTrail.filter(p => Date.now() - p.time < 800);
        } catch (err) {
            console.warn('Error in interactive background animation:', err);
        }

        animationId = requestAnimationFrame(animateInteractiveBg);
      }
    
      animateInteractiveBg();
  }
  if (!IS_CHAT_ONLY) {
      if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
              console.time('initInteractiveBackground');
              initInteractiveBackground();
              console.timeEnd('initInteractiveBackground');
          });
      } else {
          console.time('initInteractiveBackground');
          initInteractiveBackground();
          console.timeEnd('initInteractiveBackground');
      }
  }
  
  function initStars() {
        // In lite-mode, skip starfield entirely to save CPU/GPU
        if (document.documentElement.classList.contains('lite-mode')) return;
      const starCanvas = document.getElementById('starCanvas');
      if (!starCanvas) return;
      
      const starCtx = starCanvas.getContext('2d');
    let particles = [];
    let connectionFrame = 0; // Frame counter for connection updates
    const maxConnectionDistance = 150;
    const mouseRepelRadius = 150;
    const mouseRepelStrength = 2.5;
              const particleCount = isLowPerformance ? 25 : 35; // Further reduced for better performance
  
      function resizeStarCanvas() {
        const oldWidth = starCanvas.width;
        const oldHeight = starCanvas.height;
          starCanvas.width = window.innerWidth;
          starCanvas.height = window.innerHeight;
        
        // Scale existing particles to new canvas size
        const scaleX = starCanvas.width / oldWidth;
        const scaleY = starCanvas.height / oldHeight;
        
        for (let i = 0; i < particles.length; i++) {
            particles[i].x *= scaleX;
            particles[i].y *= scaleY;
        }
        
        // Add more particles if canvas got bigger
        const currentCount = particles.length;
        if (currentCount < particleCount) {
            for (let i = currentCount; i < particleCount; i++) {
                particles.push(createParticle());
            }
        }
    }
    window.addEventListener('resize', Utils.debounce(resizeStarCanvas, 250));
      resizeStarCanvas();
  
    function createParticle() {
          return {
              x: Math.random() * starCanvas.width,
              y: Math.random() * starCanvas.height,
            vx: (Math.random() - 0.5) * 1.2,
            vy: (Math.random() - 0.5) * 1.2,
            radius: Math.random() * 1.5 + 0.5,
            connections: [] // Array of particle indices this particle is connected to
        };
    }
  
    function updateParticles() {
        if (!starCanvas || !particles || particles.length === 0) return;
        
        const canvasWidth = starCanvas.width;
        const canvasHeight = starCanvas.height;
        
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') continue;
            
            // Mouse repulsion - stronger and more noticeable
            const dx = mouseX - p.x;
            const dy = mouseY - p.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            if (dist < mouseRepelRadius && dist > 0 && isFinite(dist)) {
                const force = Math.pow((mouseRepelRadius - dist) / mouseRepelRadius, 1.5);
                const angle = Math.atan2(dy, dx);
                if (isFinite(angle) && isFinite(force)) {
                    p.vx -= Math.cos(angle) * force * mouseRepelStrength;
                    p.vy -= Math.sin(angle) * force * mouseRepelStrength;
                }
            }
            
            // Update position
            p.x += p.vx;
            p.y += p.vy;
            
            // Clamp to valid bounds first (prevent out of bounds)
            const minX = p.radius;
            const maxX = canvasWidth - p.radius;
            const minY = p.radius;
            const maxY = canvasHeight - p.radius;
            
            // Boundary bouncing with validation
            if (p.x < minX || !isFinite(p.x)) {
                p.x = Math.max(minX, 0);
                p.vx = -p.vx * 0.8;
            }
            if (p.x > maxX || !isFinite(p.x)) {
                p.x = Math.min(maxX, canvasWidth);
                p.vx = -p.vx * 0.8;
            }
            if (p.y < minY || !isFinite(p.y)) {
                p.y = Math.max(minY, 0);
                p.vy = -p.vy * 0.8;
            }
            if (p.y > maxY || !isFinite(p.y)) {
                p.y = Math.min(maxY, canvasHeight);
                p.vy = -p.vy * 0.8;
            }
            
            // Ensure values are finite
            if (!isFinite(p.x)) p.x = canvasWidth / 2;
            if (!isFinite(p.y)) p.y = canvasHeight / 2;
            if (!isFinite(p.vx)) p.vx = 0;
            if (!isFinite(p.vy)) p.vy = 0;
            
            // Friction
            p.vx *= 0.99;
            p.vy *= 0.99;
            
            // Limit velocity
            const maxVel = 4;
            const vel = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            if (isFinite(vel) && vel > maxVel) {
                p.vx = (p.vx / vel) * maxVel;
                p.vy = (p.vy / vel) * maxVel;
            }
        }
        
        // Update connections - check less frequently for better performance
        connectionFrame++;
        const connectionUpdateInterval = isLowPerformance ? 4 : 2;
        if (connectionFrame % connectionUpdateInterval === 0) {
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                p1.connections = [];
                
                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distSq = dx * dx + dy * dy;
                    
                    // Skip sqrt calculation, compare squared distances
                    if (distSq < maxConnectionDistance * maxConnectionDistance) {
                        p1.connections.push(j);
                    }
                }
            }
        }
    }
  
    let lastStarFrame = 0;
    let animationRunning = true;
    let animationId = null; // Track animation frame ID

      // Pause animations when tab is hidden
      document.addEventListener('visibilitychange', () => {
          const wasRunning = animationRunning;
          animationRunning = isTabVisible();
          if (!animationRunning && wasRunning) {
              // Stop animation loop when pausing
              if (animationId) {
                  cancelAnimationFrame(animationId);
                  animationId = null;
              }
          } else if (animationRunning && !wasRunning) {
              // Resume animation loop when unpausing
              animationId = requestAnimationFrame(animateStars);
          }
      });

      function animateStars() {
          // Stop completely if home visuals are paused (e.g., fullscreen game)
          if (window.homeVisualsPaused) {
              animationRunning = false;
              if (animationId) {
                  cancelAnimationFrame(animationId);
                  animationId = null;
              }
              return;
          }
          if (!animationRunning || !starCanvas || !starCtx || !isTabVisible()) {
              animationId = null;
              return;
          }
        
        const now = performance.now();
        // Throttle to ~15fps on low-end, 20fps otherwise
        const targetFPS = isLowPerformance ? 66 : 50;
        if (now - lastStarFrame < targetFPS) {
            requestAnimationFrame(animateStars);
            return;
        }
        lastStarFrame = now;
        
        try {
            // Validate canvas and context
            if (!starCanvas || !starCtx || !starCanvas.parentNode) {
                animationRunning = false;
                return;
            }
            
            // Ensure canvas size matches window
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            if (starCanvas.width !== newWidth || starCanvas.height !== newHeight) {
                if (newWidth > 0 && newHeight > 0) {
                    resizeStarCanvas();
                } else {
                    requestAnimationFrame(animateStars);
                    return;
                }
            }
            
            // Clear canvas with proper bounds checking
            if (starCanvas.width > 0 && starCanvas.height > 0) {
          starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
            } else {
                requestAnimationFrame(animateStars);
                return;
            }
            
            // Update particles
            updateParticles();
        
        // Draw connections with validation
        starCtx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
        starCtx.lineWidth = 1;
        
        for (let i = 0; i < particles.length; i++) {
            const p1 = particles[i];
            if (!p1 || !isFinite(p1.x) || !isFinite(p1.y)) continue;
            
            for (let j of p1.connections) {
                if (j >= particles.length || j < 0) continue;
                const p2 = particles[j];
                if (!p2 || !isFinite(p2.x) || !isFinite(p2.y)) continue;
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (!isFinite(dist) || dist > maxConnectionDistance) continue;
                
                // Opacity based on distance
                const opacity = Math.max(0, Math.min(1, 1 - (dist / maxConnectionDistance)));
                starCtx.strokeStyle = `rgba(255, 215, 0, ${opacity * 0.3})`;
              
              starCtx.beginPath();
                starCtx.moveTo(p1.x, p1.y);
                starCtx.lineTo(p2.x, p2.y);
                starCtx.stroke();
            }
        }
        
        // Draw particles with validation
        for (let p of particles) {
            if (!p || !isFinite(p.x) || !isFinite(p.y) || !isFinite(p.radius)) continue;
            
            // Clamp position to canvas bounds
            const clampedX = Math.max(p.radius, Math.min(starCanvas.width - p.radius, p.x));
            const clampedY = Math.max(p.radius, Math.min(starCanvas.height - p.radius, p.y));
            
            // Mouse proximity glow
            const dx = mouseX - clampedX;
            const dy = mouseY - clampedY;
            const distSq = dx * dx + dy * dy;
            const mouseEffect = distSq < mouseRepelRadius * mouseRepelRadius 
                ? Math.max(0, 1 - Math.sqrt(distSq) / mouseRepelRadius) 
                : 0;
            
            const glowSize = Math.max(0, Math.min(50, p.radius * (1 + mouseEffect * 0.5)));
            const brightness = Math.max(0, Math.min(1, 0.6 + mouseEffect * 0.4));
            
            // Glow
            starCtx.beginPath();
            starCtx.arc(clampedX, clampedY, glowSize * 2, 0, Math.PI * 2);
            starCtx.fillStyle = `rgba(255, 215, 0, ${brightness * 0.2})`;
              starCtx.fill();
              
            // Core particle
              starCtx.beginPath();
            starCtx.arc(clampedX, clampedY, p.radius, 0, Math.PI * 2);
            starCtx.fillStyle = `rgba(255, 215, 0, ${brightness})`;
              starCtx.fill();
          }
        } catch (err) {
            console.warn('Error in star animation:', err);
        }

        if (animationRunning) {
          animationId = requestAnimationFrame(animateStars);
        } else {
          animationId = null;
        }
      }
      animateStars();
  }
  
  // Initialize after DOM is ready
  if (!IS_CHAT_ONLY) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            console.time('initStars');
            initStars();
            console.timeEnd('initStars');
        });
      } else {
        console.time('initStars');
        initStars();
        console.timeEnd('initStars');
      }
  }
  
  // ================= Christmas Snow Animation =================
  function initSnow() {
      const snowCanvas = document.getElementById('snowCanvas');
      if (!snowCanvas) return;
      
      const ctx = snowCanvas.getContext('2d');
      let snowflakes = [];
      let animationRunning = true;
      let animationId = null; // Track animation frame ID
      const snowflakeCount = isLowPerformance ? 10 : 14; // Keep snow but lighten GPU load

      // Pause animations when tab is hidden
      document.addEventListener('visibilitychange', () => {
          const wasRunning = animationRunning;
          animationRunning = isTabVisible();
          if (!animationRunning && wasRunning) {
              // Stop animation loop when pausing
              if (animationId) {
                  cancelAnimationFrame(animationId);
                  animationId = null;
              }
          } else if (animationRunning && !wasRunning) {
              // Resume animation loop when unpausing
              animationId = requestAnimationFrame(animateSnow);
          }
      });

      function resizeSnowCanvas() {
          snowCanvas.width = window.innerWidth;
          snowCanvas.height = window.innerHeight;
          snowflakes = [];
          for (let i = 0; i < snowflakeCount; i++) {
              snowflakes.push(createSnowflake());
          }
      }
      
      function createSnowflake() {
          return {
              x: Math.random() * snowCanvas.width,
              y: Math.random() * snowCanvas.height,
              radius: Math.random() * 3 + 1,
              speed: Math.random() * 2 + 0.5,
              opacity: Math.random() * 0.5 + 0.5,
              angle: Math.random() * Math.PI * 2,
              spinSpeed: (Math.random() - 0.5) * 0.1
          };
      }
      
      let lastSnowFrame = 0;
        function animateSnow() {
            // Stop completely if home visuals are paused (e.g., fullscreen game)
            if (window.homeVisualsPaused) {
                animationRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                return;
            }
            if (!snowCanvas || !ctx || !animationRunning || !isTabVisible()) {
                animationId = null;
                return;
            }
          
          const now = performance.now();
          // Throttle to ~15fps on low-end, 20fps otherwise
          const targetFPS = isLowPerformance ? 66 : 50;
          if (now - lastSnowFrame < targetFPS) {
              requestAnimationFrame(animateSnow);
              return;
          }
          lastSnowFrame = now;
          
          ctx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
          
          // Batch drawing operations - set shadow once
          ctx.shadowBlur = 8;
          ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
          
          for (let flake of snowflakes) {
              flake.y += flake.speed;
              flake.x += Math.sin(flake.angle) * 0.5;
              flake.angle += flake.spinSpeed;
              
              if (flake.y > snowCanvas.height) {
                  flake.y = -10;
                  flake.x = Math.random() * snowCanvas.width;
              }
              
              if (flake.x < 0) flake.x = snowCanvas.width;
              if (flake.x > snowCanvas.width) flake.x = 0;
              
              ctx.beginPath();
              ctx.arc(flake.x, flake.y, flake.radius, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 255, 255, ${flake.opacity})`;
              ctx.fill();
          }
          
          ctx.shadowBlur = 0;
          animationId = requestAnimationFrame(animateSnow);
      }
      
      window.addEventListener('resize', Utils.debounce(resizeSnowCanvas, 250));
      resizeSnowCanvas();
      animateSnow();
  }
  
  if (!IS_CHAT_ONLY) {
      if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
              console.time('initSnow');
              initSnow();
              console.timeEnd('initSnow');
          });
      } else {
          console.time('initSnow');
          initSnow();
          console.timeEnd('initSnow');
      }
  }
  
  
  const contextMenu = document.createElement('div');
  contextMenu.id = 'customContextMenu';
  contextMenu.innerHTML = `
      <button class="menu-item" id="menuHome">🏠 Home</button>
      <button class="menu-item" id="menuRefresh">🔄 Refresh</button>
      <button class="menu-item" id="menuBack">⬅️ Back</button>
      <button class="menu-item" id="menuForward">➡️ Forward</button>
  `;
  document.body.appendChild(contextMenu);
  
  // Context menu event listeners
  document.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      contextMenu.style.left = e.clientX + 'px';
      contextMenu.style.top = e.clientY + 'px';
      contextMenu.style.display = 'block';
  });
  
  document.addEventListener('click', () => {
      contextMenu.style.display = 'none';
  });
  
  // Menu actions
  document.getElementById('menuHome')?.addEventListener('click', () => {
      window.location.href = window.location.origin + window.location.pathname;
  });
  
  document.getElementById('menuRefresh')?.addEventListener('click', () => {
      window.location.reload();
  });
  
  document.getElementById('menuBack')?.addEventListener('click', () => {
      window.history.back();
  });
  
  document.getElementById('menuForward')?.addEventListener('click', () => {
      window.history.forward();
  });
  
  // Enhanced context menu UI & options
  (function enhanceContextMenu() {
      const menu = document.getElementById('customContextMenu');
      if (!menu) return;
      
      menu.innerHTML = `
          <div class="menu-section-label">Quick actions</div>
          <button class="menu-item" id="menuHome">
              <i class="fas fa-home"></i><span>Go to homepage</span>
          </button>
          <button class="menu-item" id="menuAllGames">
              <i class="fas fa-th-large"></i><span>Browse all games</span>
          </button>
          <button class="menu-item" id="menuRandomGame">
              <i class="fas fa-random"></i><span>Play a random game</span>
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menuRefresh">
              <i class="fas fa-rotate-right"></i><span>Refresh page</span>
          </button>
          <button class="menu-item" id="menuBack">
              <i class="fas fa-arrow-left"></i><span>Go back</span>
          </button>
          <button class="menu-item" id="menuForward">
              <i class="fas fa-arrow-right"></i><span>Go forward</span>
          </button>
          <button class="menu-item" id="menuFullscreenToggle">
              <i class="fas fa-expand"></i><span>Toggle fullscreen</span>
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menuCopyLink">
              <i class="fas fa-link"></i><span>Copy page link</span>
          </button>
      `;
      
      const path = window.location.pathname || '';
      
      const homeBtn = document.getElementById('menuHome');
      homeBtn?.addEventListener('click', () => {
          let homePath = 'index.html';
          if (path.includes('/games/') || path.includes('/pages/')) {
              homePath = '../index.html';
          }
          window.location.href = homePath;
      });
      
      const allGamesBtn = document.getElementById('menuAllGames');
      allGamesBtn?.addEventListener('click', () => {
          let allGamesPath = 'all-games.html';
          if (path.includes('/games/')) {
              allGamesPath = '../all-games.html';
          }
          window.location.href = allGamesPath;
      });
      
      const randomGameBtn = document.getElementById('menuRandomGame');
      randomGameBtn?.addEventListener('click', () => {
          const game = getRandomPlayableGame();
          if (!game) {
              alert('No games available right now. Please try again.');
              return;
          }
          const gamePath = getGamePagePathFromTitle(game.title);
          if (gamePath) window.location.href = gamePath;
      });
      
      const refreshBtn = document.getElementById('menuRefresh');
      refreshBtn?.addEventListener('click', () => window.location.reload());
      
      const backBtn = document.getElementById('menuBack');
      backBtn?.addEventListener('click', () => window.history.back());
      
      const fwdBtn = document.getElementById('menuForward');
      fwdBtn?.addEventListener('click', () => window.history.forward());
      
      const fullscreenBtn = document.getElementById('menuFullscreenToggle');
      fullscreenBtn?.addEventListener('click', () => {
          if (!document.fullscreenElement &&
              !document.webkitFullscreenElement &&
              !document.mozFullScreenElement &&
              !document.msFullscreenElement) {
              const el = document.documentElement;
              if (el.requestFullscreen) el.requestFullscreen();
              else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
              else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
              else if (el.msRequestFullscreen) el.msRequestFullscreen();
          } else {
              if (document.exitFullscreen) document.exitFullscreen();
              else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
              else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
              else if (document.msExitFullscreen) document.msExitFullscreen();
          }
      });
      
      const copyLinkBtn = document.getElementById('menuCopyLink');
      copyLinkBtn?.addEventListener('click', () => {
          const url = window.location.href;
          const showToast = (msg) => {
              const toast = document.createElement('div');
              toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(15,23,42,0.95);color:#e5e7eb;padding:10px 18px;border-radius:999px;border:1px solid rgba(148,163,184,0.5);font-size:12px;z-index:12000;box-shadow:0 10px 30px rgba(15,23,42,0.7);';
              toast.textContent = msg;
              document.body.appendChild(toast);
              setTimeout(() => {
                  toast.style.transition = 'opacity 0.2s ease';
                  toast.style.opacity = '0';
                  setTimeout(() => toast.remove(), 200);
              }, 1600);
          };
          
          if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(url)
                  .then(() => showToast('Link copied to clipboard'))
                  .catch(() => showToast('Unable to copy link'));
          } else {
              const textArea = document.createElement('textarea');
              textArea.value = url;
              textArea.style.position = 'fixed';
              textArea.style.left = '-9999px';
              document.body.appendChild(textArea);
              textArea.focus();
              textArea.select();
              try {
                  document.execCommand('copy');
                  showToast('Link copied to clipboard');
              } catch (e) {
                  showToast('Unable to copy link');
              }
              document.body.removeChild(textArea);
          }
      });
      
      // Improved positioning – override old handler result
      document.addEventListener('contextmenu', (event) => {
          const padding = 8;
          const rect = menu.getBoundingClientRect();
          let x = event.clientX;
          let y = event.clientY;
          if (x + rect.width > window.innerWidth - padding) {
              x = window.innerWidth - rect.width - padding;
          }
          if (y + rect.height > window.innerHeight - padding) {
              y = window.innerHeight - rect.height - padding;
          }
          menu.style.left = `${Math.max(padding, x)}px`;
          menu.style.top = `${Math.max(padding, y)}px`;
      });
  })();
  
const chatContainer = document.getElementById('chatContainer');
const toggleChatBtn = document.getElementById('toggleChatBtn');
  if (toggleChatBtn && toggleChatBtn.tagName === 'A') {
      toggleChatBtn.setAttribute('href', 'javascript:void(0)');
  } else if (toggleChatBtn && toggleChatBtn.tagName === 'BUTTON') {
      toggleChatBtn.setAttribute('type', 'button');
  }
  
  toggleChatBtn?.addEventListener('click', (e) => {
      if (e && typeof e.preventDefault === 'function') e.preventDefault();
      if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
      const chatContainer = document.getElementById('chatContainer');
      if (chatContainer) {
          const isHidden = (chatContainer.style.display === 'none' || chatContainer.style.display === '');
          chatContainer.style.display = 'flex';
          chatContainer.style.visibility = 'visible';
          chatContainer.style.opacity = '1';
          chatContainer.style.zIndex = '20000';
          chatContainer.style.pointerEvents = 'auto';
          if (!isHidden) {
              // allow explicit close by second click if needed
              chatContainer.style.display = 'none';
          }
      } else {
          // Fallback: create a minimal container if missing
          const fallback = document.createElement('div');
          fallback.id = 'chatContainer';
          fallback.className = 'chat-container';
          fallback.style.cssText = 'display:flex; position:fixed; bottom:20px; right:20px; width:380px; max-height:600px; background:rgba(15,15,25,0.95); backdrop-filter:blur(20px); border-radius:16px; border:1px solid rgba(255,215,0,0.2); z-index:20000; box-shadow:0 10px 40px rgba(0,0,0,0.5); flex-direction:column; visibility:visible; opacity:1;';
          document.body.appendChild(fallback);
      }
  });
  
  // ================= Expandable Chat System =================
  const expandChatBtn = document.getElementById('expandChatBtn');
  const minimizeChatBtn = document.getElementById('minimizeChatBtn');
  const fullScreenChatModal = document.getElementById('fullScreenChatModal');
  const closeFullscreenChatBtn = document.getElementById('closeFullscreenChatBtn');
  const fullscreenChatMessages = document.getElementById('fullscreenChatMessages');
  const fullscreenChatInput = document.getElementById('fullscreenChatInput');
  const fullscreenSendBtn = document.getElementById('fullscreenSendBtn');
  const fullscreenChatSidebar = document.getElementById('fullscreenChatSidebar');
  const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
  const fullscreenChatSearchBar = document.getElementById('fullscreenChatSearchBar');
  const fullscreenChatSearchBtn = document.getElementById('fullscreenChatSearchBtn');
  const closeSearchBtn = document.getElementById('closeSearchBtn');
  const fullscreenChatSearchInput = document.getElementById('fullscreenChatSearchInput');
  const fullscreenChatUsersBtn = document.getElementById('fullscreenChatUsersBtn');
  const fullscreenChatOnlineUsers = document.getElementById('fullscreenChatOnlineUsers');
  const onlineUsersCount = document.getElementById('onlineUsersCount');
  
  // Fullscreen chat buttons
  const fullscreenEmojiBtn = document.getElementById('fullscreenEmojiBtn');
  const fullscreenLinkBtn = document.getElementById('fullscreenLinkBtn');
  const fullscreenNameBtn = document.getElementById('fullscreenNameBtn');
  
  // Regular chat buttons
  const attachLinkBtn = document.getElementById('attachLinkBtn');
  const chatAttachmentInput = document.getElementById('chatAttachmentInput');
  
  // Connect fullscreen name button now that it's declared
  fullscreenNameBtn?.addEventListener('click', openNameColorPopup);
  
  // Chat Settings Button
  const chatSettingsBtn = document.getElementById('chatSettingsBtn');
  const fullscreenChatSettingsBtn = document.getElementById('fullscreenChatSettingsBtn');
  
  function openChatSettings() {
    // Create or show settings modal
    let settingsModal = document.getElementById('chatSettingsModal');
    if (!settingsModal) {
        settingsModal = document.createElement('div');
        settingsModal.id = 'chatSettingsModal';
        settingsModal.className = 'chat-settings-modal';
        settingsModal.innerHTML = `
            <div class="chat-settings-content">
                <div class="chat-settings-header">
                    <h2><i class="fas fa-cog"></i> Chat Settings</h2>
                    <button class="chat-settings-close" id="closeChatSettingsBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="chat-settings-body">
                    <div class="chat-setting-item">
                        <label>
                            <input type="checkbox" id="chatSoundEnabled" checked>
                            <span>Enable notification sounds</span>
                        </label>
                    </div>
                    <div class="chat-setting-item">
                        <label>
                            <input type="checkbox" id="chatAutoScroll" checked>
                            <span>Auto-scroll to new messages</span>
                        </label>
                    </div>
                    <div class="chat-setting-item">
                        <label>
                            <input type="checkbox" id="chatShowTimestamps">
                            <span>Show message timestamps</span>
                        </label>
                    </div>
                    <div class="chat-setting-item">
                        <label>
                            <span>Messages per page:</span>
                            <select id="chatMessagesPerPage" class="chat-setting-select">
                                <option value="50">50</option>
                                <option value="100" selected>100</option>
                                <option value="200">200</option>
                            </select>
                        </label>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(settingsModal);
        
        // Close button
        document.getElementById('closeChatSettingsBtn')?.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });
        
        // Close on backdrop click
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.style.display = 'none';
            }
        });
        
        // Load saved settings
        const soundEnabled = localStorage.getItem('chatSoundEnabled') !== 'false';
        const autoScroll = localStorage.getItem('chatAutoScroll') !== 'false';
        const showTimestamps = localStorage.getItem('chatShowTimestamps') === 'true';
        const messagesPerPage = localStorage.getItem('chatMessagesPerPage') || '100';
        
        const soundCheckbox = document.getElementById('chatSoundEnabled');
        const autoScrollCheckbox = document.getElementById('chatAutoScroll');
        const timestampsCheckbox = document.getElementById('chatShowTimestamps');
        const messagesSelect = document.getElementById('chatMessagesPerPage');
        
        if (soundCheckbox) soundCheckbox.checked = soundEnabled;
        if (autoScrollCheckbox) autoScrollCheckbox.checked = autoScroll;
        if (timestampsCheckbox) timestampsCheckbox.checked = showTimestamps;
        if (messagesSelect) messagesSelect.value = messagesPerPage;
        
        // Save settings on change
        soundCheckbox?.addEventListener('change', (e) => {
            localStorage.setItem('chatSoundEnabled', e.target.checked);
        });
        autoScrollCheckbox?.addEventListener('change', (e) => {
            localStorage.setItem('chatAutoScroll', e.target.checked);
        });
        timestampsCheckbox?.addEventListener('change', (e) => {
            localStorage.setItem('chatShowTimestamps', e.target.checked);
        });
        messagesSelect?.addEventListener('change', (e) => {
            localStorage.setItem('chatMessagesPerPage', e.target.value);
        });
    }
    
    settingsModal.style.display = 'flex';
  }
  
  chatSettingsBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    openChatSettings();
  });
  
  fullscreenChatSettingsBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    openChatSettings();
  });
  
// Expand chat to full screen
expandChatBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const url = `${window.location.origin}/pages/chat-only.html`;
    window.open(url, '_blank', 'noopener');
    return false;
});
  
  // Minimize chat - hide the chat container
  minimizeChatBtn?.addEventListener('click', () => {
    try {
        // Close fullscreen modal if open
        if (fullScreenChatModal) {
            fullScreenChatModal.style.display = 'none';
        }
        // Hide the chat container
        const chatContainer = document.getElementById('chatContainer');
        if (chatContainer) {
            chatContainer.style.display = 'none';
        }
    } catch (error) {
        console.error('Error minimizing chat:', error);
    }
  });
  
  // Close full screen chat
closeFullscreenChatBtn?.addEventListener('click', () => {
    try {
        if (fullScreenChatModal) {
            fullScreenChatModal.style.display = 'none';
        }
    } catch (error) {
        console.error('Error closing fullscreen chat:', error);
    }
  });
  
  fullScreenChatModal?.addEventListener('click', (e) => {
    if (e.target === fullScreenChatModal) {
        try {
            fullScreenChatModal.style.display = 'none';
        } catch (error) {
            console.error('Error closing chat on backdrop click:', error);
        }
    }
  });
  
  // Escape key to close fullscreen chat
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && fullScreenChatModal && fullScreenChatModal.style.display !== 'none') {
        try {
            fullScreenChatModal.style.display = 'none';
        } catch (error) {
            console.error('Error closing chat with Escape:', error);
        }
    }
  });
  
  // Toggle sidebar
  toggleSidebarBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    if (fullscreenChatSidebar) {
        const isOpen = fullscreenChatSidebar.classList.contains('open');
        if (isOpen) {
            fullscreenChatSidebar.classList.remove('open');
        } else {
            fullscreenChatSidebar.classList.add('open');
            if (backendApi) {
                loadOnlineUsersBackend();
            } else {
                loadOnlineUsers(); // Legacy Firebase
            }
        }
        const icon = toggleSidebarBtn.querySelector('i');
        if (icon) {
            if (isOpen) {
                icon.classList.remove('fa-chevron-right');
                icon.classList.add('fa-chevron-left');
            } else {
                icon.classList.remove('fa-chevron-left');
                icon.classList.add('fa-chevron-right');
            }
        }
    }
  });
  
  // Initialize sidebar state - open by default on desktop
  if (fullscreenChatSidebar && window.innerWidth > 768) {
    fullscreenChatSidebar.classList.add('open');
    const icon = toggleSidebarBtn?.querySelector('i');
    if (icon) {
        icon.classList.remove('fa-chevron-left');
        icon.classList.add('fa-chevron-right');
    }
  }
  
  // Toggle search bar
  fullscreenChatSearchBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    if (fullscreenChatSearchBar) {
        const isVisible = fullscreenChatSearchBar.style.display !== 'none' && fullscreenChatSearchBar.style.display !== '';
        if (isVisible) {
            fullscreenChatSearchBar.style.display = 'none';
            if (fullscreenChatSearchInput) {
                fullscreenChatSearchInput.value = '';
                syncChatMessages(); // Restore all messages
            }
        } else {
            fullscreenChatSearchBar.style.display = 'flex';
            setTimeout(() => {
                fullscreenChatSearchInput?.focus();
            }, 100);
        }
    }
  });
  
  closeSearchBtn?.addEventListener('click', () => {
    if (fullscreenChatSearchBar) {
        fullscreenChatSearchBar.style.display = 'none';
        if (fullscreenChatSearchInput) {
            fullscreenChatSearchInput.value = '';
        }
    }
  });
  
  // Search functionality
  fullscreenChatSearchInput?.addEventListener('input', Utils.debounce((e) => {
    const query = e.target.value.toLowerCase().trim();
    if (!query) {
        syncChatMessages();
        return;
    }
    
    // Filter messages
    const messages = fullscreenChatMessages?.querySelectorAll('.chat-message');
    if (messages) {
        messages.forEach(msg => {
            const text = msg.textContent.toLowerCase();
            if (text.includes(query)) {
                msg.style.display = '';
                msg.style.backgroundColor = 'rgba(255, 215, 0, 0.1)';
            } else {
                msg.style.display = 'none';
            }
        });
    }
  }, 300));
  
  // Toggle online users sidebar
  fullscreenChatUsersBtn?.addEventListener('click', () => {
    if (fullscreenChatSidebar) {
        fullscreenChatSidebar.classList.toggle('open');
        if (backendApi) {
            loadOnlineUsersBackend();
        } else {
            if (backendApi) {
                loadOnlineUsersBackend();
            } else {
                loadOnlineUsers();
            }
        }
    }
  });
  
  // Send message function (works for both regular and fullscreen) with moderation
  async function sendChatMessage(inputElement) {
    if (!inputElement || !inputElement.value.trim()) return;
    
    const messageText = inputElement.value.trim();
    
    // Security check: rate limiting via security system
    if (!SecuritySystem.trackRequest('chatMessages', 'chat')) {
        if (typeof notifications !== 'undefined' && notifications.show) {
            notifications.show('Too many messages. Please wait before sending another.', 'warning', 3000);
        }
        return;
    }
    
    // Check rate limiting
    const rateLimitCheck = checkRateLimit(visitorId);
    if (!rateLimitCheck.allowed) {
        if (typeof notifications !== 'undefined' && notifications.show) {
            notifications.show(rateLimitCheck.reason, 'warning', 2000);
        } else {
            alert(rateLimitCheck.reason);
        }
        return;
    }
    
    // Security check: input sanitization
    if (SecuritySystem.containsSuspiciousCode(messageText)) {
        SecuritySystem.blockIP(SecuritySystem.getClientIP(), 'Suspicious message content');
        if (typeof notifications !== 'undefined' && notifications.show) {
            notifications.show('Message blocked by security system', 'error', 3000);
        }
        inputElement.value = '';
        return;
    }
    
    // Check for profanity
    if (containsProfanity(messageText)) {
        trackBlockedMessage('profanity');
        if (typeof notifications !== 'undefined' && notifications.show) {
            notifications.show('Message contains inappropriate content', 'error', 2000);
        } else {
            alert('Message contains inappropriate content');
        }
        inputElement.value = '';
        return;
    }
    
    // Check for spam
    if (isSpam(messageText)) {
        trackBlockedMessage('spam');
        if (typeof notifications !== 'undefined' && notifications.show) {
            notifications.show('Message detected as spam', 'error', 2000);
        } else {
            alert('Message detected as spam');
        }
        inputElement.value = '';
        return;
    }
    
    inputElement.value = '';
    
    // Stop typing indicator
    if (backendApi && chatBackendReady) {
        backendApi.stopTypingIndicator();
    } else if (db) {
        db.ref('chatTyping/' + visitorId).remove().catch(err => console.error('Error removing typing:', err));
    }
    
    // Update rate limiting tracking
    const now = Date.now();
    if (!userMessageCounts[visitorId]) {
        userMessageCounts[visitorId] = [];
    }
    userMessageCounts[visitorId].push(now);
    lastMessageTime[visitorId] = now;
    
    // Prepare payload
    const msgData = {
        user: username,
        text: messageText,
        color: userColor,
        time: now,
        uid: visitorId,
        avatar: userProfile.avatar || 'dY`',
        avatarImage: userProfile.avatarImage || null
    };
    
    // Prefer custom backend socket
    if (backendApi) {
        const connected = await ensureBackendChatConnection();
        if (connected && backendApi) {
            try {
                const sent = await backendApi.sendChatMessage(msgData);
                // Optimistically render immediately
                if (sent && sent.id) {
                    backendChatMessageIds.add(sent.id);
                    renderChatMessage(sent, sent.id, null);
                    if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            } catch (err) {
                console.warn('Send failed via backend', err);
                if (typeof notifications !== 'undefined' && notifications.show) {
                    notifications.show('Message failed to send', 'error', 2000);
                }
                return;
            }
            if (typeof trackActivity === 'function') {
                trackActivity('chat', 1);
            }
            if (typeof addActivity === 'function') {
                addActivity('Sent a chat message');
            }
            return;
        }
    }
    
    // Firebase fallback
    if (db) {
        db.ref('chat').push(msgData).catch(error => {
            console.error('Error sending message:', error);
            if (typeof notifications !== 'undefined' && notifications.show) {
                notifications.show('Error sending message', 'error', 2000);
            }
        });
        
        if (typeof trackActivity === 'function') {
            trackActivity('chat', 1);
        }
        if (typeof addActivity === 'function') {
            addActivity('Sent a chat message');
        }
    } else if (typeof notifications !== 'undefined' && notifications.show) {
        notifications.show('Chat service not available', 'error', 2000);
    }
  }

  // Regular chat send
  const sendChatBtn = document.getElementById('sendChatBtn');
  sendChatBtn?.addEventListener('click', () => {
    const input = document.getElementById('chatInput');
    if (input) sendChatMessage(input);
  });
  
  // Fullscreen chat send
  fullscreenSendBtn?.addEventListener('click', () => {
    if (fullscreenChatInput) sendChatMessage(fullscreenChatInput);
  });
  
  // Enter key for both inputs
  fullscreenChatInput?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        sendChatMessage(fullscreenChatInput);
    }
  });
  
  // Sync messages between regular and fullscreen chat
  function syncChatMessages() {
    const regularMessages = document.getElementById('chatMessages');
    const fullscreenMessages = fullscreenChatMessages;
    
    if (!regularMessages || !fullscreenMessages) return;
    
    // Copy messages from regular to fullscreen
    fullscreenMessages.innerHTML = regularMessages.innerHTML;
    
    // Re-attach delete button handlers for fullscreen messages
    fullscreenMessages.querySelectorAll('[data-msg-id]').forEach(msgDiv => {
        const msgId = msgDiv.getAttribute('data-msg-id');
        const delBtn = msgDiv.querySelector('.chat-delete-btn');
        if (delBtn && msgId && db) {
            // Recreate delete functionality
            delBtn.onclick = (e) => {
                e.stopPropagation();
                if(confirm('Delete this message?')) {
                    db.ref(`chat/${msgId}`).remove().catch(err => {
                        console.error('Error deleting message:', err);
                        if (typeof notifications !== 'undefined' && notifications.show) {
                            notifications.show('Error deleting message', 'error', 2000);
                        }
                    });
                }
            };
        }
    });
    
    // Auto-scroll
    setTimeout(() => {
        fullscreenMessages.scrollTop = fullscreenMessages.scrollHeight;
    }, 50);
  }
  
  // Load online users
  function loadOnlineUsers() {
    if (!fullscreenChatOnlineUsers || !db) return;
    
    db.ref('online').once('value').then(snap => {
        const online = snap.val() || {};
        const onlineIds = Object.keys(online);
        
        if (onlineUsersCount) {
            onlineUsersCount.textContent = onlineIds.length;
        }
        
        // Only load profiles for online users (not all profiles)
        if (onlineIds.length > 0) {
            const profilePromises = onlineIds.map(userId => 
                db.ref(`profiles/${userId}`).once('value').then(profileSnap => ({ id: userId, data: profileSnap.val() }))
            );
            
            Promise.all(profilePromises).then(profileResults => {
                const profiles = {};
                profileResults.forEach(({ id, data }) => {
                    if (data) profiles[id] = data;
                });
                
                const users = onlineIds.map(id => ({
                    id,
                    profile: profiles[id] || {},
                    timestamp: online[id]?.timestamp || Date.now()
                })).sort((a, b) => b.timestamp - a.timestamp);
                
                if (users.length === 0) {
                    fullscreenChatOnlineUsers.innerHTML = '<div class="empty-state">No users online</div>';
                    return;
                }
                
                fullscreenChatOnlineUsers.innerHTML = users.map(({id, profile}) => {
                const avatarStyle = profile.avatarImage 
                    ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                    : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
                const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
                
                return `
                    <div class="online-user-item">
                        <div class="online-user-avatar" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:24px;">
                            ${avatarContent}
                            <div class="online-user-status-dot"></div>
                        </div>
                        <div class="online-user-info">
                            <div class="online-user-name">${profile.username || 'User'}</div>
                            <div class="online-user-status">🟢 Online</div>
                        </div>
                    </div>
                `;
                }).join('');
            }).catch(err => {
                console.error('Error loading profiles:', err);
                // Display without profile data if profile load fails
                const users = onlineIds.map(id => ({
                    id,
                    profile: {},
                    timestamp: online[id]?.timestamp || Date.now()
                })).sort((a, b) => b.timestamp - a.timestamp);
                
                fullscreenChatOnlineUsers.innerHTML = users.map(({id, profile}) => `
                    <div class="online-user-item">
                        <div class="online-user-avatar" style="background: linear-gradient(135deg, #FFD700, #FFA500); display:flex; align-items:center; justify-content:center; font-size:24px;">
                            👤
                            <div class="online-user-status-dot"></div>
                        </div>
                        <div class="online-user-info">
                            <div class="online-user-name">User</div>
                            <div class="online-user-status">🟢 Online</div>
                        </div>
                    </div>
                `).join('');
            });
        } else {
            fullscreenChatOnlineUsers.innerHTML = '<div class="empty-state">No users online</div>';
        }
    }).catch(err => {
        console.error('Error loading online users:', err);
    });
  }

  // Backend override: polling-friendly online users (REST)
  function loadOnlineUsersBackend() {
    if (!fullscreenChatOnlineUsers || !backendApi) return;
    backendApi.getOnlineUsers().then(async (users) => {
        const list = Array.isArray(users) ? users : [];
        if (onlineUsersCount) {
            onlineUsersCount.textContent = list.length;
        }
        if (list.length === 0) {
            fullscreenChatOnlineUsers.innerHTML = '<div class="empty-state">No users online</div>';
            return;
        }
        const profileMap = {};
        try {
            const allProfiles = await backendApi.getAllProfiles();
            if (allProfiles && typeof allProfiles === 'object') {
                Object.assign(profileMap, allProfiles);
            }
        } catch (err) {
            console.warn('Profiles fetch failed, showing bare list', err);
        }
        const rows = list.map(u => {
            const id = u.visitor_id || u.userId || u.visitorId || u.id;
            const profile = profileMap[id] || {};
            const avatarStyle = profile.avatarImage 
                ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
            const avatarContent = profile.avatarImage ? '' : (profile.avatar || '🙂');
            const name = profile.username || u.username || 'User';
            return `
                <div class="online-user">
                    <div class="online-avatar" style="${avatarStyle}">${avatarContent}</div>
                    <div class="online-info">
                        <div class="online-name">${name}</div>
                        <div class="online-status">Online</div>
                    </div>
                </div>
            `;
        }).join('');
        fullscreenChatOnlineUsers.innerHTML = rows || '<div class="empty-state">No users online</div>';
    }).catch(err => {
        console.error('Error loading online users:', err);
        fullscreenChatOnlineUsers.innerHTML = '<div class="empty-state">Error loading users</div>';
    });
  }
  
  // Sync messages when regular chat updates
  const chatMessagesObserver = new MutationObserver(() => {
    if (fullScreenChatModal && fullScreenChatModal.style.display !== 'none') {
        syncChatMessages();
    }
  });
  
  const regularChatMessages = document.getElementById('chatMessages');
  if (regularChatMessages) {
    chatMessagesObserver.observe(regularChatMessages, { childList: true, subtree: true });
  }
  
  // Update online users count periodically
  if (fullscreenChatOnlineUsers) {
    const pollOnline = () => {
        if (backendApi) {
            loadOnlineUsersBackend();
        } else if (db) {
            loadOnlineUsers();
        }
    };
    pollOnline();
    setInterval(pollOnline, 4000); // Every 4 seconds
  }
  
  const themeBtn = document.getElementById('themeBtn');
  const sidePanelThemesBtn = document.getElementById('sidePanelThemesBtn');
  const themeModal = document.getElementById('themeModal');
  const closeThemeBtn = document.getElementById('closeThemeBtn');
  const themeOptions = document.querySelectorAll('.theme-option');
  const seasonalThemes = document.querySelectorAll('.seasonal-theme');
  
  let currentTheme = localStorage.getItem('selectedTheme') || 'default';
  let currentSeasonal = localStorage.getItem('selectedSeasonal') || '';
  
  function applyTheme(theme) {
    // Remove all theme classes
    document.body.className = document.body.className.replace(/theme-\w+/g, '').trim();
    document.body.className = document.body.className.replace(/seasonal-\w+/g, '').trim();
  
    // Apply new theme
    if (theme !== 'default') {
      document.body.classList.add(`theme-${theme}`);
    }
  
    // Apply seasonal theme if exists
    if (currentSeasonal) {
      document.body.classList.add(`seasonal-${currentSeasonal}`);
    }
  
    localStorage.setItem('selectedTheme', theme);
  }
  
  function applySeasonal(season) {
    // Remove existing seasonal classes
    document.body.className = document.body.className.replace(/seasonal-\w+/g, '').trim();
  
    // Apply new seasonal theme
    if (season) {
      document.body.classList.add(`seasonal-${season}`);
    }
  
    currentSeasonal = season;
    localStorage.setItem('selectedSeasonal', season);
  }
  
  // Theme button click
  themeBtn?.addEventListener('click', () => {
    if (themeModal) {
      themeModal.style.display = 'flex';
      themeModal.setAttribute('aria-hidden', 'false');
    }
  });
  
  // Close theme modal
  closeThemeBtn?.addEventListener('click', () => {
    if (themeModal) {
      themeModal.style.display = 'none';
      themeModal.setAttribute('aria-hidden', 'true');
    }
  });

  // Sidebar themes shortcut
  sidePanelThemesBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    themeBtn?.click();
  });
  
  // Theme selection
  themeOptions.forEach(option => {
    option.addEventListener('click', () => {
      const theme = option.dataset.theme;
      applyTheme(theme);
  
      themeOptions.forEach(opt => opt.style.borderColor = opt.dataset.theme === theme ? '#28a745' : '');
    });
  });
  
  // Seasonal theme selection
  seasonalThemes.forEach(theme => {
    theme.addEventListener('click', () => {
      const season = theme.dataset.season;
      applySeasonal(season === currentSeasonal ? '' : season);
      seasonalThemes.forEach(t => t.style.opacity = t.dataset.season === currentSeasonal ? '1' : '0.6');
    });
  });
  
  applyTheme(currentTheme);
  applySeasonal(currentSeasonal);

  console.timeEnd('scriptExecution');

  const achievementsBtn = document.getElementById('achievementsBtn');
  const sidePanelAchievementsBtn = document.getElementById('sidePanelAchievementsBtn');
  const achievementsModal = document.getElementById('achievementsModal');
  const closeAchievementsBtn = document.getElementById('closeAchievementsBtn');
  
  let userStats = JSON.parse(localStorage.getItem('userStats')) || {
    chatMessages: 0,
    drawTime: 0,
    gameTime: 0,
    onlineTime: 0,
    sitesVisited: [],
    themesTried: [],
    dailyMessages: 0,
    lastDailyReset: Date.now()
  };
  const now = Date.now();
  const lastReset = userStats.lastDailyReset;
  const oneDay = 24 * 60 * 60 * 1000;
  if (now - lastReset > oneDay) {
    userStats.dailyMessages = 0;
    userStats.lastDailyReset = now;
  }
  
  function updateAchievements() {
    const chatProgress = Math.min((userStats.chatMessages / 10) * 100, 100);
    const chatProgressEl = document.getElementById('chatProgress');
    if (chatProgressEl) chatProgressEl.style.width = chatProgress + '%';
    const chatCountEl = document.getElementById('chatCount');
    if (chatCountEl) chatCountEl.textContent = userStats.chatMessages + '/10';
    if (userStats.chatMessages >= 10) {
      const chatBadgeEl = document.getElementById('chatBadge');
      if (chatBadgeEl) {
        chatBadgeEl.style.borderColor = 'rgba(255, 215, 0, 0.55)';
        chatBadgeEl.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.14), rgba(0, 212, 255, 0.10))';
      }
    }
    const drawProgress = Math.min((userStats.drawTime / 30) * 100, 100);
    const drawProgressEl = document.getElementById('drawProgress');
    if (drawProgressEl) drawProgressEl.style.width = drawProgress + '%';
    const drawCountEl = document.getElementById('drawCount');
    if (drawCountEl) drawCountEl.textContent = Math.floor(userStats.drawTime) + '/30 min';
    if (userStats.drawTime >= 30) {
      const drawBadgeEl = document.getElementById('drawBadge');
      if (drawBadgeEl) {
        drawBadgeEl.style.borderColor = 'rgba(255, 215, 0, 0.55)';
        drawBadgeEl.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.14), rgba(0, 212, 255, 0.10))';
      }
    }
    const gameProgress = Math.min((userStats.gameTime / 60) * 100, 100);
    const gameProgressEl = document.getElementById('gameProgress');
    if (gameProgressEl) gameProgressEl.style.width = gameProgress + '%';
    const gameCountEl = document.getElementById('gameCount');
    if (gameCountEl) gameCountEl.textContent = Math.floor(userStats.gameTime) + '/60 min';
    if (userStats.gameTime >= 60) {
      const gameBadgeEl = document.getElementById('gameBadge');
      if (gameBadgeEl) {
        gameBadgeEl.style.borderColor = 'rgba(255, 215, 0, 0.55)';
        gameBadgeEl.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.14), rgba(0, 212, 255, 0.10))';
      }
    }
    const socialProgress = Math.min((userStats.onlineTime / 120) * 100, 100);
    const socialProgressEl = document.getElementById('socialProgress');
    if (socialProgressEl) socialProgressEl.style.width = socialProgress + '%';
    const socialCountEl = document.getElementById('socialCount');
    if (socialCountEl) socialCountEl.textContent = Math.floor(userStats.onlineTime) + '/120 min';
    if (userStats.onlineTime >= 120) {
      const socialBadgeEl = document.getElementById('socialBadge');
      if (socialBadgeEl) {
        socialBadgeEl.style.borderColor = 'rgba(255, 215, 0, 0.55)';
        socialBadgeEl.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.14), rgba(0, 212, 255, 0.10))';
      }
    }
    const explorerProgress = Math.min((userStats.sitesVisited.length / 2) * 100, 100);
    const explorerProgressEl = document.getElementById('explorerProgress');
    if (explorerProgressEl) explorerProgressEl.style.width = explorerProgress + '%';
    const explorerCountEl = document.getElementById('explorerCount');
    if (explorerCountEl) explorerCountEl.textContent = userStats.sitesVisited.length + '/2';
    if (userStats.sitesVisited.length >= 2) {
      const explorerBadgeEl = document.getElementById('explorerBadge');
      if (explorerBadgeEl) {
        explorerBadgeEl.style.borderColor = '#28a745';
        explorerBadgeEl.style.background = '#d4edda';
      }
    }
    const themeProgress = Math.min((userStats.themesTried.length / 3) * 100, 100);
    const themeProgressEl = document.getElementById('themeProgress');
    if (themeProgressEl) themeProgressEl.style.width = themeProgress + '%';
    const themeCountEl = document.getElementById('themeCount');
    if (themeCountEl) themeCountEl.textContent = userStats.themesTried.length + '/3';
    if (userStats.themesTried.length >= 3) {
      const themeBadgeEl = document.getElementById('themeBadge');
      if (themeBadgeEl) {
        themeBadgeEl.style.borderColor = '#28a745';
        themeBadgeEl.style.background = '#d4edda';
      }
    }
    const dailyProgress = Math.min((userStats.dailyMessages / 5) * 100, 100);
    const dailyProgressEl = document.getElementById('dailyProgress');
    if (dailyProgressEl) dailyProgressEl.style.width = dailyProgress + '%';
    const dailyCountEl = document.getElementById('dailyCount');
    if (dailyCountEl) dailyCountEl.textContent = userStats.dailyMessages + '/5';
  
    localStorage.setItem('userStats', JSON.stringify(userStats));
  }
  function trackActivity(type, value = 1) {
    switch(type) {
      case 'chat':
        userStats.chatMessages += value;
        userStats.dailyMessages += value;
        break;
      case 'draw':
        userStats.drawTime += value; // value in minutes
        break;
      case 'game':
        userStats.gameTime += value; // value in minutes
        break;
      case 'online':
        userStats.onlineTime += value; // value in minutes
        break;
      case 'site':
        if (!userStats.sitesVisited.includes(value)) {
          userStats.sitesVisited.push(value);
        }
        break;
      case 'theme':
        if (!userStats.themesTried.includes(value)) {
          userStats.themesTried.push(value);
        }
        break;
    }
    updateAchievements();
  }
  achievementsBtn?.addEventListener('click', () => {
    updateAchievements();
    if (achievementsModal) {
      achievementsModal.style.display = 'flex';
      achievementsModal.setAttribute('aria-hidden', 'false');
    }
  });
  sidePanelAchievementsBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    achievementsBtn?.click();
  });
  
  // Close achievements modal
  closeAchievementsBtn?.addEventListener('click', () => {
    if (achievementsModal) {
      achievementsModal.style.display = 'none';
      achievementsModal.setAttribute('aria-hidden', 'true');
    }
  });
  let onlineStartTime = Date.now();
  setInterval(() => {
    const minutes = (Date.now() - onlineStartTime) / (1000 * 60);
    trackActivity('online', minutes - userStats.onlineTime);
    onlineStartTime = Date.now();
  }, 60000);
  let drawingStartTime = null;
  document.getElementById('openDrawingBtn')?.addEventListener('click', () => {
    drawingStartTime = Date.now();
  });
  document.getElementById('closeDrawingBtn')?.addEventListener('click', () => {
    if (drawingStartTime) {
      const minutes = (Date.now() - drawingStartTime) / (1000 * 60);
      trackActivity('draw', minutes);
      drawingStartTime = null;
    }
  });
  let gameStartTime = Date.now();
  setInterval(() => {
    const minutes = (Date.now() - gameStartTime) / (1000 * 60);
    trackActivity('game', minutes - userStats.gameTime);
    gameStartTime = Date.now();
  }, 60000);
  document.getElementById('extraSiteBtn')?.addEventListener('click', () => {
    trackActivity('site', 'extra');
  });
  document.getElementById('privacyBtn')?.addEventListener('click', () => {
    trackActivity('site', 'privacy');
  });
  themeOptions.forEach(option => {
    option.addEventListener('click', () => {
      trackActivity('theme', option.dataset.theme);
    });
  });
  updateAchievements();
  document.addEventListener('keydown', (e) => {
    const safeClick = (id) => {
      const el = document.getElementById(id);
      if (el && typeof el.click === 'function') {
        el.click();
      }
    };
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
    switch(e.key.toLowerCase()) {
      case 'r':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          safeClick('reloadBtn');
        }
        break;
      case 'f':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          safeClick('fullscreenBtn');
        }
        break;
      case 'f5':
        // Allow F5 refresh
        break;
      case '+':
      case '=':
        e.preventDefault();
        safeClick('zoomInBtn');
        break;
      case '-':
        e.preventDefault();
        safeClick('zoomOutBtn');
        break;
      case 'h':
        e.preventDefault();
        safeClick('hideIframeBtn');
        break;
      case 's':
        e.preventDefault();
        safeClick('showIframeBtn');
        break;
      case 'c':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          safeClick('toggleChatBtn');
        }
        break;
      case 'd':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          safeClick('openDrawingBtn');
        }
        break;
      case 't':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          safeClick('themeBtn');
        }
        break;
      case 'a':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          safeClick('achievementsBtn');
        }
        break;
      case 'escape':
        ['themeModal','achievementsModal','drawingModal'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
        });
        break;
    }
  });
  // Removed shortcuts hint toggle on "?" per request
  setInterval(() => {
    localStorage.setItem('userStats', JSON.stringify(userStats));
    localStorage.setItem('selectedTheme', currentTheme);
    localStorage.setItem('selectedSeasonal', currentSeasonal);
  }, 30000);
  const statsBtn = document.getElementById('statsBtn');
  const sidePanelStatsBtn = document.getElementById('sidePanelStatsBtn');
  const statsModal = document.getElementById('statsModal');
  const closeStatsBtn = document.getElementById('closeStatsBtn');
  
  function updateStatsDisplay() {
    document.getElementById('onlineTimeStat').textContent = Math.floor(userStats.onlineTime) + ' min';
    document.getElementById('chatMessagesStat').textContent = userStats.chatMessages;
    document.getElementById('gamingTimeStat').textContent = Math.floor(userStats.gameTime) + ' min';
    document.getElementById('drawingTimeStat').textContent = Math.floor(userStats.drawTime) + ' min';
  
    // Achievement progress bars
    const chatProgress = Math.min((userStats.chatMessages / 10) * 100, 100);
    document.getElementById('chatProgressBar').style.width = chatProgress + '%';
    document.getElementById('chatProgressText').textContent = userStats.chatMessages + '/10';
  
    const drawProgress = Math.min((userStats.drawTime / 30) * 100, 100);
    document.getElementById('drawProgressBar').style.width = drawProgress + '%';
    document.getElementById('drawProgressText').textContent = Math.floor(userStats.drawTime) + '/30 min';
  
    const gameProgress = Math.min((userStats.gameTime / 60) * 100, 100);
    document.getElementById('gameProgressBar').style.width = gameProgress + '%';
    document.getElementById('gameProgressText').textContent = Math.floor(userStats.gameTime) + '/60 min';
  
    // Daily stats
    document.getElementById('dailyMessagesStat').textContent = userStats.dailyMessages;
    document.getElementById('dailyOnlineStat').textContent = Math.floor(userStats.onlineTime) + ' min';
    document.getElementById('sitesVisitedStat').textContent = userStats.sitesVisited.length;
    document.getElementById('themesTriedStat').textContent = userStats.themesTried.length;
  }
  
  // Stats button
  statsBtn?.addEventListener('click', () => {
    updateStatsDisplay();
    if (statsModal) {
      statsModal.style.display = 'flex';
      statsModal.setAttribute('aria-hidden', 'false');
    }
  });
  sidePanelStatsBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    statsBtn?.click();
  });

  // Close stats modal
  closeStatsBtn?.addEventListener('click', () => {
    if (statsModal) {
      statsModal.style.display = 'none';
      statsModal.setAttribute('aria-hidden', 'true');
    }
  });

  
  // ================= Drawing Modal =================
  const drawingModal = document.getElementById('drawingModal');
  const openDrawingBtn = document.getElementById('openDrawingBtn');
  const openDrawingBtnHeader = document.getElementById('openDrawingBtnHeader');
  const closeDrawingBtn = document.getElementById('closeDrawingBtn');
  const drawingIframeOverlay = document.getElementById('drawingIframeOverlay');
  const drawingIframe = document.getElementById('drawingIframe');
  const closeDrawingIframe = document.getElementById('closeDrawingIframe');
  
  function openDrawingIframe() {
      if (drawingIframeOverlay && drawingIframe) {
          drawingIframe.src = 'https://flockmod.com/r/globalgamehall';
          drawingIframeOverlay.style.display = 'flex';
          drawingIframeOverlay.setAttribute('aria-hidden','false');
      }
  }
  
  function openDrawingModal() {
  // Use iframe overlay for drawing
  openDrawingIframe();
  }
  
  openDrawingBtn?.addEventListener('click', openDrawingModal);
  openDrawingBtnHeader?.addEventListener('click', openDrawingModal);
  closeDrawingIframe?.addEventListener('click', () => {
      if (drawingIframeOverlay) {
          drawingIframeOverlay.style.display = 'none';
          drawingIframeOverlay.setAttribute('aria-hidden','true');
          if (drawingIframe) drawingIframe.src = '';
      }
  });
  drawingIframeOverlay?.addEventListener('click', (e) => {
      if (e.target === drawingIframeOverlay) {
          drawingIframeOverlay.style.display = 'none';
          drawingIframeOverlay.setAttribute('aria-hidden','true');
          if (drawingIframe) drawingIframe.src = '';
      }
  });
  
  // Canvas initialization is handled in openDrawingModal function
  closeDrawingBtn?.addEventListener('click', () => {
    if (drawingModal) {
      drawingModal.style.display = 'none';
      drawingModal.setAttribute('aria-hidden','true');
    }
  });
  // click outside to close
  if (drawingModal) {
    drawingModal.addEventListener('click', (e) => {
      if(e.target === drawingModal) {
        drawingModal.style.display = 'none';
        drawingModal.setAttribute('aria-hidden','true');
      }
    });
  }
  
  // ================= Shared Drawing Canvas Script =================
  (function(){
    const container = document.getElementById('sharedCanvasContainer');
    const toggleBtn = document.getElementById('toggleCanvasBtn');
    const canvasWrapper = document.getElementById('canvasArea');
    const canvasEl = document.getElementById('sharedCanvas');
    if (!canvasEl) return; // Exit early if canvas doesn't exist
    const ctx2 = canvasEl.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');
    const sizeSlider = document.getElementById('sizeSlider');
    const sizeLabel = document.getElementById('sizeLabel');
    const clearBtn = document.getElementById('clearCanvasBtn');
    const brushToolBtn = document.getElementById('brushToolBtn');
    const eraserToolBtn = document.getElementById('eraserToolBtn');
  
    // Tool state
    let currentTool = 'brush'; // 'brush' or 'eraser' or 'rectangle' etc
    let drawing = false;
    let currentStroke = [];
    let brushColor = colorPicker.value;
    let brushSize = parseInt(sizeSlider.value,10);
    let brushOpacity = 1;
    let fillShapes = false;
    let shapeStart = null;
    let undoHistory = [];
    let zoomLevel = 1;
    let panX = 0, panY = 0;
    let pushedStrokes = [];
    const drawnIds = new Set(); // stroke IDs already rendered
    let strokesRef = null;
    let metaRef = null;
    let strokesCache = {}; // local cache of strokes by id to allow redraw on resize
    let initialLoadComplete = false; // Flag to prevent duplicate rendering during initial load
    let canvasInitialized = false; // Flag to prevent duplicate initialization
    let canvasListeners = {
        childAdded: null,
        childRemoved: null,
        clear: null,
        cursorsValue: null,
        cursorsAdded: null,
        cursorsRemoved: null
    };
    let canvasPollInterval = null;
  
    // Tool switching
    function resetToolStyles() {
      const tools = ['brushToolBtn', 'eraserToolBtn', 'rectangleToolBtn', 'circleToolBtn', 'lineToolBtn', 'textToolBtn', 'eyedropperBtn'];
      tools.forEach(id => {
        const btn = document.getElementById(id);
        btn.style.background = '#ffffff';
        btn.style.border = '1px solid #ccc';
        btn.style.color = '#333';
      });
    }
  
    function selectTool(tool) {
      currentTool = tool;
      resetToolStyles();
      if(tool === 'brush') {
        brushToolBtn.style.background = '#007bff';
        brushToolBtn.style.border = '1px solid #007bff';
        brushToolBtn.style.color = '#ffffff';
        canvasEl.style.cursor = 'crosshair';
      } else if(tool === 'eraser') {
        eraserToolBtn.style.background = '#ffc107';
        eraserToolBtn.style.border = '1px solid #ffc107';
        eraserToolBtn.style.color = '#000';
        canvasEl.style.cursor = 'cell';
      } else if(tool === 'rectangle') {
        document.getElementById('rectangleToolBtn').style.background = '#28a745';
        document.getElementById('rectangleToolBtn').style.border = '1px solid #28a745';
        document.getElementById('rectangleToolBtn').style.color = '#ffffff';
        canvasEl.style.cursor = 'crosshair';
      } else if(tool === 'circle') {
        document.getElementById('circleToolBtn').style.background = '#17a2b8';
        document.getElementById('circleToolBtn').style.border = '1px solid #17a2b8';
        document.getElementById('circleToolBtn').style.color = '#ffffff';
        canvasEl.style.cursor = 'crosshair';
      } else if(tool === 'line') {
        document.getElementById('lineToolBtn').style.background = '#6c757d';
        document.getElementById('lineToolBtn').style.border = '1px solid #6c757d';
        document.getElementById('lineToolBtn').style.color = '#ffffff';
        canvasEl.style.cursor = 'crosshair';
      } else if(tool === 'text') {
        document.getElementById('textToolBtn').style.background = '#dc3545';
        document.getElementById('textToolBtn').style.border = '1px solid #dc3545';
        document.getElementById('textToolBtn').style.color = '#ffffff';
        canvasEl.style.cursor = 'text';
      } else if(tool === 'eyedropper') {
        document.getElementById('eyedropperBtn').style.background = '#e83e8c';
        document.getElementById('eyedropperBtn').style.border = '1px solid #e83e8c';
        document.getElementById('eyedropperBtn').style.color = '#ffffff';
        canvasEl.style.cursor = 'copy';
      }
    }
  
    function undoLast() {
      // Backend canvas does not support undo yet
      console.warn('Undo not supported in backend canvas mode.');
    }
  
    function saveDrawing() {
      const dataURL = canvasEl.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = 'drawing.png';
      a.click();
    }
  
    function loadDrawing() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if(file) {
          const img = new Image();
          img.onload = () => {
            ctx2.clearRect(0,0,canvasEl.width,canvasEl.height);
            ctx2.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
          };
          img.src = URL.createObjectURL(file);
        }
      };
      input.click();
    }
  
    function applyZoom() {
      ctx2.setTransform(zoomLevel, 0, 0, zoomLevel, panX, panY);
      redrawAllStrokes();
    }
  
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
  
    brushToolBtn?.addEventListener('click', () => selectTool('brush'));
    eraserToolBtn?.addEventListener('click', () => selectTool('eraser'));
    document.getElementById('rectangleToolBtn')?.addEventListener('click', () => selectTool('rectangle'));
    document.getElementById('circleToolBtn')?.addEventListener('click', () => selectTool('circle'));
    document.getElementById('lineToolBtn')?.addEventListener('click', () => selectTool('line'));
    document.getElementById('textToolBtn')?.addEventListener('click', () => selectTool('text'));
    document.getElementById('fillCheckbox')?.addEventListener('change', (e) => fillShapes = e.target.checked);
    document.getElementById('opacitySlider')?.addEventListener('input', (e) => { brushOpacity = parseFloat(e.target.value); const label = document.getElementById('opacityLabel'); if (label) label.textContent = brushOpacity; });
    document.getElementById('undoBtn')?.addEventListener('click', undoLast);
    document.getElementById('eyedropperBtn')?.addEventListener('click', () => selectTool('eyedropper'));
    document.getElementById('saveBtn')?.addEventListener('click', saveDrawing);
    document.getElementById('loadBtn')?.addEventListener('click', loadDrawing);
    document.getElementById('zoomInBtn')?.addEventListener('click', () => { zoomLevel *= 1.2; applyZoom(); });
    document.getElementById('zoomOutBtn')?.addEventListener('click', () => { zoomLevel /= 1.2; applyZoom(); });
    selectTool('brush');
  
    // Resize helper
    function resizeCanvasToDisplay() {
      const ratio = window.devicePixelRatio || 1;
      const styleW = Math.min(window.innerWidth - 60, 1000);
      const styleH = Math.min(window.innerHeight * 0.7, 700);
      canvasEl.width = styleW * ratio;
      canvasEl.height = styleH * ratio;
      canvasEl.style.width = styleW + 'px';
      canvasEl.style.height = styleH + 'px';
      ctx2.setTransform(ratio, 0, 0, ratio, 0, 0);
      // After resizing the canvas (which clears its bitmap), redraw cached strokes
      redrawAllStrokes();
    }
    window.addEventListener('resize', resizeCanvasToDisplay);
    resizeCanvasToDisplay();
  
    // Show/hide canvas area toggle
    toggleBtn?.addEventListener('click', () => {
      if (canvasWrapper.style.display === 'none' || canvasWrapper.style.display === '') {
        canvasWrapper.style.display = 'block';
        toggleBtn.textContent = 'Close Canvas';
        resizeCanvasToDisplay();
      } else {
        canvasWrapper.style.display = 'none';
        toggleBtn.textContent = 'Open Canvas';
      }
    });
  
    // UI bindings
    colorPicker?.addEventListener('input', (e) => brushColor = e.target.value);
    sizeSlider?.addEventListener('input', (e) => { brushSize = parseInt(e.target.value,10); if (sizeLabel) sizeLabel.textContent = brushSize; });
  
    // Convert screen coords to canvas coords
    function getCanvasPoint(e) {
      const rect = canvasEl.getBoundingClientRect();
      const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX);
      const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY);
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      return { x: Math.round(x), y: Math.round(y) };
    }
  
    function drawStrokeLocally(stroke, opts={}) {
      if(!stroke || !stroke.points || stroke.points.length===0) return;
      
      if(stroke.type === 'erase') {
        ctx2.save();
        ctx2.globalCompositeOperation = 'destination-out';
        ctx2.strokeStyle = 'rgba(0,0,0,1)';
        ctx2.lineJoin = 'round';
        ctx2.lineCap = 'round';
        ctx2.lineWidth = stroke.size;
        ctx2.beginPath();
        const pts = stroke.points;
        ctx2.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){
          ctx2.lineTo(pts[i].x, pts[i].y);
        }
        ctx2.stroke();
        ctx2.restore();
      } else if(stroke.type === 'rectangle') {
        ctx2.globalAlpha = stroke.opacity || 1;
        ctx2.strokeStyle = stroke.color;
        ctx2.lineWidth = stroke.size || 1;
        const x = Math.min(stroke.points[0].x, stroke.points[1].x);
        const y = Math.min(stroke.points[0].y, stroke.points[1].y);
        const width = Math.abs(stroke.points[1].x - stroke.points[0].x);
        const height = Math.abs(stroke.points[1].y - stroke.points[0].y);
        if(stroke.fill) {
          ctx2.fillStyle = stroke.color;
          ctx2.fillRect(x, y, width, height);
        } else {
          ctx2.strokeRect(x, y, width, height);
        }
      } else if(stroke.type === 'circle') {
        ctx2.globalAlpha = stroke.opacity || 1;
        ctx2.strokeStyle = stroke.color;
        ctx2.lineWidth = stroke.size || 1;
        const centerX = stroke.points[0].x;
        const centerY = stroke.points[0].y;
        const radius = Math.sqrt((stroke.points[1].x - centerX)**2 + (stroke.points[1].y - centerY)**2);
        ctx2.beginPath();
        ctx2.arc(centerX, centerY, radius, 0, Math.PI * 2);
        if(stroke.fill) {
          ctx2.fillStyle = stroke.color;
          ctx2.fill();
        } else {
          ctx2.stroke();
        }
      } else if(stroke.type === 'line') {
        ctx2.globalAlpha = stroke.opacity || 1;
        ctx2.strokeStyle = stroke.color;
        ctx2.lineWidth = stroke.size || 1;
        ctx2.beginPath();
        ctx2.moveTo(stroke.points[0].x, stroke.points[0].y);
        ctx2.lineTo(stroke.points[1].x, stroke.points[1].y);
        ctx2.stroke();
      } else if(stroke.type === 'text') {
        ctx2.globalAlpha = stroke.opacity || 1;
        ctx2.fillStyle = stroke.color;
        ctx2.font = `${stroke.fontSize || 16}px Arial`;
        ctx2.fillText(stroke.text, stroke.x, stroke.y);
      } else {
        // default brush
        ctx2.globalAlpha = stroke.opacity || 1;
        ctx2.lineJoin = 'round';
        ctx2.lineCap = 'round';
        ctx2.strokeStyle = stroke.color;
        ctx2.lineWidth = stroke.size;
        ctx2.beginPath();
        const pts = stroke.points;
        ctx2.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){
          ctx2.lineTo(pts[i].x, pts[i].y);
        }
        ctx2.stroke();
      }
    }
  
    // Redraw all strokes from the in-memory cache (sorted by time)
    function redrawAllStrokes() {
      try {
        ctx2.clearRect(0,0,canvasEl.width,canvasEl.height);
        drawnIds.clear();
        // Sort strokes by timestamp so order is preserved
        const strokes = Object.keys(strokesCache).map(k => ({ id: k, s: strokesCache[k] }));
        strokes.sort((a,b) => (a.s.time || 0) - (b.s.time || 0));
        for(const item of strokes) {
          drawStrokeLocally(item.s);
          drawnIds.add(item.id);
        }
      } catch (err) {
        console.warn('redrawAllStrokes failed', err);
      }
    }
  
    // Pointer events
    canvasEl.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      canvasEl.setPointerCapture?.(e.pointerId);
      const p = getCanvasPoint(e);
      if(currentTool === 'brush' || currentTool === 'eraser') {
        drawing = true;
        currentStroke = [];
        currentStroke.push(p);
        if(currentTool === 'brush') {
          ctx2.globalAlpha = brushOpacity;
          ctx2.fillStyle = brushColor;
          ctx2.beginPath();
          ctx2.arc(p.x, p.y, Math.max(1, brushSize/2), 0, Math.PI*2);
          ctx2.fill();
        } else if(currentTool === 'eraser') {
          ctx2.save();
          ctx2.globalCompositeOperation = 'destination-out';
          ctx2.fillStyle = 'rgba(0,0,0,1)';
          ctx2.beginPath();
          ctx2.arc(p.x, p.y, Math.max(1, brushSize/2), 0, Math.PI*2);
          ctx2.fill();
          ctx2.restore();
        }
      } else if(currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'line') {
        shapeStart = p;
      } else if(currentTool === 'text') {
        const text = prompt('Enter text:');
        if(text) {
          const strokeObj = {
            user: visitorId || ('anon_'+Date.now()),
            type: 'text',
            text: text,
            x: p.x,
            y: p.y,
            color: brushColor,
            fontSize: brushSize,
            opacity: brushOpacity,
            time: Date.now()
          };
          if(backendApi) {
              const strokeId = `stroke_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
              backendApi.sendCanvasStroke(strokeId, strokeObj);
          }
        }
      } else if(currentTool === 'eyedropper') {
        const imageData = ctx2.getImageData(p.x, p.y, 1, 1);
        const data = imageData.data;
        const hex = rgbToHex(data[0], data[1], data[2]);
        colorPicker.value = hex;
        brushColor = hex;
      }
    });
  
    canvasEl.addEventListener('pointermove', (e) => {
      if(!drawing && !shapeStart) return;
      e.preventDefault();
      const p = getCanvasPoint(e);
      if(currentTool === 'brush' || currentTool === 'eraser') {
        const last = currentStroke[currentStroke.length-1];
        if(!last || last.x !== p.x || last.y !== p.y) {
          currentStroke.push(p);
  
          if(currentTool === 'brush') {
            ctx2.globalAlpha = brushOpacity;
            ctx2.lineJoin = 'round';
            ctx2.lineCap = 'round';
            ctx2.strokeStyle = brushColor;
            ctx2.lineWidth = brushSize;
            ctx2.beginPath();
            ctx2.moveTo(last.x, last.y);
            ctx2.lineTo(p.x, p.y);
            ctx2.stroke();
          } else if(currentTool === 'eraser') {
            ctx2.save();
            ctx2.globalCompositeOperation = 'destination-out';
            ctx2.strokeStyle = 'rgba(0,0,0,1)';
            ctx2.lineJoin = 'round';
            ctx2.lineCap = 'round';
            ctx2.lineWidth = brushSize;
            ctx2.beginPath();
            ctx2.moveTo(last.x, last.y);
            ctx2.lineTo(p.x, p.y);
            ctx2.stroke();
            ctx2.restore();
          }
        }
      }
      // For shapes, preview
      if(shapeStart && (currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'line')) {
        redrawAllStrokes(); // clear and redraw all
        // then draw preview
        ctx2.globalAlpha = brushOpacity;
        if(currentTool === 'rectangle') {
          const x = Math.min(shapeStart.x, p.x);
          const y = Math.min(shapeStart.y, p.y);
          const width = Math.abs(p.x - shapeStart.x);
          const height = Math.abs(p.y - shapeStart.y);
          ctx2.strokeStyle = brushColor;
          ctx2.lineWidth = 1;
          if(fillShapes) {
            ctx2.fillStyle = brushColor;
            ctx2.fillRect(x, y, width, height);
          } else {
            ctx2.strokeRect(x, y, width, height);
          }
        } else if(currentTool === 'circle') {
          const centerX = shapeStart.x;
          const centerY = shapeStart.y;
          const radius = Math.sqrt((p.x - centerX)**2 + (p.y - centerY)**2);
          ctx2.strokeStyle = brushColor;
          ctx2.lineWidth = 1;
          ctx2.beginPath();
          ctx2.arc(centerX, centerY, radius, 0, Math.PI * 2);
          if(fillShapes) {
            ctx2.fillStyle = brushColor;
            ctx2.fill();
          } else {
            ctx2.stroke();
          }
        } else if(currentTool === 'line') {
          ctx2.strokeStyle = brushColor;
          ctx2.lineWidth = brushSize;
          ctx2.beginPath();
          ctx2.moveTo(shapeStart.x, shapeStart.y);
          ctx2.lineTo(p.x, p.y);
          ctx2.stroke();
        }
      }
    });
  
    canvasEl.addEventListener('pointerup', async (e) => {
      if(!drawing && !shapeStart) return;
      drawing = false;
      if(currentTool === 'brush' || currentTool === 'eraser') {
        if(currentStroke.length > 0) {
          const strokeObj = {
            user: visitorId || ('anon_'+Date.now()),
            size: brushSize,
            points: currentStroke,
            time: Date.now()
          };
  
          if(currentTool === 'brush') {
            strokeObj.color = brushColor;
            strokeObj.type = 'brush';
            strokeObj.opacity = brushOpacity;
          } else if(currentTool === 'eraser') {
            strokeObj.type = 'erase';
          }
  
          try {
            if(backendApi) {
                const strokeId = `stroke_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
                backendApi.sendCanvasStroke(strokeId, strokeObj);
            }
          } catch (err) {
            console.error('Failed to push stroke', err);
          }
        }
      } else if(shapeStart) {
        const p = getCanvasPoint(e);
        const strokeObj = {
          user: visitorId || ('anon_'+Date.now()),
          size: brushSize,
          points: [shapeStart, p],
          color: brushColor,
          opacity: brushOpacity,
          fill: fillShapes,
          time: Date.now()
        };
        if(currentTool === 'rectangle') {
          strokeObj.type = 'rectangle';
        } else if(currentTool === 'circle') {
          strokeObj.type = 'circle';
        } else if(currentTool === 'line') {
          strokeObj.type = 'line';
        }
        try {
          if(backendApi) {
              const strokeId = `stroke_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
              backendApi.sendCanvasStroke(strokeId, strokeObj);
          }
        } catch (err) {
          console.error('Failed to push shape', err);
        }
        shapeStart = null;
        redrawAllStrokes(); // to remove preview
      }
      currentStroke = [];
    });
  
    canvasEl.addEventListener('pointercancel', () => { drawing=false; currentStroke=[]; });
  
    // Initialize canvas using backend (lazy load when opened)
    async function initializeCanvasBackend() {
        if (canvasInitialized || !backendApi) return;
        canvasInitialized = true;

        // Load existing strokes via REST and draw them
        try {
          const strokes = await backendApi.getCanvasStrokes();
          strokesCache = {};
          if (Array.isArray(strokes)) {
            strokes.forEach(stroke => {
              if (stroke && stroke.id) {
                const data = stroke.strokeData || stroke;
                strokesCache[stroke.id] = data;
                drawnIds.add(stroke.id);
              }
            });
          } else if (strokes && typeof strokes === 'object') {
            Object.keys(strokes).forEach(id => {
              const data = strokes[id];
              strokesCache[id] = data;
              drawnIds.add(id);
            });
          }
          redrawAllStrokes();
          initialLoadComplete = true;
        } catch (err) {
          console.error('Error loading strokes from backend:', err);
          initialLoadComplete = true;
        }

        // Poll strokes periodically (no websockets)
        const pollStrokes = async () => {
          try {
            const strokes = await backendApi.getCanvasStrokes();
            const latest = Array.isArray(strokes) ? strokes : [];
            const latestMap = {};
            latest.forEach(s => {
              if (s && s.id) {
                const data = s.strokeData || s;
                latestMap[s.id] = data;
              }
            });
            const latestIds = Object.keys(latestMap);
            const existingIds = Object.keys(strokesCache);
            // If stroke count shrank, clear and redraw everything
            const cleared = latestIds.length < existingIds.length;
            strokesCache = latestMap;
            if (cleared) {
              drawnIds.clear();
              redrawAllStrokes();
            }
            latestIds.forEach(id => {
              if (!drawnIds.has(id)) {
                drawStrokeLocally(strokesCache[id]);
                drawnIds.add(id);
              }
            });
          } catch (err) {
            console.warn('Canvas poll failed:', err);
          }
        };
        pollStrokes();
        canvasPollInterval = setInterval(pollStrokes, 1200);
    }
  
    // Clear button
    clearBtn?.addEventListener('click', async () => {
      try {
        if (backendApi) {
          backendApi.clearCanvas({ by: visitorId || 'anon', time: Date.now() });
        } else if(strokesRef && metaRef) {
            // Remove all strokes from DB so the clear persists across reloads
            await strokesRef.remove();
            // Notify other clients with a transient clear flag
            await metaRef.child('clear').set({ by: visitorId || 'anon', time: Date.now() });
            // Remove transient clear flag shortly after so new clients don't auto-clear forever
            setTimeout(() => { metaRef.child('clear').remove().catch(()=>{}); }, 1500);
        }
      } catch (err) {
        console.warn('Failed to clear strokes', err);
      }
    });
  
    // Presence and cursor tracking - initialized lazily
    let presenceRef = null;
    let cursorsRef = null;
    let userId = null;
    const cursorOverlay = document.getElementById('cursorOverlay');
    const ctxCursor = cursorOverlay.getContext('2d');
    let activeCursors = {}; // { userId: { x, y, color, username, timestamp } }
    const avatarImageCache = {}; // Cache for loaded avatar images
    
    // Sync cursor overlay to main canvas size
    function syncCursorOverlay() {
      // Match the overlay to the main canvas device pixel dimensions
      // canvasEl.width/height are in device pixels (after resize helper sets them)
      const ratio = window.devicePixelRatio || 1;
      cursorOverlay.width = canvasEl.width;    // device pixels
      cursorOverlay.height = canvasEl.height;  // device pixels
      // Keep CSS size the same as the visible canvas so boundingClientRect coords match
      cursorOverlay.style.width = canvasEl.style.width;
      cursorOverlay.style.height = canvasEl.style.height;
      // Reset transform and scale so we can draw using CSS pixel coordinates (same units as getCanvasPoint)
      ctxCursor.setTransform(1, 0, 0, 1, 0, 0);
      ctxCursor.scale(ratio, ratio);
      // Ensure overlay doesn't block pointer events on the main canvas
      cursorOverlay.style.pointerEvents = 'none';
    }
    window.addEventListener('resize', syncCursorOverlay);
    syncCursorOverlay();
  
    // Track mouse movement and broadcast cursor (only after Firebase is initialized)
    let lastCursorUpdate = 0;
    canvasEl.addEventListener('pointermove', (e) => {
      if(!cursorsRef || !userId) return; // Wait for Firebase initialization
      const now = Date.now();
      if(now - lastCursorUpdate > 100) { // Throttle to 100ms
        const p = getCanvasPoint(e);
        cursorsRef.child(userId).set({
          x: p.x,
          y: p.y,
          color: brushColor,
          username: username,
          avatar: userProfile.avatar || '👤',
          avatarImage: userProfile.avatarImage || null,
          timestamp: Date.now()
        }).catch(err => console.warn('Cursor update failed', err));
        lastCursorUpdate = now;
      }
    });
  
    // Draw cursors on overlay
    function drawCursorsFrame() {
      // Clear using device pixel dimensions — ctx transform is already scaled to device pixels
      ctxCursor.clearRect(0, 0, cursorOverlay.width, cursorOverlay.height);
  
      for(const uid in activeCursors) {
        if(uid === userId) continue; // Don't draw own cursor
        const cursor = activeCursors[uid];
        if(!cursor || (typeof cursor.x !== 'number') || (typeof cursor.y !== 'number')) continue;
  
        // Don't show stale cursors (older than 2 seconds)
        if(Date.now() - cursor.timestamp > 2000) continue;
  
        // cursor.x/y are stored in CSS pixels (getCanvasPoint uses boundingClientRect)
        // ctxCursor is scaled so drawing with CSS coordinates works correctly
        const x = cursor.x;
        const y = cursor.y;
        const color = cursor.color || '#00ffff';
  
        ctxCursor.save();
        
        // Draw profile picture (small avatar)
        const avatarSize = 20;
        if(cursor.avatarImage) {
            // Load and cache image
            if(!avatarImageCache[cursor.avatarImage]) {
                const img = new Image();
                img.src = cursor.avatarImage;
                avatarImageCache[cursor.avatarImage] = img;
            }
            const img = avatarImageCache[cursor.avatarImage];
            
            if(img.complete && img.naturalWidth > 0) {
                // Draw circular avatar
                ctxCursor.beginPath();
                ctxCursor.arc(x, y, avatarSize/2, 0, Math.PI * 2);
                ctxCursor.save();
                ctxCursor.clip();
                ctxCursor.drawImage(img, x - avatarSize/2, y - avatarSize/2, avatarSize, avatarSize);
                ctxCursor.restore();
            } else {
                // Image still loading, show emoji fallback
                ctxCursor.fillStyle = 'rgba(255,255,255,0.9)';
                ctxCursor.beginPath();
                ctxCursor.arc(x, y, avatarSize/2, 0, Math.PI * 2);
                ctxCursor.fill();
// Mobile responsiveness debugging
function debugMobileResponsiveness() {
    console.log('=== Mobile Responsiveness Debug ===');
    console.log('Screen size:', window.innerWidth + 'x' + window.innerHeight);
    console.log('Device pixel ratio:', window.devicePixelRatio);
    console.log('User agent:', navigator.userAgent);

    // Check header
    const header = document.querySelector('header');
    if (header) {
        const headerRect = header.getBoundingClientRect();
        console.log('Header dimensions:', headerRect.width + 'x' + headerRect.height);
        console.log('Header margin-left:', getComputedStyle(header).marginLeft);
    }

    // Check game grid
    const gameGrid = document.querySelector('.games-grid-container');
    if (gameGrid) {
        const gridRect = gameGrid.getBoundingClientRect();
        console.log('Game grid dimensions:', gridRect.width + 'x' + gridRect.height);
        console.log('Game grid padding:', getComputedStyle(gameGrid).padding);
        console.log('Game grid columns:', getComputedStyle(gameGrid).gridTemplateColumns);
    }

    // Check game cubes
    const gameCubes = document.querySelectorAll('.game-cube');
    if (gameCubes.length > 0) {
        const firstCube = gameCubes[0];
        const cubeRect = firstCube.getBoundingClientRect();
        console.log('First game cube dimensions:', cubeRect.width + 'x' + cubeRect.height);
        console.log('Game cube min-height:', getComputedStyle(firstCube).minHeight);
    }

    // Check navigation
    const nav = document.querySelector('.main-navigation');
    if (nav) {
        console.log('Navigation display:', getComputedStyle(nav).display);
        console.log('Navigation position:', getComputedStyle(nav).position);
    }

    // Check touch targets
    const buttons = document.querySelectorAll('button, .game-cube, .nav-item');
    let smallTargets = 0;
    buttons.forEach(btn => {
        const rect = btn.getBoundingClientRect();
        const minDim = Math.min(rect.width, rect.height);
        if (minDim < 44) { // 44px is recommended minimum touch target
            smallTargets++;
        }
    });
    console.log('Small touch targets (<44px):', smallTargets);

    // Check for horizontal overflow
    const bodyScrollWidth = document.body.scrollWidth;
    const windowWidth = window.innerWidth;
    console.log('Horizontal overflow:', bodyScrollWidth > windowWidth ? 'YES' : 'NO');
    if (bodyScrollWidth > windowWidth) {
        console.log('Overflow amount:', bodyScrollWidth - windowWidth + 'px');
    }

    console.log('=== End Debug ===');
}

// Run debug on load and resize
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', debugMobileResponsiveness);
} else {
    debugMobileResponsiveness();
}
window.addEventListener('resize', () => {
    setTimeout(debugMobileResponsiveness, 500); // Debounce resize
});
                ctxCursor.font = '14px Arial';
                ctxCursor.textAlign = 'center';
                ctxCursor.textBaseline = 'middle';
                ctxCursor.fillStyle = '#000';
                ctxCursor.fillText(cursor.avatar || '👤', x, y);
            }
            // Draw border around avatar
            ctxCursor.strokeStyle = color;
            ctxCursor.lineWidth = 2;
            ctxCursor.beginPath();
            ctxCursor.arc(x, y, avatarSize/2 + 1, 0, Math.PI * 2);
            ctxCursor.stroke();
        } else {
            // Draw emoji avatar
            ctxCursor.fillStyle = 'rgba(255,255,255,0.9)';
            ctxCursor.beginPath();
            ctxCursor.arc(x, y, avatarSize/2, 0, Math.PI * 2);
            ctxCursor.fill();
            ctxCursor.strokeStyle = color;
            ctxCursor.lineWidth = 2;
            ctxCursor.stroke();
            ctxCursor.font = '14px Arial';
            ctxCursor.textAlign = 'center';
            ctxCursor.textBaseline = 'middle';
            ctxCursor.fillStyle = '#000';
            ctxCursor.fillText(cursor.avatar || '👤', x, y);
        }
  
        // Draw cursor glow
        ctxCursor.strokeStyle = color;
        ctxCursor.lineWidth = 2;
        ctxCursor.globalAlpha = 0.5;
        ctxCursor.beginPath();
        ctxCursor.arc(x, y, avatarSize/2 + 3, 0, Math.PI * 2);
        ctxCursor.stroke();
        ctxCursor.globalAlpha = 1;
  
        // Draw username label
        ctxCursor.fillStyle = color;
        ctxCursor.font = 'bold 11px Arial';
        ctxCursor.textAlign = 'left';
        ctxCursor.textBaseline = 'top';
        ctxCursor.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctxCursor.shadowBlur = 3;
        ctxCursor.fillText(cursor.username, x + avatarSize/2 + 5, y + 2);
        ctxCursor.restore();
      }
  
      requestAnimationFrame(drawCursorsFrame);
    }
    
    // Start drawing cursors only after Firebase is initialized
    let cursorsDrawingStarted = false;
    function startCursorsDrawing() {
        if(cursorsDrawingStarted) return;
        cursorsDrawingStarted = true;
        drawCursorsFrame();
    }
  
    // Initial load placeholder (backend handles strokes)
    function loadCanvasStrokes() {
        // no-op; backend handles initial strokes
    }
    
    // Initialize canvas when drawing modal is opened
    // Note: openDrawingBtn is defined outside this IIFE, so we'll attach the handler there
    // Store the initialization function globally so it can be called
    window.initializeCanvasOnOpen = function() {
        if (backendApi) {
            initializeCanvasBackend();
        } else {
            console.warn('Canvas backend not available');
        }
        startCursorsDrawing();
    };
  })();
  
  // Loading screen removal is now handled at the top of the script
  
  // ================= Page Initialization =================
    // Initialize announcement popup when page loads
    window.addEventListener('load', function() {
        console.log('Page fully loaded');
        // Debug: Check Discord button position and listeners
        const discordBtn = document.getElementById('discordBtn');
        if (discordBtn) {
            console.log('Discord button found, position:', getComputedStyle(discordBtn).position, 'display:', getComputedStyle(discordBtn).display);
            console.log('Discord button event listeners:', discordBtn.onclick ? 'has onclick' : 'no onclick');
        } else {
            console.log('Discord button not found');
        }
      let hasHiddenPreference = false;
        try {
            hasHiddenPreference = localStorage.getItem(POPUP_STORAGE_KEY) === 'true';
        } catch (e) {
            hasHiddenPreference = false;
        }
        // If the user chose "Don't show this welcome again", skip only the popup,
        // but keep the loading animation behavior unchanged.
        if (!hasHiddenPreference) {
            showPopup();
        }
    });
  
  // ================= NEW FEATURES =================
  
  // ---------------- User Profiles ----------------
const PROFILE_BIO_LIMIT = 200;
const HEX_COLOR_PATTERN = /^#([0-9a-f]{6})$/i;
const createDefaultUserProfile = () => ({
    avatar: '👤',
    avatarImage: null, // base64 or data URL for uploaded image
    username: '',
    status: '',
    pronouns: '',
    location: '',
    bio: '',
    favoriteColor: '#FFD700',
    interests: [],
    activity: [],
    profileCreated: false
});
  
  let storedProfile = {};
  try {
      storedProfile = JSON.parse(localStorage.getItem('userProfile')) || {};
  } catch (error) {
      console.warn('Unable to parse saved profile, using defaults.', error);
      storedProfile = {};
  }
  
  let userProfile = {
      ...createDefaultUserProfile(),
      ...storedProfile
  };
  
  if (!Array.isArray(userProfile.activity)) {
      userProfile.activity = [];
  }
  if (!Array.isArray(userProfile.interests)) {
      userProfile.interests = [];
  }
  userProfile.favoriteColor = sanitizeHexColor(userProfile.favoriteColor);
  
  const profileBtn = document.getElementById('profileBtn');
  const profileModal = document.getElementById('profileModal');
  const closeProfileBtn = document.getElementById('closeProfileBtn');
  const profileAvatar = document.getElementById('profileAvatar');
  const profileAvatarEmoji = document.getElementById('profileAvatarEmoji');
  const profileUsername = document.getElementById('profileUsername');
  const profileStatus = document.getElementById('profileStatus');
  const activityList = document.getElementById('activityList');
  const profilePronouns = document.getElementById('profilePronouns');
  const profileLocation = document.getElementById('profileLocation');
  const profileBio = document.getElementById('profileBio');
  const profileBioCounter = document.getElementById('profileBioCounter');
  const profileFavoriteColor = document.getElementById('profileFavoriteColor');
const profileFavoriteColorValue = document.getElementById('profileFavoriteColorValue');
const profileInterestInputs = document.querySelectorAll('.profile-interest-input');
const profilePictureInput = document.getElementById('profilePictureInput');
const uploadPfpBtn = document.getElementById('uploadPfpBtn');
const removePfpBtn = document.getElementById('removePfpBtn');
const saveProfileBtn = document.getElementById('saveProfileBtn');
const profileModalTitle = document.getElementById('profileModalTitle');
if (profileStatus) {
  profileStatus.addEventListener('change', () => {
    userProfile.status = profileStatus.value;
    saveProfile();
  });
}
  
  let isFirstVisit = !userProfile.profileCreated;
  let isProfileModalLocked = false; // Lock modal only when trying to use online features
  
  // Don't auto-open profile modal on first visit - only require when using online features
  // Profile creation is now optional until user tries to use online features
  
  // Function to check if profile is required and prompt if needed
  function requireProfileForOnlineFeature(featureName, callback) {
      if (!userProfile.profileCreated) {
          // Lock the modal - user must create profile
          isProfileModalLocked = true;
          profileModalTitle.textContent = 'Create Your Profile';
          if (closeProfileBtn) {
              closeProfileBtn.style.display = 'none';
          }
          // Show profile modal
          if (profileModal) {
              profileModal.style.display = 'flex';
              updateProfileDisplay();
          }
          // Store callback to execute after profile is created
          if (callback) {
              window.pendingOnlineFeatureCallback = callback;
          }
          return false;
      }
      return true;
  }
  
  // Update save profile to execute pending callback
  const originalSaveProfile = saveProfileBtn?.onclick;
  if (saveProfileBtn) {
      saveProfileBtn.addEventListener('click', function() {
          const usernameValue = profileUsername?.value.trim();
          if (!usernameValue) {
              alert('Please enter a username');
              return;
          }
          const bioValue = (profileBio?.value || '').trim();
          if (bioValue.length > PROFILE_BIO_LIMIT) {
              alert(`Bio must be ${PROFILE_BIO_LIMIT} characters or less.`);
              return;
          }
          
          userProfile.username = usernameValue;
          userProfile.status = profileStatus?.value || '';
          userProfile.pronouns = profilePronouns?.value.trim() || '';
          userProfile.location = profileLocation?.value.trim() || '';
          userProfile.bio = bioValue;
          userProfile.favoriteColor = sanitizeHexColor(profileFavoriteColor?.value);
          userProfile.interests = Array.from(profileInterestInputs).filter(input => input.checked).map(input => input.value);
          userProfile.profileCreated = true;
          
          // Update global username everywhere
          username = usernameValue;
          const chatPopupUsername = document.getElementById('chatPopupUsername');
          if (chatPopupUsername) {
              chatPopupUsername.value = usernameValue;
          }
          
          // Save to Firebase
          if(db) {
              const profileData = {
                  username: userProfile.username,
                  status: userProfile.status,
                  avatar: userProfile.avatar,
                  avatarImage: userProfile.avatarImage,
                  pronouns: userProfile.pronouns,
                  location: userProfile.location,
                  bio: userProfile.bio,
                  favoriteColor: userProfile.favoriteColor,
                  interests: userProfile.interests,
                  lastSeen: Date.now()
              };
              db.ref('profiles/' + visitorId).update(profileData);
          }
          
          saveProfile();
          addActivity('Profile created');
          
          // Unlock modal after profile is created
          isProfileModalLocked = false;
          profileModalTitle.textContent = 'My Profile';
          if (closeProfileBtn) {
              closeProfileBtn.style.display = 'block';
          }
          profileModal.style.display = 'none';
          
          // Execute pending callback if exists
          if (window.pendingOnlineFeatureCallback) {
              const callback = window.pendingOnlineFeatureCallback;
              window.pendingOnlineFeatureCallback = null;
              callback();
          }
      });
  }
  
  profileBtn?.addEventListener('click', () => {
      isProfileModalLocked = false;
      profileModalTitle.textContent = 'My Profile';
      if (closeProfileBtn) {
          closeProfileBtn.style.display = 'block';
      }
      profileModal.style.display = 'flex';
      updateProfileDisplay();
  });
  
  closeProfileBtn?.addEventListener('click', () => {
      if (!isProfileModalLocked) {
          profileModal.style.display = 'none';
      }
  });
  
  profileModal?.addEventListener('click', (e) => {
      if(e.target === profileModal && !isProfileModalLocked) {
          profileModal.style.display = 'none';
      }
  });
  
  profileBio?.addEventListener('input', () => {
      if (profileBio.value.length > PROFILE_BIO_LIMIT) {
          profileBio.value = profileBio.value.slice(0, PROFILE_BIO_LIMIT);
      }
      updateBioCounterDisplay(profileBio.value.length);
  });
  
  profileFavoriteColor?.addEventListener('input', () => {
      updateFavoriteColorDisplay(profileFavoriteColor.value);
  });
  
  Array.from(profileInterestInputs).forEach(input => {
      input.addEventListener('change', () => {
          setInterestChipAppearance(input, input.checked);
      });
  });
  
  // Handle profile picture upload
  uploadPfpBtn?.addEventListener('click', () => {
      profilePictureInput?.click();
  });
  
  profilePictureInput?.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
          if (file.size > 5 * 1024 * 1024) { // 5MB limit
              alert('Image size must be less than 5MB');
              return;
          }
          const reader = new FileReader();
          reader.onload = (event) => {
              userProfile.avatarImage = event.target.result;
              userProfile.avatar = '👤'; // Set default emoji
              updateProfileDisplay();
          };
          reader.readAsDataURL(file);
      }
  });
  
  // Handle remove profile picture
  removePfpBtn?.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent triggering avatar click
      userProfile.avatarImage = null;
      userProfile.avatar = '👤';
      updateProfileDisplay();
  });
  
  // Allow clicking avatar to upload
  profileAvatar?.addEventListener('click', () => {
      profilePictureInput?.click();
  });
  
  saveProfileBtn?.addEventListener('click', () => {
      const usernameValue = profileUsername?.value.trim();
      if (!usernameValue) {
          alert('Please enter a username');
          return;
      }
      const bioValue = (profileBio?.value || '').trim();
      if (bioValue.length > PROFILE_BIO_LIMIT) {
          alert(`Bio must be ${PROFILE_BIO_LIMIT} characters or less.`);
          return;
      }
      
      userProfile.username = usernameValue;
    userProfile.status = profileStatus?.value || '';
    userProfile.pronouns = profilePronouns?.value.trim() || '';
    userProfile.location = profileLocation?.value.trim() || '';
    userProfile.bio = bioValue;
    userProfile.favoriteColor = sanitizeHexColor(profileFavoriteColor?.value);
      userProfile.interests = Array.from(profileInterestInputs).filter(input => input.checked).map(input => input.value);
      userProfile.profileCreated = true;
      
      // Update global username everywhere
      username = usernameValue;
      const chatPopupUsername = document.getElementById('chatPopupUsername');
      if (chatPopupUsername) {
          chatPopupUsername.value = usernameValue;
      }
      
      // Save to Firebase
      if(db) {
          const profileData = {
              username: userProfile.username,
              status: userProfile.status,
              avatar: userProfile.avatar,
              avatarImage: userProfile.avatarImage,
              pronouns: userProfile.pronouns,
              location: userProfile.location,
              bio: userProfile.bio,
            favoriteColor: userProfile.favoriteColor,
            interests: userProfile.interests,
              lastSeen: Date.now()
          };
          db.ref('profiles/' + visitorId).update(profileData);
      }
      
      saveProfile();
      addActivity('Profile created');
      
      // Unlock modal after profile is created
      isProfileModalLocked = false;
      profileModalTitle.textContent = 'My Profile';
      if (closeProfileBtn) {
          closeProfileBtn.style.display = 'block';
      }
      
      alert('Profile saved successfully!');
      
      // Auto-close profile modal after saving
      if (profileModal) {
          profileModal.style.display = 'none';
          profileModal.setAttribute('aria-hidden', 'true');
      }
  });
  
  profileStatus?.addEventListener('change', () => {
      userProfile.status = profileStatus.value;
      if(db && userProfile.profileCreated) {
          db.ref('profiles/' + visitorId).update({
              status: userProfile.status,
              avatar: userProfile.avatar,
              avatarImage: userProfile.avatarImage,
              username: userProfile.username,
              lastSeen: Date.now()
          });
      }
      saveProfile();
  });
  
  // Delete Account functionality
  const deleteAccountBtn = document.getElementById('deleteAccountBtn');
  deleteAccountBtn?.addEventListener('click', () => {
      if (!confirm('⚠️ WARNING: This will permanently delete your account and all associated data!\n\nThis includes:\n- Your profile\n- Your chat messages\n- Your friends and friend requests\n- Your activity history\n- All other account data\n\nThis action CANNOT be undone!\n\nAre you absolutely sure you want to delete your account?')) {
          return;
      }
      
      if (!confirm('This is your final warning. Click OK to permanently delete your account.')) {
          return;
      }
      
      // Delete from Firebase
      if (db) {
          const userId = visitorId;
          
          // Delete profile
          db.ref('profiles/' + userId).remove().catch(err => console.error('Error deleting profile:', err));
          
          // Delete chat messages (delete messages where uid matches)
          db.ref('chat').once('value').then(snapshot => {
              const updates = {};
              snapshot.forEach(child => {
                  if (child.val().uid === userId) {
                      updates['chat/' + child.key] = null;
                  }
              });
              if (Object.keys(updates).length > 0) {
                  db.ref().update(updates).catch(err => console.error('Error deleting chat messages:', err));
              }
          }).catch(err => console.error('Error fetching chat messages:', err));
          
          // Delete from friends lists
          db.ref('profiles').once('value').then(snapshot => {
              const updates = {};
              snapshot.forEach(child => {
                  const profileData = child.val();
                  if (profileData.friends && profileData.friends[userId]) {
                      updates['profiles/' + child.key + '/friends/' + userId] = null;
                  }
                  if (profileData.friendRequests && profileData.friendRequests[userId]) {
                      updates['profiles/' + child.key + '/friendRequests/' + userId] = null;
                  }
                  if (profileData.blockedUsers && profileData.blockedUsers[userId]) {
                      updates['profiles/' + child.key + '/blockedUsers/' + userId] = null;
                  }
              });
              if (Object.keys(updates).length > 0) {
                  db.ref().update(updates).catch(err => console.error('Error removing from friends lists:', err));
              }
          }).catch(err => console.error('Error fetching profiles:', err));
          
          // Delete online status
          db.ref('online/' + userId).remove().catch(err => console.error('Error deleting online status:', err));
          
          // Delete typing indicator
          db.ref('chatTyping/' + userId).remove().catch(err => console.error('Error deleting typing indicator:', err));
      }
      
      // Clear localStorage
      localStorage.removeItem('userProfile');
      localStorage.removeItem('visitorId');
      
      // Reset userProfile
      userProfile = createDefaultUserProfile();
      
      // Reset visitorId
      visitorId = 'visitor_' + Date.now() + '_' + Math.floor(Math.random() * 10000);
      localStorage.setItem('visitorId', visitorId);
      
      // Close modal
      if (profileModal) {
          profileModal.style.display = 'none';
      }
      
      // Reload page to reset everything
      alert('Account deleted successfully. The page will now reload.');
      window.location.reload();
  });
  
  profileUsername?.addEventListener('change', () => {
      if (userProfile.profileCreated && profileUsername.value.trim()) {
          userProfile.username = profileUsername.value.trim();
          username = userProfile.username;
          const chatPopupUsername = document.getElementById('chatPopupUsername');
          if (chatPopupUsername) {
              chatPopupUsername.value = userProfile.username;
          }
          if(db) {
              db.ref('profiles/' + visitorId).update({
                  username: userProfile.username,
                  lastSeen: Date.now()
              });
          }
          saveProfile();
      }
  });
  
  function updateProfileDisplay() {
      // Query DOM elements directly to support dynamically injected modals
      const profileAvatarEl = document.getElementById('profileAvatar');
      const profileAvatarEmojiEl = document.getElementById('profileAvatarEmoji');
      const profileUsernameEl = document.getElementById('profileUsername');
      const profileStatusEl = document.getElementById('profileStatus');
      const profilePronounsEl = document.getElementById('profilePronouns');
      const profileLocationEl = document.getElementById('profileLocation');
      const profileBioEl = document.getElementById('profileBio');
      const profileFavoriteColorEl = document.getElementById('profileFavoriteColor');
      const profileInterestInputsEl = document.querySelectorAll('.profile-interest-input');
      const activityListEl = document.getElementById('activityList');
      const removePfpBtnEl = document.getElementById('removePfpBtn');
      
      if (profileAvatarEl) {
          if (userProfile.avatarImage) {
              profileAvatarEl.style.backgroundImage = `url(${userProfile.avatarImage})`;
              profileAvatarEl.style.backgroundSize = 'cover';
              profileAvatarEl.style.backgroundPosition = 'center';
              if (profileAvatarEmojiEl) profileAvatarEmojiEl.style.display = 'none';
              if (removePfpBtnEl) removePfpBtnEl.style.display = 'block';
          } else {
              profileAvatarEl.style.backgroundImage = 'none';
              if (profileAvatarEmojiEl) {
                  profileAvatarEmojiEl.style.display = 'block';
                  profileAvatarEmojiEl.textContent = userProfile.avatar || '👤';
              }
              if (removePfpBtnEl) removePfpBtnEl.style.display = 'none';
          }
      }
      if (profileUsernameEl) {
          profileUsernameEl.value = userProfile.username || '';
      }
      if (profileStatusEl) {
          profileStatusEl.value = userProfile.status || '';
      }
      if (profilePronounsEl) {
          profilePronounsEl.value = userProfile.pronouns || '';
      }
      if (profileLocationEl) {
          profileLocationEl.value = userProfile.location || '';
      }
      if (profileBioEl) {
          profileBioEl.value = userProfile.bio || '';
          updateBioCounterDisplay(profileBioEl.value.length);
      } else {
          updateBioCounterDisplay((userProfile.bio || '').length);
      }
      if (profileFavoriteColorEl) {
          const colorValue = userProfile.favoriteColor || '#FFD700';
          profileFavoriteColorEl.value = colorValue;
          updateFavoriteColorDisplay(colorValue);
      } else {
          updateFavoriteColorDisplay(userProfile.favoriteColor || '#FFD700');
      }
      if (profileInterestInputsEl.length > 0) {
          const interests = Array.isArray(userProfile.interests) ? userProfile.interests : [];
          Array.from(profileInterestInputsEl).forEach(input => {
              const isActive = interests.includes(input.value);
              input.checked = isActive;
              setInterestChipAppearance(input, isActive);
          });
      }
      if (activityListEl) {
          activityListEl.innerHTML = userProfile.activity.slice(-10).reverse().map(a => 
              `<div style="padding:8px; background:rgba(255,255,255,0.05); border-radius:6px; margin-bottom:8px; font-size:13px;">
                  <strong>${a.action}</strong> - ${new Date(a.time).toLocaleString()}
              </div>`
          ).join('') || '<p style="color:rgba(255,255,255,0.5);">No activity yet</p>';
      }
  }
  
  function sanitizeHexColor(value) {
      return HEX_COLOR_PATTERN.test(value || '') ? value : '#FFD700';
  }
  
  function updateBioCounterDisplay(currentLength = 0) {
      if (profileBioCounter) {
          const safeLength = Math.min(currentLength, PROFILE_BIO_LIMIT);
          profileBioCounter.textContent = `${safeLength} / ${PROFILE_BIO_LIMIT}`;
      }
  }
  
  function updateFavoriteColorDisplay(colorValue = '#FFD700') {
      const safeColor = sanitizeHexColor(colorValue);
      if (profileFavoriteColorValue) {
          profileFavoriteColorValue.textContent = safeColor.toUpperCase();
      }
      if (profileFavoriteColor) {
          profileFavoriteColor.value = safeColor;
      }
  }
  
  function setInterestChipAppearance(input, isActive) {
      if (!input?.parentElement) return;
      input.parentElement.style.background = isActive ? 'rgba(255,215,0,0.12)' : 'rgba(255,255,255,0.03)';
      input.parentElement.style.borderColor = isActive ? 'rgba(255,215,0,0.4)' : 'rgba(255,255,255,0.1)';
      input.parentElement.style.color = isActive ? '#FFD700' : 'rgba(255,255,255,0.85)';
  }
  
  function saveProfile() {
      localStorage.setItem('userProfile', JSON.stringify(userProfile));
      updateProfileDisplay();
      if (backendApi && !backendFriendsDisabled && userProfile.profileCreated) {
          backendApi.setUserProfile(visitorId, {
              username: userProfile.username,
              status: userProfile.status,
              pronouns: userProfile.pronouns,
              location: userProfile.location,
              bio: userProfile.bio,
              favoriteColor: userProfile.favoriteColor,
              interests: userProfile.interests,
              avatar: userProfile.avatar,
              avatarImage: userProfile.avatarImage,
              activity: userProfile.activity
          }).catch(err => console.warn('Failed to save profile to backend', err));
      }
  }
  
  function addActivity(action) {
      userProfile.activity.push({ action, time: Date.now() });
      if(userProfile.activity.length > 50) userProfile.activity.shift();
      saveProfile();
      updateProfileDisplay();
  }
  
  // ---------------- Leaderboard ----------------
  const leaderboardBtn = document.getElementById('leaderboardBtn');
  const leaderboardModal = document.getElementById('leaderboardModal');
  const closeLeaderboardBtn = document.getElementById('closeLeaderboardBtn');
  const leaderboardContent = document.getElementById('leaderboardContent');
  const leaderboardTabs = document.querySelectorAll('.leaderboardTab');
  let currentLeaderboardTab = 'active';
  
  leaderboardBtn?.addEventListener('click', () => {
      if (!requireProfileForOnlineFeature('Leaderboard', () => {
          leaderboardModal.style.display = 'flex';
          loadLeaderboardBackend('active');
      })) {
          return;
      }
      leaderboardModal.style.display = 'flex';
      loadLeaderboardBackend('active');
  });
  
  closeLeaderboardBtn?.addEventListener('click', () => {
      leaderboardModal.style.display = 'none';
  });
  
  leaderboardModal?.addEventListener('click', (e) => {
      if(e.target === leaderboardModal) leaderboardModal.style.display = 'none';
  });
  
  leaderboardTabs.forEach(tab => {
      tab.addEventListener('click', () => {
          currentLeaderboardTab = tab.dataset.tab;
          leaderboardTabs.forEach(t => {
              t.style.background = 'rgba(255,255,255,0.05)';
              t.style.color = 'rgba(255,255,255,0.7)';
          });
          tab.style.background = 'rgba(255,215,0,0.1)';
          tab.style.color = '#FFD700';
          loadLeaderboardBackend(currentLeaderboardTab);
      });
  });
  
  function loadLeaderboard(type) {
      if(!leaderboardContent) return;
      
      leaderboardContent.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Loading...</p>';
      
      if(type === 'active') {
          if(!db) {
              leaderboardContent.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Active leaderboard requires a database connection.</p>';
              return;
          }
          // Load only online users, then load profiles for top 10 only
          db.ref('online').once('value').then(onlineSnap => {
              const online = onlineSnap.val() || {};
              const sorted = Object.entries(online).sort((a,b) => (b[1].timestamp || 0) - (a[1].timestamp || 0)).slice(0, 10);
              const topUserIds = sorted.map(([id]) => id);
              
              // Only load profiles for top 10 users
              if (topUserIds.length > 0) {
                  const profilePromises = topUserIds.map(userId => 
                      db.ref(`profiles/${userId}`).once('value').then(snap => ({ id: userId, data: snap.val() }))
                  );
                  
                  Promise.all(profilePromises).then(profileResults => {
                      const profiles = {};
                      profileResults.forEach(({ id, data }) => {
                          if (data) profiles[id] = data;
                      });
                      
                      displayLeaderboard(sorted.map(([id, data], i) => {
                          const profile = profiles[id] || {};
                          return {
                              rank: i + 1,
                              name: data.username || profile.username || 'User',
                              value: Math.floor((Date.now() - (data.timestamp || Date.now())) / 60000),
                              label: 'min online',
                              avatar: profile.avatar || '👤',
                              avatarImage: profile.avatarImage || null
                          };
                      }));
                  }).catch(err => {
                      console.error('Error loading profiles:', err);
                      // Display without profile data if profile load fails
                      displayLeaderboard(sorted.map(([id, data], i) => ({
                          rank: i + 1,
                          name: data.username || 'User',
                          value: Math.floor((Date.now() - (data.timestamp || Date.now())) / 60000),
                          label: 'min online',
                          avatar: '👤',
                          avatarImage: null
                      })));
                  });
              } else {
                  displayLeaderboard([]);
              }
          }).catch(err => {
              console.error('Error loading active leaderboard:', err);
              leaderboardContent.innerHTML = '<p style="text-align:center; color:rgba(255,0,0,0.7);">Error loading leaderboard.</p>';
          });
      } else if(type === 'achievements') {
          // Get achievement data from localStorage of all users (simplified)
          const stats = JSON.parse(localStorage.getItem('userStats')) || {};
          const achievements = [
              { name: 'Chat Master', value: Math.floor((stats.chatMessages || 0) / 10) },
              { name: 'Artist', value: Math.floor((stats.drawTime || 0) / 30) },
              { name: 'Gamer', value: Math.floor((stats.gameTime || 0) / 60) }
          ];
          displayLeaderboard(achievements.map((a, i) => ({
              rank: i + 1,
              name: a.name,
              value: a.value,
              label: 'completed',
              avatar: '🏆',
              avatarImage: null
          })));
      } else {
          leaderboardContent.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Daily/Weekly stats coming soon!</p>';
      }
  }
  
  function displayLeaderboard(data) {
      if(!leaderboardContent) return;
      leaderboardContent.innerHTML = data.map(item => {
          const avatarStyle = item.avatarImage 
              ? `background-image: url(${item.avatarImage}); background-size: cover; background-position: center;`
              : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
          const avatarContent = item.avatarImage ? '' : item.avatar || '👤';
          return `
          <div style="display:flex; align-items:center; padding:15px; background:rgba(255,255,255,0.05); border-radius:8px; margin-bottom:10px;">
              <div style="width:40px; height:40px; border-radius:50%; ${avatarStyle} display:flex; align-items:center; justify-content:center; font-weight:bold; margin-right:15px; font-size:20px; flex-shrink:0;">
                  ${avatarContent}
              </div>
              <div style="width:35px; height:35px; border-radius:50%; background:rgba(255,215,0,0.2); display:flex; align-items:center; justify-content:center; font-weight:bold; margin-right:15px; flex-shrink:0;">
                  ${item.rank}
              </div>
              <div style="flex:1;">
                  <div style="font-weight:600; color:#FFD700;">${item.name}</div>
                  <div style="font-size:12px; color:rgba(255,255,255,0.6);">${item.value} ${item.label}</div>
              </div>
          </div>
      `;
      }).join('');
  }
  
  // ================= Modern Friends System =================
  const friendsBtn = document.getElementById('friendsBtn');
  const friendsModal = document.getElementById('friendsModal');
  const closeFriendsBtn = document.getElementById('closeFriendsBtn');
  
  // Friends data storage
  let friendsData = {
    friends: JSON.parse(localStorage.getItem('friends')) || [],
    requests: {
        sent: JSON.parse(localStorage.getItem('friendRequestsSent')) || [],
        received: JSON.parse(localStorage.getItem('friendRequestsReceived')) || []
    },
    blocked: JSON.parse(localStorage.getItem('blockedUsers')) || []
  };
  
  // Cache for performance
  let profilesCache = {};
  let onlineCache = {};
  let cacheTimestamp = 0;
  const CACHE_DURATION = 10000; // 10 seconds
  let notificationSystemInitialized = false;
  let friendsPollInterval = null;
  
  // Initialize friends system
  function initFriendsSystem() {
    // Skip entirely if social features are disabled or UI is missing
    if (backendFriendsDisabled || SOCIAL_FEATURES_ENABLED === false) return;
    if (!friendsBtn && !friendsModal) return;
    if (backendApi && !backendFriendsDisabled) {
        loadFriendsFromBackend();
        if (friendsPollInterval) clearInterval(friendsPollInterval);
        friendsPollInterval = setInterval(loadFriendsFromBackend, 5000);
        initNotificationSystem();
        return;
    }
    if (!db) return;
    
    // Load friends data from Firebase if available
    loadFriendsFromFirebase();
    
    // Set up real-time listeners
    setupFriendsRealtimeListeners();
    
    // Initialize notification system
    initNotificationSystem();
  }
  
  // Load friends from Firebase (with localStorage fallback)
  function loadFriendsFromFirebase() {
    if (!db) {
        updateAllDisplays();
        return;
    }
    
      Promise.all([
        db.ref(`friends/${visitorId}`).once('value'),
        db.ref(`friendRequests/${visitorId}`).once('value'),
        db.ref(`blocked/${visitorId}`).once('value'),
          db.ref('online').once('value')
    ]).then(([friendsSnap, requestsSnap, blockedSnap, onlineSnap]) => {
        // Load friends
        const firebaseFriends = friendsSnap.val();
        if (firebaseFriends) {
            friendsData.friends = Object.keys(firebaseFriends);
            localStorage.setItem('friends', JSON.stringify(friendsData.friends));
        }
        
        // Load requests
        const requests = requestsSnap.val() || {};
        friendsData.requests = {
            sent: Object.keys(requests.sent || {}),
            received: Object.keys(requests.received || {})
        };
        localStorage.setItem('friendRequestsSent', JSON.stringify(friendsData.requests.sent));
        localStorage.setItem('friendRequestsReceived', JSON.stringify(friendsData.requests.received));
        
        // Update notification badge
        updateNotificationBadge();
        
        // Load blocked
        const blocked = blockedSnap.val();
        if (blocked) {
            friendsData.blocked = Object.keys(blocked);
            localStorage.setItem('blockedUsers', JSON.stringify(friendsData.blocked));
        }
        
        // Cache online status
        onlineCache = onlineSnap.val() || {};
        
        // Only load profiles for friends, requests, and blocked users (not all profiles)
        const userIdsToLoad = new Set([
            ...friendsData.friends,
            ...friendsData.requests.sent,
            ...friendsData.requests.received,
            ...friendsData.blocked
        ]);
        
        if (userIdsToLoad.size > 0) {
            // Load only specific user profiles
            const profilePromises = Array.from(userIdsToLoad).map(userId => 
                db.ref(`profiles/${userId}`).once('value').then(snap => ({ id: userId, data: snap.val() }))
            );
            
            Promise.all(profilePromises).then(profileResults => {
                profileResults.forEach(({ id, data }) => {
                    if (data) {
                        profilesCache[id] = data;
                    }
                });
                cacheTimestamp = Date.now();
                updateAllDisplays();
            }).catch(err => {
                console.error('Error loading specific profiles:', err);
                updateAllDisplays();
            });
        } else {
            updateAllDisplays();
        }
    }).catch(err => {
        console.error('Error loading friends from Firebase:', err);
        updateAllDisplays();
    });
  }

  // Load friends using backend REST (polling)
  async function loadFriendsFromBackend() {
    if (!backendApi || backendFriendsDisabled || SOCIAL_FEATURES_ENABLED === false) return;
    try {
        const [friendsList, requests, onlineUsers, profiles] = await Promise.all([
            backendApi.getFriends(visitorId),
            backendApi.getFriendRequests(visitorId),
            backendApi.getOnlineUsers(),
            backendApi.getAllProfiles()
        ]);
        friendsData.friends = Array.isArray(friendsList) ? friendsList : [];
        friendsData.requests = {
            sent: Array.isArray(requests?.sent) ? requests.sent : [],
            received: Array.isArray(requests?.received) ? requests.received : []
        };
        localStorage.setItem('friends', JSON.stringify(friendsData.friends));
        localStorage.setItem('friendRequestsSent', JSON.stringify(friendsData.requests.sent));
        localStorage.setItem('friendRequestsReceived', JSON.stringify(friendsData.requests.received));
        updateNotificationBadge();

        onlineCache = Array.isArray(onlineUsers)
            ? onlineUsers.reduce((acc, u) => {
                const id = u.visitor_id || u.userId || u.visitorId;
                if (id) acc[id] = { online: true, username: u.username || 'Anonymous' };
                return acc;
              }, {})
            : {};

        profilesCache = Array.isArray(profiles)
            ? profiles.reduce((acc, p) => { const id = p.user_id || p.id; if (id) acc[id] = p; return acc; }, {})
            : (profiles || {});
        cacheTimestamp = Date.now();
        updateAllDisplays();
    } catch (err) {
        console.error('Error loading friends from backend:', err);
        // If backend endpoints are missing, disable backend polling and fall back
        if (String(err).includes('404')) {
            disableBackend('friends endpoints missing (404)');
            if (db) {
                loadFriendsFromFirebase();
            }
        }
        updateAllDisplays();
    }
  }
  
  // Setup real-time listeners
  function setupFriendsRealtimeListeners() {
    if (backendApi) return; // Backend mode uses polling
    if (!db) return;
    
    // Friends listener
    db.ref(`friends/${visitorId}`).on('value', (snap) => {
        const friends = snap.val();
        if (friends) {
            friendsData.friends = Object.keys(friends);
            localStorage.setItem('friends', JSON.stringify(friendsData.friends));
            updateCountBadges();
            if (document.querySelector('.friends-tab-btn[data-tab="friends"]')?.classList.contains('active')) {
                renderFriendsTab();
            }
        }
    });
    
    // Requests listener
    db.ref(`friendRequests/${visitorId}`).on('value', (snap) => {
        const requests = snap.val() || {};
        friendsData.requests = {
            sent: Object.keys(requests.sent || {}),
            received: Object.keys(requests.received || {})
        };
        localStorage.setItem('friendRequestsSent', JSON.stringify(friendsData.requests.sent));
        localStorage.setItem('friendRequestsReceived', JSON.stringify(friendsData.requests.received));
        updateCountBadges();
        updateNotificationBadge();
        if (document.querySelector('.friends-tab-btn[data-tab="requests"]')?.classList.contains('active')) {
            renderRequestsTab();
        }
    });
    
    // Online status listener
    db.ref('online').on('value', (snap) => {
        onlineCache = snap.val() || {};
        if (document.querySelector('.friends-tab-btn[data-tab="friends"]')?.classList.contains('active')) {
            renderFriendsTab();
        }
    });
  }
  
  // Update count badges
  function updateCountBadges() {
    const friendsBadge = document.getElementById('friendsCountBadge');
    const requestsBadge = document.getElementById('requestsCountBadge');
    const blockedBadge = document.getElementById('blockedCountBadge');
    
    if (friendsBadge) {
        friendsBadge.textContent = friendsData.friends.length;
        friendsBadge.style.display = friendsData.friends.length > 0 ? 'inline-block' : 'none';
    }
    
    if (requestsBadge) {
        const count = friendsData.requests.received.length;
        requestsBadge.textContent = count;
        requestsBadge.style.display = count > 0 ? 'inline-block' : 'none';
    }
    
    if (blockedBadge) {
        const count = friendsData.blocked.length;
        blockedBadge.textContent = count;
        blockedBadge.style.display = count > 0 ? 'inline-block' : 'none';
    }
  }
  
  // Update notification badge
  function updateNotificationBadge() {
    const notificationBadge = document.getElementById('notificationBadge');
    if (!notificationBadge) return;
    
    const count = (friendsData && friendsData.requests && friendsData.requests.received) 
        ? friendsData.requests.received.length 
        : 0;
    notificationBadge.textContent = count > 99 ? '99+' : count;
    notificationBadge.style.display = count > 0 ? 'flex' : 'none';
    
    // Update notification list
    updateNotificationList();
  }
  
  // Update notification list
  function updateNotificationList() {
    const notificationList = document.getElementById('notificationList');
    if (!notificationList) return;
    
    const receivedRequests = (friendsData && friendsData.requests && friendsData.requests.received) 
        ? friendsData.requests.received 
        : [];
    
    if (receivedRequests.length === 0) {
        notificationList.innerHTML = `
            <div class="notification-empty">
                <i class="fas fa-bell-slash"></i>
                <p>No notifications</p>
            </div>
        `;
        return;
    }
    
    // Load user profiles for notifications
    if (typeof loadUserProfiles === 'function') {
        loadUserProfiles(receivedRequests).then(users => {
            notificationList.innerHTML = users.map(({id, profile}) => {
                const avatarStyle = profile.avatarImage 
                    ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                    : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
                const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
                const username = profile.username || 'Unknown User';
                
                return `
                    <div class="notification-item" data-user-id="${id}">
                        <div class="notification-avatar" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:24px;">
                            ${avatarContent}
                        </div>
                        <div class="notification-content">
                            <p class="notification-text"><strong>${username}</strong> sent you a friend request</p>
                            <div class="notification-actions">
                                <button class="notification-action-btn accept" onclick="acceptFriendRequest('${id}'); closeNotificationDropdown();">
                                    <i class="fas fa-check"></i> Accept
                                </button>
                                <button class="notification-action-btn decline" onclick="declineFriendRequest('${id}'); closeNotificationDropdown();">
                                    <i class="fas fa-times"></i> Decline
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }).catch(() => {
            // Fallback if loadUserProfiles fails
            notificationList.innerHTML = `
                <div class="notification-empty">
                    <i class="fas fa-bell-slash"></i>
                    <p>No notifications</p>
                </div>
            `;
        });
    } else {
        // Fallback if loadUserProfiles is not available
        notificationList.innerHTML = `
            <div class="notification-empty">
                <i class="fas fa-bell-slash"></i>
                <p>No notifications</p>
            </div>
        `;
    }
  }
  
  // Toggle notification dropdown
  function toggleNotificationDropdown() {
    const dropdown = document.getElementById('notificationDropdown');
    if (!dropdown) return;
    
    dropdown.classList.toggle('active');
    
    // Close when clicking outside
    if (dropdown.classList.contains('active')) {
        setTimeout(() => {
            document.addEventListener('click', function closeOnOutsideClick(e) {
                if (!dropdown.contains(e.target) && !e.target.closest('#notificationBellBtn')) {
                    dropdown.classList.remove('active');
                    document.removeEventListener('click', closeOnOutsideClick);
                }
            });
        }, 100);
    }
  }
  
  // Close notification dropdown
  function closeNotificationDropdown() {
    const dropdown = document.getElementById('notificationDropdown');
    if (dropdown) {
        dropdown.classList.remove('active');
    }
  }
  
  // Initialize notification system
  function initNotificationSystem() {
    if (notificationSystemInitialized) return;
    notificationSystemInitialized = true;
    const notificationBellBtn = document.getElementById('notificationBellBtn');
    const clearAllBtn = document.getElementById('clearAllNotificationsBtn');
    
    if (notificationBellBtn) {
        notificationBellBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleNotificationDropdown();
        });
    }
    
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', () => {
            // Decline all friend requests
            if (friendsData && friendsData.requests && friendsData.requests.received) {
                friendsData.requests.received.forEach(userId => {
                    if (typeof declineFriendRequest === 'function') {
                        declineFriendRequest(userId);
                    }
                });
            }
            closeNotificationDropdown();
        });
    }
    
    // Initial update
    updateNotificationBadge();
  }
  
  // Tab navigation
  document.querySelectorAll('.friends-tab-btn').forEach(tab => {
    tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        
        // Update active state
        document.querySelectorAll('.friends-tab-btn').forEach(t => {
            t.classList.remove('active');
        });
        tab.classList.add('active');
        
        // Show/hide panels
        document.querySelectorAll('.friends-tab-panel').forEach(panel => {
            panel.classList.remove('active');
        });
        
        const targetPanel = document.getElementById(`${targetTab}TabContent`);
        if (targetPanel) {
            targetPanel.classList.add('active');
            
            // Load data for active tab
            switch(targetTab) {
                case 'friends':
                    renderFriendsTab();
                    break;
                case 'requests':
                    renderRequestsTab();
                    break;
                case 'search':
                    // Load all profiles when search tab is opened
                    loadAllProfiles();
                    break;
                case 'blocked':
                    renderBlockedTab();
                    break;
            }
        }
    });
  });
  
  // Render friends tab
  function renderFriendsTab() {
    const friendsList = document.getElementById('friendsList');
    if (!friendsList) return;
    
    if (friendsData.friends.length === 0) {
        friendsList.innerHTML = `
            <div class="friends-empty-state">
                <i class="fas fa-user-friends"></i>
                <h3>No Friends Yet</h3>
                <p>Start by searching for users or accepting friend requests!</p>
            </div>
        `;
        updateCountBadges();
        return;
    }
    
    // Get friend data
    const friendsWithData = friendsData.friends.map(id => {
        const profile = profilesCache[id] || {};
        const isOnline = !!onlineCache[id];
        return { id, profile, isOnline };
    });
    
    // Apply sorting
    const sortValue = document.getElementById('friendsSortSelect')?.value || 'online';
    friendsWithData.sort((a, b) => {
        if (sortValue === 'online') {
            if (a.isOnline !== b.isOnline) return b.isOnline - a.isOnline;
            return (a.profile.username || '').localeCompare(b.profile.username || '');
        } else if (sortValue === 'name') {
            return (a.profile.username || '').localeCompare(b.profile.username || '');
        }
        return 0;
    });
    
    // Apply filter
    const filterValue = document.getElementById('filterFriendsInput')?.value.toLowerCase() || '';
    const filtered = filterValue 
        ? friendsWithData.filter(f => (f.profile.username || '').toLowerCase().includes(filterValue))
        : friendsWithData;
    
    // Render friend cards
    friendsList.innerHTML = filtered.map(({id, profile, isOnline}) => {
                  const avatarStyle = profile.avatarImage 
                      ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                      : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
                  const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
        const status = profile.status || '';
        
        return `
            <div class="friend-card-modern ${isOnline ? 'online' : ''}">
                <div class="friend-card-header">
                    <div class="friend-avatar-modern" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:36px;">
                        ${avatarContent}
                        <div class="friend-status-dot ${isOnline ? 'online' : ''}"></div>
                    </div>
                    <div class="friend-info-modern">
                        <div class="friend-name-modern">${profile.username || 'User'}</div>
                        <div class="friend-status-text">
                            ${isOnline ? '<span style="color:#28a745;">🟢 Online</span>' : '<span style="color:#6c757d;">⚫ Offline</span>'}
                        </div>
                        ${status ? `<div class="friend-status-message">"${status}"</div>` : ''}
                    </div>
                </div>
                <div class="friend-actions-modern">
                    <button class="friend-action-btn-modern primary" onclick="viewFriendProfile('${id}')" title="View Profile">
                        <i class="fas fa-user"></i> Profile
                    </button>
                    <button class="friend-action-btn-modern" style="background:linear-gradient(135deg, #28a745, #20c997);" onclick="openPrivateChat('${id}')" title="Private Chat">
                        <i class="fas fa-comments"></i> Chat
                    </button>
                    <button class="friend-action-btn-modern danger" onclick="removeFriend('${id}')" title="Remove Friend">
                        <i class="fas fa-user-minus"></i> Remove
                    </button>
                    <button class="friend-action-btn-modern secondary" onclick="blockUser('${id}')" title="Block User">
                        <i class="fas fa-ban"></i> Block
                    </button>
                </div>
            </div>
        `;
    }).join('');
    
    updateCountBadges();
  }
  
  // Render requests tab
  function renderRequestsTab() {
    const sentList = document.getElementById('sentRequestsList');
    const receivedList = document.getElementById('receivedRequestsList');
    
    // Render sent requests
    if (sentList) {
        if (friendsData.requests.sent.length === 0) {
            sentList.innerHTML = '<div class="friends-empty-state" style="padding:40px 20px;"><i class="fas fa-paper-plane"></i><h3>No Sent Requests</h3><p>Friend requests you send will appear here</p></div>';
        } else {
            loadUserProfiles(friendsData.requests.sent).then(users => {
                sentList.innerHTML = users.map(({id, profile}) => {
                    const avatarStyle = profile.avatarImage 
                        ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                        : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
                    const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
                    
                    return `
                        <div class="request-card-modern">
                            <div class="request-card-header">
                                <div class="request-avatar" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:28px;">
                                    ${avatarContent}
                                </div>
                                <div class="request-info">
                                    <h4>${profile.username || 'User'}</h4>
                                    <p>Pending request</p>
                                </div>
                            </div>
                            <div class="request-actions">
                                <button class="friend-action-btn-modern secondary" onclick="cancelFriendRequest('${id}')">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
            });
        }
    }
    
    // Render received requests
    if (receivedList) {
        if (friendsData.requests.received.length === 0) {
            receivedList.innerHTML = '<div class="friends-empty-state" style="padding:40px 20px;"><i class="fas fa-inbox"></i><h3>No Pending Requests</h3><p>Friend requests you receive will appear here</p></div>';
        } else {
            loadUserProfiles(friendsData.requests.received).then(users => {
                receivedList.innerHTML = users.map(({id, profile}) => {
                    const avatarStyle = profile.avatarImage 
                        ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                        : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
                    const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
                    
                    return `
                        <div class="request-card-modern">
                            <div class="request-card-header">
                                <div class="request-avatar" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:32px;">
                  ${avatarContent}
              </div>
                                <div class="request-info">
                                    <h4>${profile.username || 'User'}</h4>
                                    <p>wants to be your friend</p>
              </div>
                            </div>
                            <div class="request-actions">
                                <button class="friend-action-btn-modern success" onclick="acceptFriendRequest('${id}')">
                                    <i class="fas fa-check"></i> Accept
                                </button>
                                <button class="friend-action-btn-modern danger" onclick="declineFriendRequest('${id}')">
                                    <i class="fas fa-times"></i> Decline
              </button>
          </div>
                        </div>
                    `;
                }).join('');
            });
        }
    }
    
    updateCountBadges();
  }
  
  // Render blocked tab
  function renderBlockedTab() {
    const blockedList = document.getElementById('blockedList');
    if (!blockedList) return;
    
    if (friendsData.blocked.length === 0) {
        blockedList.innerHTML = `
            <div class="friends-empty-state">
                <i class="fas fa-ban"></i>
                <h3>No Blocked Users</h3>
                <p>Users you block will appear here</p>
            </div>
        `;
        updateCountBadges();
        return;
    }
    
    loadUserProfiles(friendsData.blocked).then(users => {
        blockedList.innerHTML = users.map(({id, profile}) => {
            const avatarStyle = profile.avatarImage 
                ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
            const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
            
            return `
                <div class="friend-card-modern" style="opacity:0.6;">
                    <div class="friend-card-header">
                        <div class="friend-avatar-modern" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:36px;">
                            ${avatarContent}
                        </div>
                        <div class="friend-info-modern">
                            <div class="friend-name-modern">${profile.username || 'User'}</div>
                            <div class="friend-status-text" style="color:rgba(255,255,255,0.4);">Blocked</div>
                        </div>
                    </div>
                    <div class="friend-actions-modern">
                        <button class="friend-action-btn-modern success" onclick="unblockUser('${id}')">
                            <i class="fas fa-unlock"></i> Unblock
                        </button>
                    </div>
                </div>
            `;
        }).join('');
    });
    
    updateCountBadges();
  }
  
  // Helper function to load user profiles - optimized to only load specific profiles
  function loadUserProfiles(userIds) {
    if (!db || !userIds || userIds.length === 0) {
        return Promise.resolve(userIds.map(id => ({
            id,
            profile: profilesCache[id] || {}
        })));
    }
    
    // Filter out user IDs we already have cached
    const userIdsToLoad = userIds.filter(id => !profilesCache[id]);
    
    // If we have all profiles cached, return from cache
    if (userIdsToLoad.length === 0) {
        return Promise.resolve(userIds.map(id => ({
            id,
            profile: profilesCache[id] || {}
        })));
    }
    
    // Only load profiles we don't have cached
    const profilePromises = userIdsToLoad.map(userId => 
        db.ref(`profiles/${userId}`).once('value').then(snap => ({ id: userId, data: snap.val() }))
    );
    
    return Promise.all(profilePromises).then(profileResults => {
        // Update cache with new profiles
        profileResults.forEach(({ id, data }) => {
            if (data) {
                profilesCache[id] = data;
            }
        });
        cacheTimestamp = Date.now();
        
        // Return all requested profiles (from cache or newly loaded)
        return userIds.map(id => ({
            id,
            profile: profilesCache[id] || {}
        }));
    }).catch(err => {
        console.error('Error loading user profiles:', err);
        // Return what we have in cache even if there's an error
        return userIds.map(id => ({
            id,
            profile: profilesCache[id] || {}
        }));
    });
  }
  
// Friend profile modal helpers
const friendProfileModal = document.getElementById('friendProfileModal');
const friendProfileCard = document.getElementById('friendProfileCard');
const closeFriendProfileModalBtn = document.getElementById('closeFriendProfileModal');
const friendProfileAvatar = document.getElementById('friendProfileAvatar');
const friendProfileAvatarEmoji = document.getElementById('friendProfileAvatarEmoji');
const friendProfileName = document.getElementById('friendProfileName');
const friendProfilePresence = document.getElementById('friendProfilePresence');
const friendProfileStatus = document.getElementById('friendProfileStatus');
const friendProfilePronounsValue = document.getElementById('friendProfilePronounsValue');
const friendProfileLocationValue = document.getElementById('friendProfileLocationValue');
const friendProfileBioValue = document.getElementById('friendProfileBioValue');
const friendProfileColorSwatch = document.getElementById('friendProfileColorSwatch');
const friendProfileColorLabel = document.getElementById('friendProfileColorLabel');
const friendProfileInterests = document.getElementById('friendProfileInterests');
const friendProfileLoading = document.getElementById('friendProfileLoading');

function setFriendProfileLoadingState(isLoading) {
    if (!friendProfileCard || !friendProfileLoading) return;
    friendProfileCard.classList.toggle('loading', isLoading);
    friendProfileLoading.style.display = isLoading ? 'flex' : 'none';
}

function closeFriendProfileModal() {
    if (!friendProfileModal) return;
    friendProfileModal.classList.remove('visible');
    setFriendProfileLoadingState(false);
    setTimeout(() => {
        if (friendProfileModal) {
            friendProfileModal.style.display = 'none';
        }
    }, 200);
}

function renderFriendProfile(profile = {}, friendId, options = {}) {
    if (!friendProfileModal) return;
    const safeProfile = profile || {};
    const isOnline = !!onlineCache[friendId];
    const sanitizedColor = sanitizeHexColor(safeProfile.favoriteColor || '#FFD700');
    
    if (friendProfileAvatar) {
        if (safeProfile.avatarImage) {
            friendProfileAvatar.style.backgroundImage = `url(${safeProfile.avatarImage})`;
            if (friendProfileAvatarEmoji) friendProfileAvatarEmoji.style.display = 'none';
        } else {
            friendProfileAvatar.style.backgroundImage = 'none';
            if (friendProfileAvatarEmoji) {
                friendProfileAvatarEmoji.style.display = 'block';
                friendProfileAvatarEmoji.textContent = safeProfile.avatar || '👤';
            }
        }
    }
    
    if (friendProfileName) {
        friendProfileName.textContent = safeProfile.username || 'Player';
    }
    if (friendProfileStatus) {
        friendProfileStatus.textContent = safeProfile.status || 'No status message shared yet.';
    }
    if (friendProfilePresence) {
        friendProfilePresence.innerHTML = `
            <span class="friend-profile-status-dot ${isOnline ? 'online' : ''}"></span>
            ${isOnline ? 'Online now' : 'Offline'}
        `;
    }
    if (friendProfilePronounsValue) {
        friendProfilePronounsValue.textContent = safeProfile.pronouns || 'Not shared';
    }
    if (friendProfileLocationValue) {
        friendProfileLocationValue.textContent = safeProfile.location || 'Not shared';
    }
    if (friendProfileBioValue) {
        friendProfileBioValue.textContent = safeProfile.bio || "This player hasn't shared a bio yet.";
    }
    if (friendProfileColorSwatch) {
        friendProfileColorSwatch.style.background = sanitizedColor;
    }
    if (friendProfileColorLabel) {
        friendProfileColorLabel.textContent = sanitizedColor.toUpperCase();
    }
    if (friendProfileInterests) {
        const interests = Array.isArray(safeProfile.interests) ? safeProfile.interests.filter(Boolean) : [];
        friendProfileInterests.innerHTML = '';
        if (!interests.length) {
            friendProfileInterests.innerHTML = '<p class="friend-profile-empty">No interests added yet.</p>';
        } else {
            interests.forEach(interest => {
                const chip = document.createElement('span');
                chip.className = 'friend-profile-chip';
                chip.textContent = interest;
                friendProfileInterests.appendChild(chip);
            });
        }
    }
    
    friendProfileModal.dataset.friendId = friendId || '';
    if (friendProfileModal.style.display !== 'flex') {
        friendProfileModal.style.display = 'flex';
        requestAnimationFrame(() => friendProfileModal.classList.add('visible'));
    }
    
    setFriendProfileLoadingState(!!options.isLoading);
}

closeFriendProfileModalBtn?.addEventListener('click', closeFriendProfileModal);
friendProfileModal?.addEventListener('click', (event) => {
    if (event.target === friendProfileModal) {
        closeFriendProfileModal();
    }
});

// Auto-open fullscreen chat when requested via query param
try {
    const params = new URLSearchParams(window.location.search);
    if (params.get('fullscreenChat') === '1') {
        const chatContainer = document.getElementById('chatContainer');
        if (chatContainer) chatContainer.style.display = 'none';
        if (fullScreenChatModal) {
            fullScreenChatModal.style.display = 'block';
            syncChatMessages();
            loadOnlineUsers();
            setTimeout(() => {
                if (fullscreenChatMessages) {
                    fullscreenChatMessages.scrollTop = fullscreenChatMessages.scrollHeight;
                }
            }, 400);
        }
    }
} catch (err) {
    console.warn('Unable to auto-open fullscreen chat', err);
}

  // Friend actions (global functions)
  window.viewFriendProfile = function(friendId) {
    if (!friendId) return;
    if (!friendProfileModal) {
        notifications.show('Profile viewer is not available right now.', 'error', 2500);
        return;
    }
    
    renderFriendProfile({
        username: 'Loading profile...',
        status: 'Fetching the latest details...',
        interests: []
    }, friendId, { isLoading: true });
    
    loadUserProfiles([friendId]).then(results => {
        const profileEntry = Array.isArray(results) ? results.find(entry => entry.id === friendId) : null;
        const profile = profileEntry?.profile || profilesCache[friendId] || {};
        renderFriendProfile(profile, friendId, { isLoading: false });
    }).catch(err => {
        console.error('Error loading friend profile:', err);
        setFriendProfileLoadingState(false);
        notifications.show('Unable to load that profile right now.', 'error', 2500);
    });
  };
  
  window.removeFriend = function(friendId) {
    const profile = profilesCache[friendId] || {};
    if (!confirm(`Remove ${profile.username || 'this user'} from your friends?`)) return;
    
    // Remove from friends
    friendsData.friends = friendsData.friends.filter(id => id !== friendId);
    localStorage.setItem('friends', JSON.stringify(friendsData.friends));
    
    // Remove from Firebase if db exists
    if (backendApi) {
        backendApi.removeFriend(visitorId, friendId).catch(err => console.error('Backend remove friend failed', err));
    } else if (db) {
        db.ref(`friends/${visitorId}/${friendId}`).remove();
        db.ref(`friends/${friendId}/${visitorId}`).remove();
    }
    
    notifications.show('Friend removed', 'success', 2000);
    renderFriendsTab();
    updateCountBadges();
  };
  
  window.blockUser = function(userId) {
    const profile = profilesCache[userId] || {};
    if (!confirm(`Block ${profile.username || 'this user'}? They won't be able to see you or send you requests.`)) return;
    
    // Remove from friends if they are friends
    if (friendsData.friends.includes(userId)) {
        friendsData.friends = friendsData.friends.filter(id => id !== userId);
        localStorage.setItem('friends', JSON.stringify(friendsData.friends));
        if (db) {
            db.ref(`friends/${visitorId}/${userId}`).remove();
            db.ref(`friends/${userId}/${visitorId}`).remove();
        }
    }
    
    // Add to blocked
    if (!friendsData.blocked.includes(userId)) {
        friendsData.blocked.push(userId);
        localStorage.setItem('blockedUsers', JSON.stringify(friendsData.blocked));
    }
    
    if (db) {
        db.ref(`blocked/${visitorId}/${userId}`).set(true);
    }
    
    notifications.show('User blocked', 'success', 2000);
    renderFriendsTab();
    renderBlockedTab();
    updateCountBadges();
  };
  
  window.unblockUser = function(userId) {
    friendsData.blocked = friendsData.blocked.filter(id => id !== userId);
    localStorage.setItem('blockedUsers', JSON.stringify(friendsData.blocked));
    
    if (db) {
        db.ref(`blocked/${visitorId}/${userId}`).remove();
    }
    
    notifications.show('User removed from block list', 'success', 2000);
    renderBlockedTab();
    updateCountBadges();
  };
  
  window.sendFriendRequest = function(userId) {
      if (!db && !backendApi) {
          notifications.show('Database not available', 'error', 2000);
          return;
      }
    
    // Check if already friends
    if (friendsData.friends.includes(userId)) {
        notifications.show('Already friends!', 'info', 2000);
        return;
    }
    
    // Check if already sent
    if (friendsData.requests.sent.includes(userId)) {
        notifications.show('Request already sent', 'info', 2000);
        return;
    }
    
    // Check if blocked
    if (friendsData.blocked.includes(userId)) {
        notifications.show('Cannot send request to blocked user', 'error', 2000);
        return;
    }
    
      // Send request
      if (backendApi) {
          backendApi.sendFriendRequest(visitorId, userId).catch(err => console.error('Backend friend request failed', err));
      } else if (db) {
          db.ref(`friendRequests/${userId}/received/${visitorId}`).set({
              from: visitorId,
              timestamp: Date.now()
          });
          db.ref(`friendRequests/${visitorId}/sent/${userId}`).set({
              to: userId,
              timestamp: Date.now()
          });
      }
    
    friendsData.requests.sent.push(userId);
    localStorage.setItem('friendRequestsSent', JSON.stringify(friendsData.requests.sent));
    
    notifications.show('Friend request sent!', 'success', 2000);
    renderRequestsTab();
    updateCountBadges();
  };
  
  window.acceptFriendRequest = function(userId) {
      if (!db && !backendApi) {
          notifications.show('Database not available', 'error', 2000);
          return;
      }
      
      // Add to friends
      if (backendApi) {
          backendApi.acceptFriendRequest(visitorId, userId).catch(err => console.error('Backend accept failed', err));
      } else {
          db.ref(`friends/${visitorId}/${userId}`).set(true);
          db.ref(`friends/${userId}/${visitorId}`).set(true);
          // Remove from requests
          db.ref(`friendRequests/${visitorId}/received/${userId}`).remove();
          db.ref(`friendRequests/${userId}/sent/${visitorId}`).remove();
      }
    
    friendsData.friends.push(userId);
    friendsData.requests.received = friendsData.requests.received.filter(id => id !== userId);
    localStorage.setItem('friends', JSON.stringify(friendsData.friends));
    localStorage.setItem('friendRequestsReceived', JSON.stringify(friendsData.requests.received));
    
    const profile = profilesCache[userId] || {};
    notifications.show(`You are now friends with ${profile.username || 'this user'}!`, 'success', 3000);
    renderFriendsTab();
    renderRequestsTab();
    updateCountBadges();
  };
  
window.declineFriendRequest = function(userId) {
    if (!db && !backendApi) {
        notifications.show('Database not available', 'error', 2000);
        return;
    }
    
    // Remove from requests
    if (backendApi) {
        backendApi.declineFriendRequest(visitorId, userId).catch(err => console.error('Backend decline failed', err));
    } else {
        db.ref(`friendRequests/${visitorId}/received/${userId}`).remove();
        db.ref(`friendRequests/${userId}/sent/${visitorId}`).remove();
    }
    
    friendsData.requests.received = friendsData.requests.received.filter(id => id !== userId);
    localStorage.setItem('friendRequestsReceived', JSON.stringify(friendsData.requests.received));
    
    notifications.show('Friend request declined', 'info', 2000);
    renderRequestsTab();
    updateCountBadges();
  };
  
  // Private chat functionality
  let currentPrivateChatId = null;
  let privateChatRef = null;
  
  window.openPrivateChat = function(friendId) {
    if (!friendId || !db) {
      notifications.show('Chat unavailable', 'error', 2000);
      return;
    }
    
    const profile = profilesCache[friendId] || {};
    const privateChatModal = document.getElementById('privateChatModal');
    const privateChatName = document.getElementById('privateChatName');
    const privateChatAvatar = document.getElementById('privateChatAvatar');
    const privateChatStatus = document.getElementById('privateChatStatus');
    const privateChatMessages = document.getElementById('privateChatMessages');
    const privateChatInput = document.getElementById('privateChatInput');
    const sendPrivateChatBtn = document.getElementById('sendPrivateChatBtn');
    
    if (!privateChatModal) return;
    
    currentPrivateChatId = friendId;
    privateChatName.textContent = profile.username || 'Friend';
    privateChatStatus.textContent = onlineCache[friendId] ? '🟢 Online' : '⚫ Offline';
    
    if (profile.avatarImage) {
      privateChatAvatar.style.backgroundImage = `url(${profile.avatarImage})`;
      privateChatAvatar.style.backgroundSize = 'cover';
      privateChatAvatar.style.backgroundPosition = 'center';
      privateChatAvatar.textContent = '';
    } else {
      privateChatAvatar.style.backgroundImage = '';
      privateChatAvatar.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
      privateChatAvatar.textContent = profile.avatar || '👤';
    }
    
    privateChatMessages.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Loading messages...</p>';
    privateChatModal.style.display = 'flex';
    
    // Set up Firebase listener for private messages
    const chatId = [visitorId, friendId].sort().join('_');
    privateChatRef = db.ref(`privateChats/${chatId}/messages`);
    
    privateChatRef.orderByChild('timestamp').limitToLast(50).on('value', (snap) => {
      const messages = snap.val() || {};
      const messagesArray = Object.keys(messages).map(key => ({ id: key, ...messages[key] })).sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
      
      privateChatMessages.innerHTML = messagesArray.map(msg => {
        const isOwn = msg.from === visitorId;
        return `
          <div style="display:flex; ${isOwn ? 'justify-content:flex-end' : 'justify-content:flex-start'};">
            <div style="max-width:70%; padding:10px 14px; background:${isOwn ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'rgba(255,255,255,0.1)'}; border-radius:12px; color:${isOwn ? '#000' : 'rgba(255,255,255,0.9)'};">
              <div style="font-size:12px; opacity:0.7; margin-bottom:4px;">${msg.fromName || 'User'}</div>
              <div>${msg.text || ''}</div>
              <div style="font-size:10px; opacity:0.6; margin-top:4px;">${new Date(msg.timestamp).toLocaleTimeString()}</div>
            </div>
          </div>
        `;
      }).join('');
      
      privateChatMessages.scrollTop = privateChatMessages.scrollHeight;
    });
    
    // Send message handler
    function sendPrivateMessage() {
      const text = privateChatInput.value.trim();
      if (!text || !privateChatRef) return;
      
      const chatId = [visitorId, friendId].sort().join('_');
      const messageRef = db.ref(`privateChats/${chatId}/messages`).push();
      messageRef.set({
        from: visitorId,
        fromName: username || 'User',
        to: friendId,
        text: text,
        timestamp: Date.now()
      });
      
      privateChatInput.value = '';
    }
    
    sendPrivateChatBtn.onclick = sendPrivateMessage;
    privateChatInput.onkeypress = (e) => {
      if (e.key === 'Enter') sendPrivateMessage();
    };
  };
  
  // Close private chat
  document.getElementById('closePrivateChatBtn')?.addEventListener('click', () => {
    const privateChatModal = document.getElementById('privateChatModal');
    if (privateChatModal) {
      privateChatModal.style.display = 'none';
      if (privateChatRef) {
        privateChatRef.off();
        privateChatRef = null;
      }
      currentPrivateChatId = null;
    }
  });
  
window.cancelFriendRequest = function(userId) {
    if (!db && !backendApi) {
        notifications.show('Database not available', 'error', 2000);
        return;
    }
    
    // Remove from requests
    if (backendApi) {
        backendApi.deleteFriendRequest(visitorId, userId).catch(err => console.error('Backend cancel request failed', err));
    } else {
        db.ref(`friendRequests/${visitorId}/sent/${userId}`).remove();
        db.ref(`friendRequests/${userId}/received/${visitorId}`).remove();
    }
    
    friendsData.requests.sent = friendsData.requests.sent.filter(id => id !== userId);
    localStorage.setItem('friendRequestsSent', JSON.stringify(friendsData.requests.sent));
    
    notifications.show('Friend request cancelled', 'info', 2000);
    renderRequestsTab();
    updateCountBadges();
  };
  
  // Search functionality
  const searchFriendsInput = document.getElementById('searchFriendsInput');
  const clearSearchBtn = document.getElementById('clearSearchBtn');
  const searchResults = document.getElementById('searchResults');
  
  searchFriendsInput?.addEventListener('input', Utils.debounce((e) => {
      const query = e.target.value.toLowerCase().trim();
    
    if (clearSearchBtn) {
        clearSearchBtn.style.display = query.length > 0 ? 'flex' : 'none';
    }
    
    if (!searchResults || (!db && !backendApi)) return;
    
    if (query.length === 0) {
        // Show all profiles when search is empty
        loadAllProfiles();
          return;
      }
      
    // Use cached profiles if available (don't reload all profiles on every search)
    // Only reload if cache is very stale (5 minutes) or completely empty
    const now = Date.now();
    const LONG_CACHE_DURATION = 300000; // 5 minutes instead of 10 seconds
    const shouldReload = (now - cacheTimestamp > LONG_CACHE_DURATION || Object.keys(profilesCache).length === 0);

    if (shouldReload) {
        const loader = backendApi
            ? Promise.all([backendApi.getAllProfiles(), backendApi.getOnlineUsers()])
            : Promise.all([db.ref('profiles').once('value'), db.ref('online').once('value')]);

        loader.then(([profilesData, onlineData]) => {
            if (backendApi) {
                profilesCache = Array.isArray(profilesData)
                    ? profilesData.reduce((acc, p) => { if (p.user_id) acc[p.user_id] = p; return acc; }, {})
                    : profilesData || {};
                onlineCache = Array.isArray(onlineData)
                    ? onlineData.reduce((acc, u) => { const id = u.visitor_id || u.userId || u.visitorId; if (id) acc[id] = { online: true, username: u.username || 'Anonymous' }; return acc; }, {})
                    : onlineData || {};
            } else {
                profilesCache = profilesData.val() || {};
                onlineCache = onlineData.val() || {};
            }
            cacheTimestamp = now;
            performSearch(query);
        }).catch(err => {
            console.error('Error loading profiles for search:', err);
            // Use cached data even if reload fails
            performSearch(query);
        });
    } else {
        performSearch(query);
    }
  }, 400));
  
  clearSearchBtn?.addEventListener('click', () => {
    if (searchFriendsInput) {
        searchFriendsInput.value = '';
        clearSearchBtn.style.display = 'none';
        // Show all profiles when search is cleared
        loadAllProfiles();
    }
  });
  
  // Function to load and display all profiles
    function loadAllProfiles() {
      if (!searchResults || SOCIAL_FEATURES_ENABLED === false) return;
      const loader = (backendApi && !backendFriendsDisabled)
          ? Promise.all([backendApi.getAllProfiles(), backendApi.getOnlineUsers()])
          : (db ? Promise.all([db.ref('profiles').once('value'), db.ref('online').once('value')]) : null);
      if (!loader) return;
      loader.then(([profilesData, onlineData]) => {
          if (backendApi && !backendFriendsDisabled) {
              profilesCache = Array.isArray(profilesData)
                  ? profilesData.reduce((acc, p) => { if (p.user_id) acc[p.user_id] = p; return acc; }, {})
                  : profilesData || {};
              onlineCache = Array.isArray(onlineData)
                  ? onlineData.reduce((acc, u) => { const id = u.visitor_id || u.userId || u.visitorId; if (id) acc[id] = { online: true, username: u.username || 'Anonymous' }; return acc; }, {})
                  : onlineData || {};
          } else {
              profilesCache = profilesData.val() || {};
              onlineCache = onlineData.val() || {};
          }
          cacheTimestamp = Date.now();
          displayAllProfiles();
      }).catch(err => {
          console.error('Error loading profiles:', err);
          if (String(err).includes('404')) {
              disableBackend('profiles/all endpoint missing (404)');
          }
          if (Object.keys(profilesCache).length > 0) {
              displayAllProfiles();
          } else {
              searchResults.innerHTML = '<div class="friends-empty-state"><i class="fas fa-exclamation-triangle"></i><h3>Error Loading Profiles</h3><p>Please try again later</p></div>';
          }
      });
    }
  
  // Function to display all profiles (no filtering)
  function displayAllProfiles() {
    if (!searchResults) return;
    
    const allProfiles = Object.entries(profilesCache)
        .filter(([id, profile]) => 
            id !== visitorId && 
            !friendsData.blocked.includes(id) &&
            profile.username
        )
        .map(([id, profile]) => {
            const isOnline = !!onlineCache[id];
            return { id, profile, isOnline };
        })
        .sort((a, b) => {
            // Sort online users first, then alphabetically by username
            if (a.isOnline !== b.isOnline) return b.isOnline - a.isOnline;
            return (a.profile.username || '').localeCompare(b.profile.username || '');
        })
        .map(({ id, profile, isOnline }) => {
            const isFriend = friendsData.friends.includes(id);
            const hasSentRequest = friendsData.requests.sent.includes(id);
            const hasReceivedRequest = friendsData.requests.received.includes(id);
            
            const avatarStyle = profile.avatarImage 
                ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
            const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
            const status = profile.status || '';
            
            let actionButton = '';
            if (isFriend) {
                actionButton = '<button class="friend-action-btn-modern secondary" disabled><i class="fas fa-check"></i> Friends</button>';
            } else if (hasSentRequest) {
                actionButton = '<button class="friend-action-btn-modern secondary" onclick="cancelFriendRequest(\'' + id + '\')"><i class="fas fa-clock"></i> Pending</button>';
            } else if (hasReceivedRequest) {
                actionButton = '<div class="request-actions"><button class="friend-action-btn-modern success" onclick="acceptFriendRequest(\'' + id + '\')"><i class="fas fa-check"></i> Accept</button><button class="friend-action-btn-modern danger" onclick="declineFriendRequest(\'' + id + '\')"><i class="fas fa-times"></i> Decline</button></div>';
            } else {
                actionButton = '<button class="friend-action-btn-modern primary" onclick="sendFriendRequest(\'' + id + '\')"><i class="fas fa-user-plus"></i> Add Friend</button>';
            }
            
            return `
                <div class="friend-card-modern ${isOnline ? 'online' : ''}">
                    <div class="friend-card-header">
                        <div class="friend-avatar-modern" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:36px;">
                              ${avatarContent}
                            <div class="friend-status-dot ${isOnline ? 'online' : ''}"></div>
                          </div>
                        <div class="friend-info-modern">
                            <div class="friend-name-modern">${profile.username || 'User'}</div>
                            <div class="friend-status-text">
                                ${isOnline ? '<span style="color:#28a745;">🟢 Online</span>' : '<span style="color:#6c757d;">⚫ Offline</span>'}
                              </div>
                            ${status ? `<div class="friend-status-message">"${status}"</div>` : ''}
                          </div>
                    </div>
                    <div class="friend-actions-modern">
                        ${actionButton}
                        <button class="friend-action-btn-modern secondary" onclick="viewFriendProfile('${id}')">
                            <i class="fas fa-user"></i> View
                        </button>
                    </div>
                      </div>
                  `;
        });
    
    if (allProfiles.length === 0) {
        searchResults.innerHTML = '<div class="friends-empty-state"><i class="fas fa-users"></i><h3>No Users Found</h3><p>No profiles available at this time</p></div>';
    } else {
        searchResults.innerHTML = allProfiles.join('');
    }
  }
  
  function performSearch(query) {
    if (!searchResults) return;
    
    const matches = Object.entries(profilesCache)
              .filter(([id, profile]) => 
                  id !== visitorId && 
            !friendsData.blocked.includes(id) &&
                  profile.username && 
                  profile.username.toLowerCase().includes(query)
              )
        .slice(0, 30)
              .map(([id, profile]) => {
            const isOnline = !!onlineCache[id];
            const isFriend = friendsData.friends.includes(id);
            const hasSentRequest = friendsData.requests.sent.includes(id);
            const hasReceivedRequest = friendsData.requests.received.includes(id);
            
                  const avatarStyle = profile.avatarImage 
                      ? `background-image: url(${profile.avatarImage}); background-size: cover; background-position: center;`
                      : `background: linear-gradient(135deg, #FFD700, #FFA500);`;
                  const avatarContent = profile.avatarImage ? '' : (profile.avatar || '👤');
            const status = profile.status || '';
            
            let actionButton = '';
            if (isFriend) {
                actionButton = '<button class="friend-action-btn-modern secondary" disabled><i class="fas fa-check"></i> Friends</button>';
            } else if (hasSentRequest) {
                actionButton = '<button class="friend-action-btn-modern secondary" onclick="cancelFriendRequest(\'' + id + '\')"><i class="fas fa-clock"></i> Pending</button>';
            } else if (hasReceivedRequest) {
                actionButton = '<div class="request-actions"><button class="friend-action-btn-modern success" onclick="acceptFriendRequest(\'' + id + '\')"><i class="fas fa-check"></i> Accept</button><button class="friend-action-btn-modern danger" onclick="declineFriendRequest(\'' + id + '\')"><i class="fas fa-times"></i> Decline</button></div>';
            } else {
                actionButton = '<button class="friend-action-btn-modern primary" onclick="sendFriendRequest(\'' + id + '\')"><i class="fas fa-user-plus"></i> Add Friend</button>';
            }
            
                  return `
                <div class="friend-card-modern ${isOnline ? 'online' : ''}">
                    <div class="friend-card-header">
                        <div class="friend-avatar-modern" style="${avatarStyle} display:flex; align-items:center; justify-content:center; font-size:36px;">
                              ${avatarContent}
                            <div class="friend-status-dot ${isOnline ? 'online' : ''}"></div>
                          </div>
                        <div class="friend-info-modern">
                            <div class="friend-name-modern">${profile.username || 'User'}</div>
                            <div class="friend-status-text">
                                ${isOnline ? '<span style="color:#28a745;">🟢 Online</span>' : '<span style="color:#6c757d;">⚫ Offline</span>'}
                              </div>
                            ${status ? `<div class="friend-status-message">"${status}"</div>` : ''}
                          </div>
                    </div>
                    <div class="friend-actions-modern">
                        ${actionButton}
                        <button class="friend-action-btn-modern secondary" onclick="viewFriendProfile('${id}')">
                            <i class="fas fa-user"></i> View
                        </button>
                    </div>
                      </div>
                  `;
        });
    
    if (matches.length === 0) {
        searchResults.innerHTML = '<div class="friends-empty-state"><i class="fas fa-search"></i><h3>No Users Found</h3><p>Try a different search term</p></div>';
    } else {
        searchResults.innerHTML = matches.join('');
    }
  }
  
  // Filter and sort handlers
  const filterFriendsInput = document.getElementById('filterFriendsInput');
  filterFriendsInput?.addEventListener('input', Utils.debounce(() => {
    renderFriendsTab();
  }, 300));
  
  const friendsSortSelect = document.getElementById('friendsSortSelect');
  friendsSortSelect?.addEventListener('change', () => {
    renderFriendsTab();
  });
  
  // Update all displays
  function updateAllDisplays() {
    updateCountBadges();
    if (document.querySelector('.friends-tab-btn.active')) {
        const activeTab = document.querySelector('.friends-tab-btn.active').dataset.tab;
        switch(activeTab) {
            case 'friends':
                renderFriendsTab();
                break;
            case 'requests':
                renderRequestsTab();
                break;
            case 'blocked':
                renderBlockedTab();
                break;
        }
    }
  }
  
  // Modal open/close
  closeFriendsBtn?.addEventListener('click', () => {
    friendsModal.style.display = 'none';
  });
  
  friendsModal?.addEventListener('click', (e) => {
    if (e.target === friendsModal) {
        friendsModal.style.display = 'none';
    }
  });
  
  friendsBtn?.addEventListener('click', () => {
      if (!requireProfileForOnlineFeature('Friends', () => {
          if (!friendsModal) {
              console.error('Friends modal not found');
              return;
          }
          friendsModal.style.display = 'block';
          friendsModal.style.visibility = 'visible';
          friendsModal.style.opacity = '1';
          loadFriendsFromFirebase();
          renderFriendsTab();
      })) {
          return;
      }
    if (!friendsModal) {
        console.error('Friends modal not found');
        return;
    }
    
    friendsModal.style.display = 'block';
    friendsModal.style.visibility = 'visible';
    friendsModal.style.opacity = '1';
    
    // Load fresh data
    // Don't load all profiles here - profiles are loaded on-demand in loadFriendsFromFirebase
    if (db) {
        db.ref('online').once('value').then(onlineSnap => {
            onlineCache = onlineSnap.val() || {};
        }).catch(err => {
            console.error('Error loading online data:', err);
        });
    }
    
    // Activate friends tab by default
    setTimeout(() => {
        const friendsTab = document.querySelector('.friends-tab-btn[data-tab="friends"]');
        if (friendsTab) {
            friendsTab.click();
        } else {
            // Fallback: manually activate
            renderFriendsTab();
        }
    }, 100);
  });
  
  onFirebaseReady(() => {
    initFriendsSystem();
    loadAllProfiles();
  });
  
  if (!db) {
    updateAllDisplays();
    initNotificationSystem();
  }
  
  // Ensure friends modal is accessible and background effects are running
  document.addEventListener('DOMContentLoaded', () => {
    // Verify friends modal exists
    const modal = document.getElementById('friendsModal');
    if (!modal) {
        console.warn('Friends modal not found in DOM');
    }
    
    // Ensure background effects are initialized
    setTimeout(() => {
        const starCanvas = document.getElementById('starCanvas');
        const interactiveBg = document.getElementById('interactiveBackground');
        const sparkleCanvas = document.getElementById('sparkleCanvas');
        
        if (!starCanvas) {
            console.warn('starCanvas not found - stars may not work');
        } else {
            // Re-initialize if not working
            try {
                initStars();
            } catch(e) {
                console.error('Error initializing stars:', e);
            }
        }
        
        if (!interactiveBg) {
            console.warn('interactiveBackground not found - interactive effects may not work');
        } else {
            // Re-initialize if not working
            try {
                initInteractiveBackground();
            } catch(e) {
                console.error('Error initializing interactive background:', e);
            }
        }
        
        if (!sparkleCanvas) {
            // Sparkle canvas is in popup, may not exist yet - that's ok
        }
    }, 500);
  });
  
  
  // ---------------- Polls/Voting ----------------
  const pollsBtn = document.getElementById('pollsBtn');
  const sidePanelPollsBtn = document.getElementById('sidePanelPollsBtn');
  const pollsModal = document.getElementById('pollsModal');
  const pollsList = document.getElementById('pollsList');
  const createPollBtn = document.getElementById('createPollBtn');
  const createPollForm = document.getElementById('createPollForm');
  const pollQuestion = document.getElementById('pollQuestion');
  const pollOptions = document.getElementById('pollOptions');
  const addPollOptionBtn = document.getElementById('addPollOptionBtn');
  const submitPollBtn = document.getElementById('submitPollBtn');
  const cancelPollBtn = document.getElementById('cancelPollBtn');
  const closePollsBtn = document.getElementById('closePollsBtn');
  
  pollsBtn?.addEventListener('click', () => {
      pollsModal.style.display = 'flex';
      loadPolls();
  });
  sidePanelPollsBtn?.addEventListener('click', (e) => {
      e.preventDefault();
      pollsBtn?.click();
  });
  
  // Contact button
  const contactBtn = document.getElementById('contactBtn');
  contactBtn?.addEventListener('click', () => {
      window.location.href = 'pages/contact-us.html';
  });
  
  closePollsBtn?.addEventListener('click', () => {
      pollsModal.style.display = 'none';
  });
  
  pollsModal?.addEventListener('click', (e) => {
      if(e.target === pollsModal) pollsModal.style.display = 'none';
  });
  
  createPollBtn?.addEventListener('click', () => {
      createPollForm.style.display = createPollForm.style.display === 'none' ? 'block' : 'none';
  });
  
  addPollOptionBtn?.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'pollOption';
      input.placeholder = `Option ${pollOptions.children.length + 1}`;
      input.style.cssText = 'width:100%; padding:8px; border-radius:6px; border:1px solid rgba(255,215,0,0.2); background:rgba(255,255,255,0.05); color:rgba(255,255,255,0.9); margin-bottom:8px;';
      pollOptions.appendChild(input);
  });
  
  cancelPollBtn?.addEventListener('click', () => {
      createPollForm.style.display = 'none';
      pollQuestion.value = '';
      pollOptions.innerHTML = `
          <input type="text" class="pollOption" placeholder="Option 1" style="width:100%; padding:8px; border-radius:6px; border:1px solid rgba(255,215,0,0.2); background:rgba(255,255,255,0.05); color:rgba(255,255,255,0.9); margin-bottom:8px;">
          <input type="text" class="pollOption" placeholder="Option 2" style="width:100%; padding:8px; border-radius:6px; border:1px solid rgba(255,215,0,0.2); background:rgba(255,255,255,0.05); color:rgba(255,255,255,0.9); margin-bottom:8px;">
      `;
  });
  
  submitPollBtn?.addEventListener('click', () => {
      const question = pollQuestion.value.trim();
      const options = Array.from(pollOptions.querySelectorAll('.pollOption')).map(inp => inp.value.trim()).filter(v => v);
      if(question && options.length >= 2) {
          if(db) {
              const poll = {
                  question,
                  // Store vote counts in summary, not individual voters (reduces downloads)
                  options: options.map(opt => ({ text: opt, votes: 0 })),
                  summary: {
                      totalVotes: 0,
                      optionVotes: options.map(() => 0)
                  },
                  createdBy: username,
                  createdAt: Date.now()
              };
              db.ref('polls').push(poll);
              cancelPollBtn.click();
              loadPolls();
          }
      }
  });
  
  function loadPolls() {
      if(!db || !pollsList) {
          if(pollsList) pollsList.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Loading polls...</p>';
          return;
      }
      pollsList.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">Loading polls...</p>';
      db.ref('polls').limitToLast(10).once('value').then(snap => {
          const polls = snap.val() || {};
          if(Object.keys(polls).length === 0) {
              pollsList.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5);">No polls yet. Create one to get started!</p>';
              return;
          }
          // Check which polls user has voted on (only fetch user's votes, not all voters)
          const userVotesPromises = Object.keys(polls).map(pollId => 
              db.ref(`polls/${pollId}/userVotes/${visitorId}`).once('value').then(snap => ({ pollId, votedOption: snap.val() }))
          );
          
          Promise.all(userVotesPromises).then(userVotes => {
              const userVoteMap = {};
              userVotes.forEach(({ pollId, votedOption }) => {
                  if(votedOption !== null) userVoteMap[pollId] = votedOption;
              });
              
              pollsList.innerHTML = Object.entries(polls).reverse().map(([id, poll]) => {
                  if(!poll || !poll.options) return '';
                  // Use summary if available, otherwise calculate from options (backward compatibility)
                  const totalVotes = poll.summary?.totalVotes || poll.options.reduce((sum, opt) => sum + (opt.votes || 0), 0);
                  const isOwner = poll.createdBy === username;
                  const userVotedOption = userVoteMap[id];
                  
                  return `
                      <div style="padding:20px; background:rgba(255,255,255,0.05); border-radius:12px; margin-bottom:15px; position:relative;">
                          <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:15px;">
                              <div style="font-weight:600; color:#FFD700; flex:1;">${poll.question || 'Untitled Poll'}</div>
                              ${isOwner ? `<button class="deletePollBtn" data-poll-id="${id}" style="padding:6px 12px; background:#dc3545; border:1px solid #dc3545; border-radius:6px; color:#ffffff; cursor:pointer; font-size:12px; font-weight:600; margin-left:10px; transition:all 0.3s ease;" title="Delete this poll"><i class="fas fa-trash"></i></button>` : ''}
                          </div>
                          ${poll.options.map((opt, i) => {
                              if(!opt) return '';
                              const voteCount = opt.votes || 0;
                              const percent = totalVotes > 0 ? voteCount / totalVotes * 100 : 0;
                              const hasVoted = userVotedOption === i;
                              return `
                                  <div style="margin-bottom:10px;">
                                      <button class="voteBtn" data-poll="${id}" data-option="${i}" style="width:100%; padding:10px; text-align:left; background:rgba(255,255,255,0.05); border:1px solid rgba(255,215,0,0.2); border-radius:6px; color:rgba(255,255,255,0.9); cursor:pointer; margin-bottom:5px; ${hasVoted ? 'opacity:0.7;' : ''}">
                                          ${opt.text || 'Option ' + (i + 1)} ${hasVoted ? '✓' : ''}
                                      </button>
                                      <div style="width:100%; height:6px; background:rgba(255,255,255,0.1); border-radius:3px; overflow:hidden;">
                                          <div style="height:100%; background:#FFD700; width:${percent}%; transition:width 0.3s;"></div>
                                      </div>
                                      <div style="font-size:12px; color:rgba(255,255,255,0.6); margin-top:4px;">${voteCount} votes (${percent.toFixed(1)}%)</div>
                                  </div>
                              `;
                          }).join('')}
                          <div style="font-size:11px; color:rgba(255,255,255,0.5); margin-top:10px;">By ${poll.createdBy || 'Unknown'} • ${new Date(poll.createdAt || Date.now()).toLocaleString()}</div>
                      </div>
                  `;
              }).join('');
              
              // Re-attach event listeners after rendering
              attachPollVoteHandlers();
          }).catch(err => {
              console.error('Error loading user votes:', err);
              // Fallback: render polls without user vote info
              renderPollsFallback(polls);
          });
          
          function attachPollVoteHandlers() {
              // Re-attach event listeners - optimized to use vote summary instead of individual voters
              document.querySelectorAll('.voteBtn').forEach(btn => {
                  btn.addEventListener('click', () => {
                      const pollId = btn.dataset.poll;
                      const optionIndex = parseInt(btn.dataset.option);
                      if(db && pollId && !isNaN(optionIndex)) {
                          // Check if user already voted (check in separate path to avoid loading all voters)
                          const userVoteRef = db.ref(`polls/${pollId}/userVotes/${visitorId}`);
                          userVoteRef.once('value').then(snap => {
                              if(snap.exists()) {
                                  notifications.show('You have already voted on this poll!', 'info', 2000);
                                  return;
                              }
                              
                              // Mark user as voted
                              userVoteRef.set(optionIndex).then(() => {
                                  // Update vote count in summary (don't store individual voters)
                                  const optionRef = db.ref(`polls/${pollId}/options/${optionIndex}`);
                                  const summaryRef = db.ref(`polls/${pollId}/summary`);
                                  
                                  optionRef.transaction(opt => {
                                      if(!opt) return opt;
                                      opt.votes = (opt.votes || 0) + 1;
                                      return opt;
                                  });
                                  
                                  summaryRef.transaction(summary => {
                                      if(!summary) summary = { totalVotes: 0, optionVotes: [] };
                                      summary.totalVotes = (summary.totalVotes || 0) + 1;
                                      if(!summary.optionVotes) summary.optionVotes = [];
                                      summary.optionVotes[optionIndex] = (summary.optionVotes[optionIndex] || 0) + 1;
                                      return summary;
                                  }).then(() => {
                                      loadPolls(); // Reload to show updated votes
                                  });
                              });
                          });
                      }
                  });
              });
              
              // Add delete poll button handlers
              document.querySelectorAll('.deletePollBtn').forEach(btn => {
                  btn.addEventListener('click', (e) => {
                      e.stopPropagation();
                      const pollId = btn.dataset.pollId;
                      if(pollId && confirm('Are you sure you want to delete this poll? This action cannot be undone.')) {
                          if(db) {
                              db.ref(`polls/${pollId}`).remove().then(() => {
                                  notifications.show('Poll deleted successfully!', 'success', 2000);
                                  loadPolls();
                              }).catch(err => {
                                  console.error('Error deleting poll:', err);
                                  notifications.show('Error deleting poll. Please try again.', 'error', 2000);
                              });
                          }
                      }
                  });
              });
          }
          
          function renderPollsFallback(polls) {
              // Fallback rendering without user vote info (for backward compatibility)
              pollsList.innerHTML = Object.entries(polls).reverse().map(([id, poll]) => {
                  if(!poll || !poll.options) return '';
                  const totalVotes = poll.summary?.totalVotes || poll.options.reduce((sum, opt) => sum + (opt.votes || 0), 0);
                  const isOwner = poll.createdBy === username;
                  return `
                      <div style="padding:20px; background:rgba(255,255,255,0.05); border-radius:12px; margin-bottom:15px; position:relative;">
                          <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:15px;">
                              <div style="font-weight:600; color:#FFD700; flex:1;">${poll.question || 'Untitled Poll'}</div>
                              ${isOwner ? `<button class="deletePollBtn" data-poll-id="${id}" style="padding:6px 12px; background:#dc3545; border:1px solid #dc3545; border-radius:6px; color:#ffffff; cursor:pointer; font-size:12px; font-weight:600; margin-left:10px; transition:all 0.3s ease;" title="Delete this poll"><i class="fas fa-trash"></i></button>` : ''}
                          </div>
                          ${poll.options.map((opt, i) => {
                              if(!opt) return '';
                              const voteCount = opt.votes || 0;
                              const percent = totalVotes > 0 ? voteCount / totalVotes * 100 : 0;
                              return `
                                  <div style="margin-bottom:10px;">
                                      <button class="voteBtn" data-poll="${id}" data-option="${i}" style="width:100%; padding:10px; text-align:left; background:rgba(255,255,255,0.05); border:1px solid rgba(255,215,0,0.2); border-radius:6px; color:rgba(255,255,255,0.9); cursor:pointer; margin-bottom:5px;">
                                          ${opt.text || 'Option ' + (i + 1)}
                                      </button>
                                      <div style="width:100%; height:6px; background:rgba(255,255,255,0.1); border-radius:3px; overflow:hidden;">
                                          <div style="height:100%; background:#FFD700; width:${percent}%; transition:width 0.3s;"></div>
                                      </div>
                                      <div style="font-size:12px; color:rgba(255,255,255,0.6); margin-top:4px;">${voteCount} votes (${percent.toFixed(1)}%)</div>
                                  </div>
                              `;
                          }).join('')}
                          <div style="font-size:11px; color:rgba(255,255,255,0.5); margin-top:10px;">By ${poll.createdBy || 'Unknown'} • ${new Date(poll.createdAt || Date.now()).toLocaleString()}</div>
                      </div>
                  `;
              }).join('');
              attachPollVoteHandlers();
          }
      }).catch(err => {
          console.error('Error loading polls:', err);
          if(pollsList) pollsList.innerHTML = '<p style="text-align:center; color:rgba(255,0,0,0.7);">Error loading polls. Please try again.</p>';
      });
  }
  
  // ---------------- Emoji Reactions ----------------
  const emojiBtn = document.getElementById('emojiBtn');
  const emojiPicker = document.getElementById('emojiPicker');
  const emojiOptions = document.querySelectorAll('.emoji-option');
  const fullscreenEmojiPicker = document.getElementById('fullscreenEmojiPicker');

  const emojiSet = ("😀 😃 😄 😁 😆 😅 😂 🤣 😊 😇 🙂 🙃 😉 😌 😍 🥰 😘 😗 😙 😚 😋 😛 😜 🤪 😝 🤑 🤗 🤭 🤫 🤔 🤐 🤨 😐 😑 😶 😏 😒 🙄 😬 🤥 😌 😔 😪 🤤 😴 😷 🤒 🤕 🤢 🤮 🤧 🥵 🥶 🥴 😵 🤯 🤠 🥳 😎 🤓 🧐 😕 😟 🙁 ☹️ 😮 😯 😲 😳 🥺 😦 😧 😨 😰 😥 😢 🤤 😭 😱 😖 😣 😞 😓 😩 😫 🥱 😤 😡 😠 🤬 😈 👿 💀 ☠️ 💩 🤡 👹 👺 👻 👽 👾 🤖 😺 😸 😹 😻 😼 😽 🙀 😿 😾 🤲 👐 🙌 👏 🤝 👍 👎 👊 ✊ 🤛 🤜 🤞 ✌️ 🤟 🤘 👌 🤌 🤏 👈 👉 👆 👇 ☝️ ✋ 🖐 🖖 🤙 🤚 👋 🤟 💪 🦵 🦶 👂 👃 🧠 🫀 🫁 🦷 🦴 👀 👁 👅 👄 💋 🩸 🧠").split(' ');

  function populateEmojiPicker(target) {
      if (!target) return;
      target.innerHTML = '';
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(32px, 1fr))';
      grid.style.gap = '6px';
      emojiSet.forEach(e => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = e;
          btn.style.cssText = 'border:none; background:transparent; font-size:20px; cursor:pointer; padding:6px; border-radius:8px;';
          btn.addEventListener('click', () => handleEmojiClick(e));
          btn.addEventListener('mouseenter', () => btn.style.background = 'rgba(255,215,0,0.2)');
          btn.addEventListener('mouseleave', () => btn.style.background = 'transparent');
          grid.appendChild(btn);
      });
      target.appendChild(grid);
  }
  
  // Ensure emoji picker is hidden by default
  if (emojiPicker) {
      emojiPicker.style.display = 'none';
      populateEmojiPicker(emojiPicker);
  }
  if (fullscreenEmojiPicker) {
      fullscreenEmojiPicker.style.display = 'none';
      populateEmojiPicker(fullscreenEmojiPicker);
  }
  
  emojiBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
    if (emojiPicker) {
      emojiPicker.style.display = emojiPicker.style.display === 'none' ? 'block' : 'none';
    }
  });
  
  document.addEventListener('click', (e) => {
    if (emojiPicker && !emojiPicker.contains(e.target) && e.target !== emojiBtn) {
          emojiPicker.style.display = 'none';
      }
  });
  
  // Emoji selection handler (works for both regular and fullscreen)
  function handleEmojiClick(emojiChar) {
    const regularInput = document.getElementById('chatInput');
    const fullscreenInput = document.getElementById('fullscreenChatInput');
    
    // Determine which input is active
    const activeInput = document.activeElement === fullscreenInput ? fullscreenInput : regularInput;
    
    if (activeInput) {
        activeInput.value += emojiChar;
        activeInput.focus();
    } else if (regularInput) {
        regularInput.value += emojiChar;
        regularInput.focus();
    }
    
    // Hide both emoji pickers
    const regularPicker = document.getElementById('emojiPicker');
    const fullscreenPicker = document.getElementById('fullscreenEmojiPicker');
    if (regularPicker) regularPicker.style.display = 'none';
    if (fullscreenPicker) fullscreenPicker.style.display = 'none';
  }
  
  emojiOptions.forEach(emoji => {
    emoji.addEventListener('click', () => handleEmojiClick(emoji.textContent));
      emoji.addEventListener('mouseenter', () => {
          emoji.style.background = 'rgba(255,215,0,0.2)';
      });
      emoji.addEventListener('mouseleave', () => {
          emoji.style.background = 'transparent';
      });
  });
  
  // Fullscreen emoji button
  fullscreenEmojiBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    const fullscreenPicker = document.getElementById('fullscreenEmojiPicker') || emojiPicker;
    if (fullscreenPicker) {
        fullscreenPicker.style.display = fullscreenPicker.style.display === 'none' ? 'block' : 'none';
    }
  });
  
  // ---------------- Attach Link (works for both regular and fullscreen) ----------------
  function attachLink() {
      if (chatAttachmentInput) {
          chatAttachmentInput.value = '';
          chatAttachmentInput.click();
          return;
      }
      promptAndSendLink();
  }

  async function sendPreparedChatMessage(messageText) {
      const targetInput = fullscreenChatInput || chatInput;
      if (targetInput) {
          const previousValue = targetInput.value;
          targetInput.value = messageText;
          try {
              await sendChatMessage(targetInput);
          } finally {
              if (targetInput.value !== '') {
                  targetInput.value = previousValue;
              }
          }
      } else if (typeof backendApi !== 'undefined' && backendApi) {
          backendApi.sendChatMessage({
              user: username,
              text: messageText,
              color: userColor,
              time: Date.now(),
              uid: visitorId,
              avatar: userProfile.avatar || '👤',
              avatarImage: userProfile.avatarImage || null
          });
      }
  }

  function promptAndSendLink() {
      const url = prompt('Enter a URL to share:');
      if(url && url.trim()) {
          let linkUrl = url.trim();
          if(!linkUrl.match(/^https?:\/\//i)) {
              linkUrl = 'http://' + linkUrl;
          }
          try {
              new URL(linkUrl);
              sendPreparedChatMessage(`🔗 Shared a link: ${linkUrl}`);
              if (typeof notifications !== 'undefined' && notifications.show) {
                  notifications.show('Link shared!', 'success', 2000);
              }
          } catch(e) {
              if (typeof notifications !== 'undefined' && notifications.show) {
                  notifications.show('Invalid URL. Please enter a valid web address.', 'error', 3000);
              } else {
                  alert('Invalid URL. Please enter a valid web address.');
              }
          }
      }
  }

  chatAttachmentInput?.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) {
          promptAndSendLink();
          return;
      }
      try {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          await new Promise((resolve, reject) => {
              reader.onload = () => resolve();
              reader.onerror = reject;
          });
          const dataUrl = reader.result;
          let uploadedUrl = null;
          if (typeof backendApi !== 'undefined' && backendApi) {
              const uploadResp = await backendApi.uploadAttachment(file.name, dataUrl);
              uploadedUrl = uploadResp?.url || uploadResp?.path;
          }
          const linkToSend = uploadedUrl || dataUrl;
          await sendPreparedChatMessage(`📎 Attachment (${file.name}): ${linkToSend}`);
          if (typeof notifications !== 'undefined' && notifications.show) {
              notifications.show('Attachment shared as a link', 'success', 2000);
          }
      } catch (err) {
          console.error('Attachment upload failed', err);
          if (typeof notifications !== 'undefined' && notifications.show) {
              notifications.show('Upload failed. Please try again.', 'error', 2500);
          }
      }
  });

  attachLinkBtn?.addEventListener('click', attachLink);
  fullscreenLinkBtn?.addEventListener('click', attachLink);
  
  // Initialize profile on load
  if(document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
          if(db && userProfile.profileCreated) {
              const profileData = {
                  avatar: userProfile.avatar,
                  avatarImage: userProfile.avatarImage,
                  status: userProfile.status,
                  username: userProfile.username || username,
                  lastSeen: Date.now()
              };
              db.ref('profiles/' + visitorId).update(profileData);
          }
      });
  } else {
      if(db && userProfile.profileCreated) {
          const profileData = {
              avatar: userProfile.avatar,
              avatarImage: userProfile.avatarImage,
              status: userProfile.status,
              username: userProfile.username || username,
              lastSeen: Date.now()
          };
          db.ref('profiles/' + visitorId).update(profileData);
      }
  }
  
  // ================= PROFESSIONAL ENHANCEMENTS =================
  
  // Professional Notification System
  class NotificationSystem {
    constructor() {
        this.container = null;
        this.init();
    }
  
    init() {
        this.container = document.createElement('div');
        this.container.id = 'notificationContainer';
        this.container.style.cssText = 'position:fixed; top:20px; right:20px; z-index:100000; display:flex; flex-direction:column; gap:12px; pointer-events:none;';
        document.body.appendChild(this.container);
    }
  
    show(message, type = 'info', duration = 5000) {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        // Responsive sizing for notifications
        const isSmallDevice = window.innerWidth <= 1024;
        const isMobile = window.innerWidth <= 768;
        const padding = isMobile ? '10px 14px' : isSmallDevice ? '12px 18px' : '16px 24px';
        const maxWidth = isMobile ? 'calc(100vw - 20px)' : isSmallDevice ? '320px' : '400px';
        const fontSize = isMobile ? '12px' : isSmallDevice ? '14px' : 'inherit';
        const iconSize = isMobile ? '16px' : isSmallDevice ? '18px' : '20px';
        
        notification.style.cssText = `
            padding: ${padding};
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            color: white;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            max-width: ${maxWidth};
            pointer-events: all;
            animation: slideInDown 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: ${isMobile ? '8px' : '12px'};
            font-size: ${fontSize};
        `;
  
        const icons = {
            success: '✓',
            error: '✕',
            info: 'ℹ',
            warning: '⚠'
        };
  
        const colors = {
            success: 'rgba(40, 167, 69, 0.3)',
            error: 'rgba(220, 53, 69, 0.3)',
            info: 'rgba(0, 123, 255, 0.3)',
            warning: 'rgba(255, 193, 7, 0.3)'
        };
  
        notification.style.borderColor = colors[type] || colors.info;
        const closeBtnSize = isMobile ? '20px' : isSmallDevice ? '22px' : '24px';
        const closeBtnFontSize = isMobile ? '16px' : isSmallDevice ? '17px' : '18px';
        
        notification.innerHTML = `
            <span style="font-size: ${iconSize}; font-weight: bold; flex-shrink: 0;">${icons[type] || icons.info}</span>
            <span style="flex: 1; word-wrap: break-word; overflow-wrap: break-word;">${message}</span>
            <button class="notification-close" style="background:none; border:none; color:rgba(255,255,255,0.7); cursor:pointer; font-size:${closeBtnFontSize}; padding:0; width:${closeBtnSize}; height:${closeBtnSize}; display:flex; align-items:center; justify-content:center; flex-shrink: 0;">&times;</button>
        `;
  
        this.container.appendChild(notification);
  
        const closeBtn = notification.querySelector('.notification-close');
        const close = () => {
            notification.style.animation = 'fadeOutScale 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        };
  
        closeBtn.addEventListener('click', close);
        setTimeout(close, duration);
  
        return notification;
    }
  }
  
  const notifications = new NotificationSystem();
  
  // Professional Animation Utilities
  const Animations = {
    fadeIn: (element, duration = 300) => {
        element.style.opacity = '0';
        element.style.transition = `opacity ${duration}ms ease`;
        requestAnimationFrame(() => {
            element.style.opacity = '1';
        });
    },
  
    fadeOut: (element, duration = 300) => {
        element.style.transition = `opacity ${duration}ms ease`;
        element.style.opacity = '0';
        return new Promise(resolve => setTimeout(resolve, duration));
    },
  
    slideIn: (element, direction = 'up', duration = 300) => {
        const transforms = {
            up: 'translateY(30px)',
            down: 'translateY(-30px)',
            left: 'translateX(30px)',
            right: 'translateX(-30px)'
        };
        element.style.transform = transforms[direction] || transforms.up;
        element.style.opacity = '0';
        element.style.transition = `all ${duration}ms ease`;
        requestAnimationFrame(() => {
            element.style.transform = 'translate(0, 0)';
            element.style.opacity = '1';
        });
    },
  
    scale: (element, from = 0.9, to = 1, duration = 300) => {
        element.style.transform = `scale(${from})`;
        element.style.opacity = '0';
        element.style.transition = `all ${duration}ms ease`;
        requestAnimationFrame(() => {
            element.style.transform = `scale(${to})`;
            element.style.opacity = '1';
        });
    }
  };
  
  // Professional Loading State Manager
  class LoadingManager {
    constructor() {
        this.loaders = new Map();
    }
  
    show(element, text = 'Loading...') {
        const loaderId = `loader_${Date.now()}_${Math.random()}`;
        const loader = document.createElement('div');
        loader.className = 'loading-overlay';
        loader.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            border-radius: inherit;
        `;
        loader.innerHTML = `
            <div style="text-align: center;">
                <div class="spinner" style="margin: 0 auto 16px;"></div>
                <div style="color: white; font-size: 14px;">${text}</div>
            </div>
        `;
        
        const parent = element.parentElement || document.body;
        parent.style.position = 'relative';
        parent.appendChild(loader);
        this.loaders.set(loaderId, loader);
        return loaderId;
    }
  
    hide(loaderId) {
        const loader = this.loaders.get(loaderId);
        if (loader) {
            Animations.fadeOut(loader).then(() => loader.remove());
            this.loaders.delete(loaderId);
        }
    }
  }
  
  const loadingManager = new LoadingManager();
  
  // Professional Form Validation
  class FormValidator {
    static validateEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
  
    static validateURL(url) {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    }
  
    static validateRequired(value) {
        return value && value.trim().length > 0;
    }
  
    static validateLength(value, min, max) {
        const len = value ? value.length : 0;
        return len >= min && len <= max;
    }
  
    static showError(input, message) {
        input.style.borderColor = 'rgba(220, 53, 69, 0.5)';
        const errorDiv = document.createElement('div');
        errorDiv.className = 'form-error';
        errorDiv.style.cssText = 'color: #dc3545; font-size: 12px; margin-top: 4px;';
        errorDiv.textContent = message;
        input.parentElement.appendChild(errorDiv);
        setTimeout(() => {
            input.style.borderColor = '';
            errorDiv.remove();
        }, 5000);
    }
  }
  
  // Utils is already defined earlier in the file - adding additional methods here
  Utils.formatDate = (timestamp) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
  
    if (seconds < 60) return 'just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    return date.toLocaleDateString();
  };
  
  Utils.formatNumber = (num) => {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
  };
  
  Utils.copyToClipboard = async (text) => {
    try {
        await navigator.clipboard.writeText(text);
        if (typeof notifications !== 'undefined' && notifications.show) {
            notifications.show('Copied to clipboard!', 'success', 2000);
        }
        return true;
    } catch (err) {
        console.error('Failed to copy:', err);
        if (typeof notifications !== 'undefined' && notifications.show) {
            notifications.show('Failed to copy', 'error');
        }
        return false;
    }
  };
  
  // Professional Error Handler (only show notifications for critical errors)
  window.addEventListener('error', (event) => {
    // Prevent default error handling for filtered errors
    event.preventDefault();
    
    // Ignore errors from extensions, scripts from other origins, AdSense, or expected errors
    if (event.filename && (
        event.filename.includes('chrome-extension://') ||
        event.filename.includes('moz-extension://') ||
        event.filename.includes('safari-extension://') ||
        event.filename.includes('googlesyndication.com') ||
        event.filename.includes('doubleclick.net') ||
        event.filename.includes('googleads.g.doubleclick.net') ||
        event.filename.includes('<anonymous>') // Firebase/AdSense anonymous scripts
    )) {
        return; // Ignore these common non-critical errors
    }
    
    if (event.message && (
        event.message.includes('Script error') ||
        event.message.includes('Non-Error promise rejection') ||
        event.message.includes('ResizeObserver loop') ||
        event.message.includes('Failed to fetch') ||
        event.message.includes('TypeError: Failed to fetch') ||
        event.message.includes('ERR_BLOCKED_BY_CLIENT') ||
        event.message.includes('NetworkError')
    )) {
        return; // Ignore these common non-critical errors
    }
    
    // Ignore AdSense-related errors by URL
    if (event.target && event.target.src && (
        event.target.src.includes('googlesyndication.com') ||
        event.target.src.includes('doubleclick.net') ||
        event.target.src.includes('googleads.g.doubleclick.net')
    )) {
        return; // Ignore AdSense resource loading errors
    }
    
    // Only show notification for actual JavaScript errors
    if (event.error && event.error instanceof Error) {
        console.error('Global error:', event.error);
        // Don't show notification for every error - only log it
        // Uncomment the line below if you want to see error notifications
        // notifications.show('An error occurred. Please check the console.', 'error');
    }
  });
  
  window.addEventListener('unhandledrejection', (event) => {
    // Prevent default error handling for filtered errors
    event.preventDefault();
    
    const reason = event.reason;
    const reasonStr = reason?.toString() || '';
    const reasonMsg = reason?.message || '';
    
    // Ignore AdSense-related promise rejections
    if (reasonStr.includes('googlesyndication.com') ||
        reasonStr.includes('doubleclick.net') ||
        reasonStr.includes('googleads.g.doubleclick.net') ||
        reasonStr.includes('ERR_BLOCKED_BY_CLIENT') ||
        reasonStr.includes('Failed to fetch') ||
        reasonStr.includes('TypeError: Failed to fetch') ||
        reasonMsg.includes('googlesyndication.com') ||
        reasonMsg.includes('doubleclick.net') ||
        reasonMsg.includes('ERR_BLOCKED_BY_CLIENT') ||
        reasonMsg.includes('Failed to fetch') ||
        reasonMsg.includes('TypeError: Failed to fetch')) {
        return; // Ignore AdSense-related promise rejections
    }
    
    // Ignore common promise rejections that are expected
    if (reasonStr.includes('aborted') ||
        reasonStr.includes('cancelled') ||
        reasonStr.includes('user') ||
        reasonMsg.includes('aborted') ||
        reasonMsg.includes('cancelled')) {
        return; // Ignore expected rejections
    }
    
    // Only log actual errors (not filtered ones)
    if (reason && !reasonStr.includes('Failed to fetch')) {
        console.error('Unhandled promise rejection:', event.reason);
    }
    // Don't show notification for every rejection - only log it
  });
  
  // Suppress AdSense-related console errors (they're expected and harmless)
  const originalConsoleError = console.error;
  const originalConsoleWarn = console.warn;
  console.error = function(...args) {
    const message = args.join(' ');
    // Filter out AdSense-related errors and common non-critical errors
    if (message.includes('googlesyndication.com') ||
        message.includes('doubleclick.net') ||
        message.includes('googleads.g.doubleclick.net') ||
        message.includes('googleads') ||
        message.includes('ERR_BLOCKED_BY_CLIENT') ||
        message.includes('Failed to load resource') ||
        message.includes('Failed to fetch') ||
        message.includes('NetworkError') ||
        message.includes('TypeError: Failed to fetch') ||
        (message.includes('403') && (message.includes('ads') || message.includes('doubleclick') || message.includes('googleads'))) ||
        (message.includes('ads') && message.includes('fetch'))) {
        return; // Suppress these errors
    }
    originalConsoleError.apply(console, args);
  };
  
  // Suppress CSP violation warnings (they're just warnings and harmless)
  console.warn = function(...args) {
    const message = args.join(' ');
    // Filter out CSP violations and other non-critical warnings
    if (message.includes('Content Security Policy') ||
        message.includes('CSP') ||
        message.includes('frame-ancestors') ||
        message.includes('violates') ||
        message.includes('report-only') ||
        message.includes('Failed to fetch') ||
        message.includes('Failed to load resource') ||
        message.includes('googlesyndication.com') ||
        message.includes('doubleclick.net') ||
        message.includes('googleads') ||
        (message.includes('403') && (message.includes('ads') || message.includes('doubleclick') || message.includes('googleads')))) {
        return; // Suppress these warnings
    }
    originalConsoleWarn.apply(console, args);
  };
  
  // Note: AdSense errors in the Network tab are normal and expected
  // They occur when ad blockers block ad requests or when the site isn't fully approved yet
  
  // Prevent text/element selection via double-click and drag
  document.addEventListener('selectstart', (e) => {
    // Allow selection in input fields and textareas
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
        return;
    }
    e.preventDefault();
    return false;
  });
  
  document.addEventListener('dragstart', (e) => {
    // Allow dragging of images and links if needed
    if (e.target.tagName === 'IMG' || e.target.tagName === 'A') {
        return;
    }
    e.preventDefault();
    return false;
  });
  
  // Prevent double-click selection
  document.addEventListener('mousedown', (e) => {
    if (e.detail > 1) { // Double-click
        e.preventDefault();
        return false;
    }
  });
  
  // Note: Context menu is already handled by the custom context menu code above
  // The custom context menu will still work, but selection is disabled
  
  // Professional Performance Monitor
  class PerformanceMonitor {
    constructor() {
        this.metrics = {
            pageLoad: 0,
            renderTime: 0,
            interactions: []
        };
        this.init();
    }
  
    init() {
        if (window.performance && window.performance.timing) {
            window.addEventListener('load', () => {
                const timing = window.performance.timing;
                this.metrics.pageLoad = timing.loadEventEnd - timing.navigationStart;
                this.metrics.renderTime = timing.domComplete - timing.domLoading;
                console.log('Performance metrics:', this.metrics);
            });
        }
    }
  
    measure(name, fn) {
        const start = performance.now();
        const result = fn();
        const end = performance.now();
        this.metrics.interactions.push({ name, duration: end - start });
        return result;
    }
  }
  
  const perfMonitor = new PerformanceMonitor();
  
  // Professional Keyboard Navigation
  class KeyboardNavigation {
    constructor() {
        this.init();
    }
  
    init() {
        document.addEventListener('keydown', (e) => {
            // Escape to close modals
            if (e.key === 'Escape') {
                const modals = document.querySelectorAll('[id$="Modal"]');
                modals.forEach(modal => {
                    if (modal.style.display !== 'none') {
                        modal.style.display = 'none';
                    }
                });
            }
  
            // Ctrl/Cmd + K for search (if search exists)
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                const searchInput = document.getElementById('searchFriendsInput');
                if (searchInput) {
                    searchInput.focus();
                }
            }
        });
    }
  }
  
  new KeyboardNavigation();
  
  // Professional Smooth Scroll Enhancement
  const smoothScrollTo = (element, offset = 0) => {
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - offset;
  
    window.scrollTo({
        top: offsetPosition,
        behavior: 'smooth'
    });
  };
  
  // Professional Intersection Observer for Animations
  const observeElements = () => {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('animate-in');
                observer.unobserve(entry.target);
            }
        });
    }, { threshold: 0.1 });
  
    document.querySelectorAll('.animate-on-scroll').forEach(el => {
        observer.observe(el);
    });
  };
  
  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', observeElements);
  } else {
    observeElements();
  }
  
  // Professional Image Lazy Loading
  const lazyLoadImages = () => {
    const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                if (img.dataset.src) {
                    img.src = img.dataset.src;
                    img.removeAttribute('data-src');
                    observer.unobserve(img);
                }
            }
        });
    });
  
    document.querySelectorAll('img[data-src]').forEach(img => {
        imageObserver.observe(img);
    });
  };
  
  lazyLoadImages();
  
  // Professional Toast Notification Helper
  const showToast = (message, type = 'info', duration = 3000) => {
    return notifications.show(message, type, duration);
  };
  
  // Professional Confirmation Dialog
  const confirmAction = (message, title = 'Confirm') => {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100000;
        `;
  
        const dialog = document.createElement('div');
        dialog.style.cssText = `
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        `;
  
        dialog.innerHTML = `
            <h3 style="margin: 0 0 16px 0; color: #FFD700; font-size: 20px;">${title}</h3>
            <p style="margin: 0 0 24px 0; color: rgba(255, 255, 255, 0.9);">${message}</p>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="confirm-cancel" style="padding: 10px 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 215, 0, 0.2); border-radius: 8px; color: rgba(255, 255, 255, 0.9); cursor: pointer;">Cancel</button>
                <button class="confirm-ok" style="padding: 10px 20px; background: rgba(255, 215, 0, 0.2); border: 1px solid rgba(255, 215, 0, 0.4); border-radius: 8px; color: #FFD700; cursor: pointer; font-weight: 600;">Confirm</button>
            </div>
        `;
  
        modal.appendChild(dialog);
        document.body.appendChild(modal);
  
        const close = (result) => {
            Animations.fadeOut(modal).then(() => {
                modal.remove();
                resolve(result);
            });
        };
  
        dialog.querySelector('.confirm-ok').addEventListener('click', () => close(true));
        dialog.querySelector('.confirm-cancel').addEventListener('click', () => close(false));
        modal.addEventListener('click', (e) => {
            if (e.target === modal) close(false);
        });
  
        Animations.fadeIn(modal);
    });
  };
  
  // Professional Local Storage Manager
  class StorageManager {
    static set(key, value, expiry = null) {
        const item = {
            value,
            expiry: expiry ? Date.now() + expiry : null
        };
        localStorage.setItem(key, JSON.stringify(item));
    }
  
    static get(key) {
        const itemStr = localStorage.getItem(key);
        if (!itemStr) return null;
  
        try {
            const item = JSON.parse(itemStr);
            if (item.expiry && Date.now() > item.expiry) {
                localStorage.removeItem(key);
                return null;
            }
            return item.value;
        } catch {
            return null;
        }
    }
  
    static remove(key) {
        localStorage.removeItem(key);
    }
  
    static clear() {
        localStorage.clear();
    }
  }
  
  // Professional URL Parameter Handler
  const URLParams = {
    get: (key) => {
        const params = new URLSearchParams(window.location.search);
        return params.get(key);
    },
  
    set: (key, value) => {
        const url = new URL(window.location);
        url.searchParams.set(key, value);
        window.history.pushState({}, '', url);
    },
  
    remove: (key) => {
        const url = new URL(window.location);
        url.searchParams.delete(key);
        window.history.pushState({}, '', url);
    }
  };
  
  // Professional Viewport Utilities
  const Viewport = {
    isMobile: () => window.innerWidth < 768,
    isTablet: () => window.innerWidth >= 768 && window.innerWidth < 1024,
    isDesktop: () => window.innerWidth >= 1024,
    width: () => window.innerWidth,
    height: () => window.innerHeight
  };
  
  // Professional Device Detection
  const Device = {
    isIOS: () => /iPad|iPhone|iPod/.test(navigator.userAgent),
    isAndroid: () => /Android/.test(navigator.userAgent),
    isMobile: () => /Mobile/.test(navigator.userAgent),
    isTouch: () => 'ontouchstart' in window || navigator.maxTouchPoints > 0
  };
  
  // Professional Network Status Monitor
  class NetworkMonitor {
    constructor() {
        this.online = navigator.onLine;
        this.init();
    }
  
    init() {
        window.addEventListener('online', () => {
            this.online = true;
            notifications.show('Connection restored', 'success');
        });
  
        window.addEventListener('offline', () => {
            this.online = false;
            notifications.show('Connection lost', 'error');
        });
    }
  
    isOnline() {
        return this.online;
    }
  }
  
  const networkMonitor = new NetworkMonitor();
  
  // Professional Theme Manager Enhancement
  class EnhancedThemeManager {
    constructor() {
        this.currentTheme = localStorage.getItem('selectedTheme') || 'default';
        this.init();
    }
  
    init() {
        this.applyTheme(this.currentTheme);
        this.addThemeToggle();
    }
  
    applyTheme(theme) {
        document.body.className = document.body.className.replace(/theme-\w+/g, '').trim();
        if (theme !== 'default') {
            document.body.classList.add(`theme-${theme}`);
        }
        this.currentTheme = theme;
        localStorage.setItem('selectedTheme', theme);
    }
  
    addThemeToggle() {
        // Add quick theme switcher if needed
    }
  }
  
  // Professional Analytics (Privacy-friendly)
  class Analytics {
    static track(event, data = {}) {
        console.log('Event:', event, data);
        // Add your analytics tracking here
    }
  
    static pageView(page) {
        this.track('page_view', { page });
    }
  
    static userAction(action, details = {}) {
        this.track('user_action', { action, ...details });
    }
  }
  
  // Professional Accessibility Enhancements
  const Accessibility = {
    init: () => {
        // Skip to main content link
        const skipLink = document.createElement('a');
        skipLink.href = '#main-content';
        skipLink.textContent = 'Skip to main content';
        skipLink.className = 'sr-only';
        skipLink.style.cssText = `
            position: absolute;
            top: -40px;
            left: 0;
            background: #000;
            color: #fff;
            padding: 8px;
            z-index: 100000;
        `;
        skipLink.addEventListener('focus', () => {
            skipLink.style.top = '0';
        });
        skipLink.addEventListener('blur', () => {
            skipLink.style.top = '-40px';
        });
        document.body.insertBefore(skipLink, document.body.firstChild);
  
        // Add ARIA labels to interactive elements
        document.querySelectorAll('button:not([aria-label])').forEach(btn => {
            if (!btn.textContent.trim() && btn.title) {
                btn.setAttribute('aria-label', btn.title);
            }
        });
    }
  };
  
  Accessibility.init();
  
  // Professional Performance Optimizations
  const Performance = {
    // Lazy load heavy components
    lazyLoad: (selector, callback) => {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    callback(entry.target);
                    observer.unobserve(entry.target);
                }
            });
        });
        document.querySelectorAll(selector).forEach(el => observer.observe(el));
    },
  
    // Preload critical resources
    preload: (url, type = 'script') => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.href = url;
        link.as = type;
        document.head.appendChild(link);
    },
  
    // Debounced resize handler
    onResize: (callback, delay = 250) => {
        let timeout;
        window.addEventListener('resize', () => {
            clearTimeout(timeout);
            timeout = setTimeout(callback, delay);
        });
    }
  };
  
  // Professional Console Styling
  if (console.log) {
    const originalLog = console.log;
    console.log = function(...args) {
        originalLog.apply(console, [
            '%cNebulo',
            'background: linear-gradient(135deg, #FFD700, #FFA500); color: #000; padding: 2px 8px; border-radius: 4px; font-weight: bold;',
            ...args
        ]);
    };
  }
  
  // Professional Error Recovery
  const ErrorRecovery = {
    retry: async (fn, maxRetries = 3, delay = 1000) => {
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await fn();
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
            }
        }
    }
  };
  
  // Professional Feature Detection
  const Features = {
    supports: {
        webGL: () => {
            try {
                const canvas = document.createElement('canvas');
                return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
            } catch {
                return false;
            }
        },
        webP: () => {
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
        },
        localStorage: () => {
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                return true;
            } catch {
                return false;
            }
        }
    }
  };
  
  // Professional Image Optimization
  const ImageOptimizer = {
    compress: (file, maxWidth = 1920, quality = 0.8) => {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
  
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
  
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(resolve, 'image/jpeg', quality);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }
  };
  
  // Professional Color Utilities
  const ColorUtils = {
    hexToRgb: (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    },
  
    rgbToHex: (r, g, b) => {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    },
  
    lighten: (hex, percent) => {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return hex;
        const factor = 1 + percent / 100;
        return this.rgbToHex(
            Math.min(255, Math.floor(rgb.r * factor)),
            Math.min(255, Math.floor(rgb.g * factor)),
            Math.min(255, Math.floor(rgb.b * factor))
        );
    },
  
    darken: (hex, percent) => {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return hex;
        const factor = 1 - percent / 100;
        return this.rgbToHex(
            Math.max(0, Math.floor(rgb.r * factor)),
            Math.max(0, Math.floor(rgb.g * factor)),
            Math.max(0, Math.floor(rgb.b * factor))
        );
    }
  };
  
  // Professional String Utilities
  const StringUtils = {
    truncate: (str, length, suffix = '...') => {
        return str.length > length ? str.substring(0, length) + suffix : str;
    },
  
    capitalize: (str) => {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    },
  
    slugify: (str) => {
        return str.toLowerCase()
            .trim()
            .replace(/[^\w\s-]/g, '')
            .replace(/[\s_-]+/g, '-')
            .replace(/^-+|-+$/g, '');
    },
  
    escapeHtml: (str) => {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
  };
  
  // Professional Array Utilities
  const ArrayUtils = {
    shuffle: (array) => {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    },
  
    chunk: (array, size) => {
        const chunks = [];
        for (let i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    },
  
    unique: (array) => {
        return [...new Set(array)];
    }
  };
  
  // Professional Object Utilities
  const ObjectUtils = {
    deepClone: (obj) => {
        return JSON.parse(JSON.stringify(obj));
    },
  
    merge: (...objects) => {
        return Object.assign({}, ...objects);
    },
  
    isEmpty: (obj) => {
        return Object.keys(obj).length === 0;
    }
  };
  
  // Professional Date Utilities
  const DateUtils = {
    format: (date, format = 'YYYY-MM-DD') => {
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        const seconds = String(d.getSeconds()).padStart(2, '0');
  
        return format
            .replace('YYYY', year)
            .replace('MM', month)
            .replace('DD', day)
            .replace('HH', hours)
            .replace('mm', minutes)
            .replace('ss', seconds);
    },
  
    timeAgo: (date) => {
        return Utils.formatDate(new Date(date).getTime());
    }
  };
  
  // Professional DOM Utilities
  const DOMUtils = {
    createElement: (tag, props = {}, children = []) => {
        const el = document.createElement(tag);
        Object.entries(props).forEach(([key, value]) => {
            if (key === 'style' && typeof value === 'object') {
                Object.assign(el.style, value);
            } else if (key === 'className') {
                el.className = value;
            } else if (key.startsWith('on')) {
                el.addEventListener(key.substring(2).toLowerCase(), value);
            } else {
                el.setAttribute(key, value);
            }
        });
        children.forEach(child => {
            if (typeof child === 'string') {
                el.appendChild(document.createTextNode(child));
            } else {
                el.appendChild(child);
            }
        });
        return el;
    },
  
    ready: (fn) => {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', fn);
        } else {
            fn();
        }
    }
  };
  
  // Professional Event Emitter
  class EventEmitter {
    constructor() {
        this.events = {};
    }
  
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }
  
    off(event, callback) {
        if (this.events[event]) {
            this.events[event] = this.events[event].filter(cb => cb !== callback);
        }
    }
  
    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(data));
        }
    }
  }
  
  const appEvents = new EventEmitter();
  
  
  // Professional Modal Manager
  class ModalManager {
    constructor() {
        this.modals = new Map();
        this.activeModal = null;
    }
  
    register(id, element) {
        this.modals.set(id, element);
    }
  
    open(id) {
        const modal = this.modals.get(id);
        if (modal) {
            if (this.activeModal && this.activeModal !== modal) {
                this.close(this.activeModal.id);
            }
            modal.style.display = 'flex';
            Animations.fadeIn(modal);
            this.activeModal = { id, element: modal };
        }
    }
  
    close(id) {
        const modal = this.modals.get(id);
        if (modal) {
            Animations.fadeOut(modal).then(() => {
                modal.style.display = 'none';
                if (this.activeModal && this.activeModal.id === id) {
                    this.activeModal = null;
                }
            });
        }
    }
  }
  
  const modalManager = new ModalManager();
  
  // Professional Tooltip System
  class TooltipSystem {
    constructor() {
        this.tooltips = new Map();
        this.init();
    }
  
    init() {
        document.querySelectorAll('[data-tooltip]').forEach(el => {
            this.createTooltip(el);
        });
    }
  
    createTooltip(element) {
        const text = element.dataset.tooltip;
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.textContent = text;
        tooltip.style.cssText = `
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        `;
  
        element.style.position = 'relative';
        element.appendChild(tooltip);
  
        element.addEventListener('mouseenter', () => {
            tooltip.style.opacity = '1';
        });
  
        element.addEventListener('mouseleave', () => {
            tooltip.style.opacity = '0';
        });
    }
  }
  
  new TooltipSystem();
  
  
  
  // Professional Console Commands (Easter eggs)
  window.gameHallCommands = {
    help: () => {
        console.log('%cAvailable Commands:', 'font-weight: bold; color: #FFD700;');
        console.log('  - gameHallCommands.help() - Show this help');
        console.log('  - gameHallCommands.theme(name) - Change theme');
        console.log('  - gameHallCommands.notify(message) - Show notification');
        console.log('  - gameHallCommands.stats() - Show performance stats');
    },
  
    theme: (name) => {
        if (typeof applyTheme === 'function') {
            applyTheme(name);
            console.log(`Theme changed to: ${name}`);
        }
    },
  
    notify: (message) => {
        notifications.show(message);
    },
  
    stats: () => {
        console.table(perfMonitor.metrics);
    }
  };
  
  // Dynamic tooltip positioning to prevent clipping
  function setupTooltips() {
    document.querySelectorAll('[title]').forEach(el => {
        if (el.hasAttribute('data-tooltip-setup')) return;
        el.setAttribute('data-tooltip-setup', 'true');
        
        el.addEventListener('mouseenter', function(e) {
            const tooltip = this.getAttribute('title');
            if (!tooltip) return;
            
            // Remove title temporarily to prevent default tooltip
            const originalTitle = this.getAttribute('title');
            this.setAttribute('data-original-title', originalTitle);
            this.removeAttribute('title');
            
            // Create custom tooltip
            const tooltipEl = document.createElement('div');
            tooltipEl.className = 'custom-tooltip';
            tooltipEl.textContent = tooltip;
            document.body.appendChild(tooltipEl);
            
            // Position tooltip
            const rect = this.getBoundingClientRect();
            const tooltipRect = tooltipEl.getBoundingClientRect();
            let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
            let top = rect.top - tooltipRect.height - 12;
            
            // Keep tooltip in viewport
            if (left < 10) left = 10;
            if (left + tooltipRect.width > window.innerWidth - 10) {
                left = window.innerWidth - tooltipRect.width - 10;
            }
            if (top < 10) {
                top = rect.bottom + 12;
                tooltipEl.classList.add('tooltip-below');
            }
            
            tooltipEl.style.left = left + 'px';
            tooltipEl.style.top = top + 'px';
            
            // Store reference for cleanup
            this._tooltipEl = tooltipEl;
        });
        
        el.addEventListener('mouseleave', function() {
            if (this._tooltipEl) {
                this._tooltipEl.remove();
                this._tooltipEl = null;
            }
            // Title restoration removed - no tooltips
        });
    });
  }
  
  // Initialize professional enhancements
  DOMUtils.ready(() => {
    console.log('%c✨ Professional enhancements loaded!', 'font-size: 16px; font-weight: bold; color: #FFD700;');
    
    // Add smooth animations to modals
    document.querySelectorAll('[id$="Modal"]').forEach(modal => {
        modalManager.register(modal.id, modal);
    });
  
    // Initialize tooltips
    new TooltipSystem();
    setupTooltips();
    
    // Re-setup tooltips for dynamically added elements
    const observer = new MutationObserver(() => {
        setupTooltips();
    });
    observer.observe(document.body, { childList: true, subtree: true });
  
    // Add loading states to buttons
    document.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', function() {
            if (this.dataset.loading !== 'true') {
                const originalText = this.innerHTML;
                this.dataset.loading = 'true';
                this.disabled = true;
                this.innerHTML = '<span class="spinner spinner-small"></span> Loading...';
                
                setTimeout(() => {
                    this.innerHTML = originalText;
                    this.disabled = false;
                    this.dataset.loading = 'false';
                }, 1000);
            }
        });
    });
  
    // Add professional hover effects
    document.querySelectorAll('.card, .modalInner').forEach(el => {
        el.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-2px)';
            this.style.boxShadow = '0 12px 40px rgba(0, 0, 0, 0.4)';
        });
        el.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '';
        });
    });
  });
  
  // Professional Export for global use
  window.ProfessionalUtils = {
    notifications,
    Animations,
    Utils,
    FormValidator,
    loadingManager,
    confirmAction,
    showToast,
    StorageManager,
    URLParams,
    Viewport,
    Device,
    ColorUtils,
    StringUtils,
    ArrayUtils,
    ObjectUtils,
    DateUtils,
    DOMUtils,
    Analytics,
    appEvents,
    modalManager
  };
  
  console.log('%c🚀 All professional enhancements are ready!', 'font-size: 14px; color: #28a745;');
  
// ================= Games Grid System =================
const GENERIC_DESCRIPTION_SNIPPETS = [
    'experience this exciting game',
    'engaging gameplay and stunning graphics',
    'premium gaming experiences',
    'ultimate destination for premium gaming',
    'hours of entertainment for players of all skill levels'
];

const MECHANIC_RULES = [
    { tags: ['drift', 'racing'], text: 'chain drifts through sweeping corners and hold speed without spinning out' },
    { tags: ['racing', 'driving'], text: 'thread dense traffic, hit boost pads, and chase leaderboard lap times' },
    { tags: ['shooting', 'first-person-shooter', 'fps'], text: 'snap between targets, manage recoil, and control the map' },
    { tags: ['battle-royale'], text: 'loot fast, hold angles, and survive shrinking zones until you are the last player standing' },
    { tags: ['puzzle', 'brain', 'logic'], text: 'solve escalating logic challenges at a relaxed pace' },
    { tags: ['parkour', 'platformer'], text: 'time precision jumps and wall-runs to clear each route' },
    { tags: ['idle', 'tycoon'], text: 'invest earnings, upgrade stations, and keep production humming even while idle' },
    { tags: ['sports', 'basketball'], text: 'line up shots, outmaneuver defenders, and score clutch points' },
    { tags: ['football', 'soccer'], text: 'fake out defenders, unleash power shots, and protect your own goal' },
    { tags: ['simulator'], text: 'master weighty physics and deliberate control inputs' },
    { tags: ['tower-defense', 'strategy'], text: 'place defenses, upgrade paths, and adapt to enemy waves' },
    { tags: ['sniper'], text: 'steady your aim, account for distance, and confirm each target with precision' }
];

const SECONDARY_RULES = [
    { tags: ['multiplayer', 'io-games'], text: 'Jump into quick online rounds and climb seasonal leaderboards.' },
    { tags: ['2-player'], text: 'Challenge a friend locally or practice against the CPU to sharpen your skills.' },
    { tags: ['drift', 'racing', 'car'], text: 'Earn currency to unlock new rides and fine-tune handling for every track.' },
    { tags: ['idle', 'tycoon', 'simulator'], text: 'Smart upgrades keep progress rolling even when you step away.' },
    { tags: ['puzzle', 'brain', 'logic'], text: 'Every stage adds a new wrinkle, so planning ahead always helps.' },
    { tags: ['shooting', 'weapon', 'gun'], text: 'Experiment with loadouts to counter different maps and enemy types.' },
    { tags: ['parkour', 'speedrun'], text: 'Discover alternate routes to shave seconds off personal bests.' },
    { tags: ['adventure', 'survival'], text: 'Gather resources between missions to stay prepared for tougher encounters.' }
];

function buildTagSet(title = '', existingTags = '') {
    const baseTags = new Set(
        (existingTags || '')
            .split(',')
            .map(tag => tag.trim().toLowerCase())
            .filter(Boolean)
    );
    const normalizedTitle = (title || '').toLowerCase();
    const addTags = (...tags) => tags.forEach(tag => baseTags.add(tag));
    if (/drift|race|racing|speed|traffic/.test(normalizedTitle)) addTags('racing', 'driving');
    if (/car|truck|motor|moto|bike|kart/.test(normalizedTitle)) addTags('car', 'driving');
    if (/parkour|runner|dash|jump|platform|escape|helix/.test(normalizedTitle)) addTags('parkour', 'platformer');
    if (/puzzle|match|block|brain|logic|blast|merge|stack/.test(normalizedTitle)) addTags('puzzle', 'brain', 'logic');
    if (/shoot|sniper|strike|battle|arena|war|combat|gun|fps/.test(normalizedTitle)) addTags('shooting', 'action', 'fps');
    if (/tower|defense|strategy|tactic|siege/.test(normalizedTitle)) addTags('strategy', 'tower-defense');
    if (/idle|tycoon|manager|clicker|simulator|builder|factory|farm|city/.test(normalizedTitle)) addTags('idle', 'tycoon', 'simulator');
    if (/adventure|quest|survival|island|dragon|hero|dungeon|craft/.test(normalizedTitle)) addTags('adventure');
    if (/soccer|football|basket|basketball|hoop|sports/.test(normalizedTitle)) addTags('sports');
    if (/io/.test(normalizedTitle)) addTags('io-games', 'multiplayer');
    if (/multiplayer|online/.test(normalizedTitle)) addTags('multiplayer');
    if (/2 player|2-player|two player|vs/.test(normalizedTitle)) addTags('2-player');
    if (/3d/.test(normalizedTitle)) addTags('3d');
    if (/2d/.test(normalizedTitle)) addTags('2d');
    if (/sniper/.test(normalizedTitle)) addTags('sniper');
    return baseTags;
}

function normalizeGameTags(game = {}) {
    const tagSet = buildTagSet(game.title, game.tags);
    if (tagSet.size === 0) {
        tagSet.add('free');
        tagSet.add('game');
    }
    return Array.from(tagSet).join(',');
}

function getTagArray(tagString = '') {
    return tagString.split(',').map(tag => tag.trim().toLowerCase()).filter(Boolean);
}

function dedupeWords(parts = []) {
    const seen = new Set();
    const ordered = [];
    parts.forEach(part => {
        const trimmed = (part || '').trim();
        if (!trimmed) return;
        if (!seen.has(trimmed)) {
            seen.add(trimmed);
            ordered.push(trimmed);
        }
    });
    return ordered;
}

function inferPrimaryGenre(tags = [], title = '') {
    const titleLower = (title || '').toLowerCase();
    const priority = [
        { tags: ['drift'], label: 'drift racing' },
        { tags: ['racing', 'driving'], label: 'racing' },
        { tags: ['shooting', 'first-person-shooter', 'fps'], label: 'shooter' },
        { tags: ['battle-royale'], label: 'battle royale' },
        { tags: ['puzzle', 'brain', 'logic'], label: 'puzzle' },
        { tags: ['strategy', 'tower-defense'], label: 'strategy' },
        { tags: ['sports', 'basketball', 'soccer', 'football'], label: 'sports' },
        { tags: ['idle', 'tycoon'], label: 'idle/tycoon' },
        { tags: ['simulator'], label: 'simulator' },
        { tags: ['adventure', 'survival'], label: 'adventure' },
        { tags: ['parkour', 'platformer'], label: 'platformer' },
        { tags: ['arcade'], label: 'arcade' }
    ];
    for (const rule of priority) {
        if (rule.tags.some(tag => tags.includes(tag))) {
            return rule.label;
        }
    }
    if (titleLower.includes('drift') || titleLower.includes('race')) return 'racing';
    if (titleLower.includes('shoot') || titleLower.includes('sniper')) return 'shooter';
    if (titleLower.includes('puzzle')) return 'puzzle';
    return 'arcade';
}

function getModeDescriptor(tags = []) {
    if (tags.includes('multiplayer') || tags.includes('io-games')) return 'multiplayer';
    if (tags.includes('2-player')) return 'two-player';
    return 'single-player';
}

function getPerspectiveDescriptor(tags = []) {
    if (tags.includes('first-person-shooter') || tags.includes('fps')) return 'first-person';
    if (tags.includes('top-down')) return 'top-down';
    return '';
}

function getDimensionDescriptor(tags = []) {
    if (tags.includes('3d')) return '3D';
    if (tags.includes('2d')) return '2D';
    return '';
}

function pickDescriptionFromRules(rules, tags) {
    for (const rule of rules) {
        if (rule.tags.some(tag => tags.includes(tag))) {
            return rule.text;
        }
    }
    return '';
}

function isGenericDescription(text = '') {
    if (!text) return true;
    const lower = text.toLowerCase().trim();
    if (lower.length < 40) return true;
    return GENERIC_DESCRIPTION_SNIPPETS.some(snippet => lower.includes(snippet));
}

function generateAccurateDescription(game = {}) {
    const tagString = (game.tags && game.tags.length) ? game.tags : normalizeGameTags(game);
    const tags = getTagArray(tagString);
    const title = game.title || 'This game';
    const descriptorParts = dedupeWords([
        getModeDescriptor(tags),
        getPerspectiveDescriptor(tags),
        getDimensionDescriptor(tags),
        inferPrimaryGenre(tags, title)
    ]);
    const descriptor = descriptorParts.join(' ') || 'arcade';
    const mechanic = pickDescriptionFromRules(MECHANIC_RULES, tags) || 'keeps the pace high from the very first level';
    const secondary = pickDescriptionFromRules(SECONDARY_RULES, tags) || 'Chase higher scores, unlock rewards, and keep improving every run.';
    return `${title} is a ${descriptor} game where you ${mechanic}. ${secondary}`;
}

const GAME_PLACEHOLDER_IMAGE = '/images/logoshs.png';
function getSafeImageUrl(game = {}) {
    const fallback = GAME_PLACEHOLDER_IMAGE;
    try {
        const candidate = (game && (game.image || game.thumbnail || game.thumb || '')) || '';
        const raw = String(candidate).trim();
        if (!raw) return fallback;
        if (raw.startsWith('data:') || raw.startsWith('blob:')) return raw;
        if (raw.includes('images.weserv.nl/?url=')) return raw;
        const normalized = raw.startsWith('http') ? raw : `https://${raw.replace(/^\/+/, '')}`;
        const hostless = normalized.replace(/^https?:\/\//i, '');
        return `https://images.weserv.nl/?url=${encodeURIComponent(hostless)}&output=webp`;
    } catch (e) {
        return fallback;
    }
}

function normalizeGameData(game = {}) {
    if (!game) return game;
    const tags = normalizeGameTags(game);
    let description = (game.description || '').trim();
    if (isGenericDescription(description)) {
        description = generateAccurateDescription({ ...game, tags });
    }
    const image = getSafeImageUrl(game);
    return { ...game, tags, description, image };
}

function ensureAccurateDescriptions(games = []) {
    return games.map(game => normalizeGameData(game));
}

function getGameDescription(game = {}) {
    if (!game) return 'Jump in and start playing.';
    const description = (game.description || '').trim();
    if (isGenericDescription(description)) {
        return generateAccurateDescription(game);
    }
    return description;
}

// Initialize gameSites array with default games (will be merged with JSON data)
gameSites = ensureAccurateDescriptions([
      { title: 'Chess FreezeNova', embed: 'https://cloud.onlinegames.io/games/2025/unity3/chess/index-og.html', image: 'https://www.onlinegames.io/media/posts/1116/responsive/chess-freezenova-xs.webp' },
      { title: 'Davo', embed: 'https://cloud.onlinegames.io/games/2025/construct/302/davo/index-og.html', image: 'https://www.onlinegames.io/media/posts/1115/responsive/davo-xs.webp' },
      { title: 'Fast Food Manager', embed: 'https://cloud.onlinegames.io/games/2025/unity4/fast-food-manager/index-og.html', image: 'https://www.onlinegames.io/media/posts/1114/responsive/fast-food-manager-xs.webp' },
      { title: 'Block Builder Survival', embed: 'https://cloud.onlinegames.io/games/2025/unity4/cubecraft-survival/index-og.html', image: 'https://www.onlinegames.io/media/posts/1113/responsive/cubecraft-survival-xs.webp' },
      { title: 'Love Tester', embed: 'https://www.onlinegames.io/games/2021/3/love-tester/index.html', image: 'https://www.onlinegames.io/media/posts/152/responsive/love-tester-xs.jpg' },
      { title: 'Drift King', embed: 'https://www.onlinegames.io/games/2024/unity/drift-king/index.html', image: 'https://www.onlinegames.io/media/posts/729/responsive/Drift-King-xs.jpg' },
      { title: 'Highway Traffic', embed: 'https://www.onlinegames.io/games/2022/unity/highway-traffic/index.html', image: 'https://www.onlinegames.io/media/posts/32/responsive/Highway-Traffic-2-xs.jpg' },
      { title: 'Stack Fire Ball', embed: 'https://www.onlinegames.io/games/2021/unity/stack-fire-ball/index.html', image: 'https://www.onlinegames.io/media/posts/184/responsive/Stack-Fire-Ball-Game-xs.jpg' },
      { title: 'Masked Special Forces', embed: 'https://www.onlinegames.io/games/2022/unity2/masked-special-forces/index.html', image: 'https://www.onlinegames.io/media/posts/310/responsive/Masked-Special-Forces-FPS-xs.jpg' },
      { title: 'City Simulator', embed: 'https://www.onlinegames.io/games/2023/unity2/gta-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/416/responsive/GTA-Simulator-xs.jpg' },
      { title: 'Real Flight Simulator', embed: 'https://cloud.onlinegames.io/games/2023/unity2/real-flight-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/342/responsive/Real-Flight-Simulator-2-xs.jpg' },
      { title: 'Stickman City Adventure', embed: 'https://cloud.onlinegames.io/games/2024/unity3/stickman-gta-city/index-og.html', image: 'https://www.onlinegames.io/media/posts/900/responsive/stickman-gta-city-free-xs.jpg' },
      { title: 'Drift Hunters Pro', embed: 'https://www.onlinegames.io/games/2023/unity/drift-hunters-pro/index.html', image: 'https://www.onlinegames.io/media/posts/397/responsive/Drift-Hunters-Pro-xs.jpg' },
      { title: 'Stickman Parkour', embed: 'https://cloud.onlinegames.io/games/2024/construct/219/stickman-parkour/index-og.html', image: 'https://www.onlinegames.io/media/posts/871/responsive/stickman-parkour-OG-xs.jpg' },
      { title: 'Fast Food Rush', embed: 'https://cloud.onlinegames.io/games/2025/unity/fast-food-rush/index-og.html', image: 'https://www.onlinegames.io/media/posts/979/responsive/fast-food-rush-xs.jpg' },
      { title: 'Get On Top', embed: 'https://www.onlinegames.io/games/2024/code/6/get-on-top/index.html', image: 'https://www.onlinegames.io/media/posts/697/responsive/Get-on-Top-xs.jpg' },
      { title: 'Edys Car Simulator', embed: 'https://www.onlinegames.io/games/2022/unity/edys-car-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/238/responsive/Edys-Car-Simulator-Online-xs.jpg' },
      { title: 'Crown Defense', embed: 'https://cloud.onlinegames.io/games/2025/construct/337/crown-defense/index-og.html', image: 'https://www.onlinegames.io/media/posts/1098/responsive/crown-defense-online-xs.webp' },
      { title: 'Escape Car', embed: 'https://cloud.onlinegames.io/games/2025/unity2/escape-car/index-og.html', image: 'https://www.onlinegames.io/media/posts/1000/responsive/Escape-Car-xs.jpg' },
      { title: 'Madalin Stunt Cars Pro', embed: 'https://www.onlinegames.io/games/2023/unity/madalin-stunt-cars-pro/index.html', image: 'https://www.onlinegames.io/media/posts/401/responsive/Madalin-Stunt-Cars-Pro-Game-xs.jpg' },
      { title: 'Guerrillas io', embed: 'https://www.onlinegames.io/games/2023/unity2/guerrillas-io/index.html', image: 'https://www.onlinegames.io/media/posts/423/responsive/Guerillas-io-xs.jpg' },
      { title: 'Drift Rider', embed: 'https://www.onlinegames.io/games/2023/unity3/drift-rider/index.html', image: 'https://www.onlinegames.io/media/posts/553/responsive/Drift-Rider-xs.jpg' },
      { title: 'Basket Hoop', embed: 'https://cloud.onlinegames.io/games/2024/construct/311/basket-hoop/index-og.html', image: 'https://www.onlinegames.io/media/posts/843/responsive/Basket-Hoop-xs.jpg' },
      { title: 'Stickman Destruction', embed: 'https://www.onlinegames.io/games/2021/unity3/stickman-destruction/index.html', image: 'https://www.onlinegames.io/media/posts/233/responsive/Stickman-Destruction-xs.jpg' },
      { title: 'Tactical Shooter Online', embed: 'https://www.onlinegames.io/games/2023/unity2/cs-online/index.html', image: 'https://www.onlinegames.io/media/posts/434/responsive/CS-Online-xs.jpg' },
      { title: 'Burnout City', embed: 'https://cloud.onlinegames.io/games/2024/unity/burnout-city/index-og.html', image: 'https://www.onlinegames.io/media/posts/861/responsive/burnoutcity-xs.jpg' },
      { title: 'Love Tester Story', embed: 'https://cloud.onlinegames.io/games/2024/construct/225/love-tester-story/index-og.html', image: 'https://www.onlinegames.io/media/posts/816/responsive/Love-Tester-Story-xs.jpg' },
      { title: 'Police Chase Drifter', embed: 'https://www.onlinegames.io/games/2021/3/police-chase-drifter/index.html', image: 'https://www.onlinegames.io/media/posts/155/responsive/Police-Chase-Drifter-Online-xs.jpg' },
      { title: 'Super Car Driving', embed: 'https://cloud.onlinegames.io/games/2024/unity2/super-car-driving/index-og.html', image: 'https://www.onlinegames.io/media/posts/854/responsive/supercardriving-2-xs.jpg' },
      { title: 'WarStrike', embed: 'https://cloud.onlinegames.io/games/2024/unity3/warstrike/index-og.html', image: 'https://www.onlinegames.io/media/posts/870/responsive/WarStrike-Online-xs.jpg' },
      { title: 'Legendary Sniper', embed: 'https://www.onlinegames.io/games/2021/unity3/legendary-sniper/index.html', image: 'https://www.onlinegames.io/media/posts/596/responsive/Legendary-Sniper-xs.jpg' },
      { title: 'Motorbike Stunt Simulator', embed: 'https://cloud.onlinegames.io/games/2021/unity/motorbike-stunt-simulator/index-og.html', image: 'https://www.onlinegames.io/media/posts/1045/responsive/motorbike_stunt_simulator_game-2-xs.webp' },
      { title: 'Capybara Clicker Pro', embed: 'https://www.onlinegames.io/games/2023/q2/capybara-clicker-pro/index.html', image: 'https://www.onlinegames.io/media/posts/554/responsive/Capybara-Clicker-Pro-xs.jpg' },
      { title: 'Block Blast', embed: 'https://cloud.onlinegames.io/games/2024/unity3/block-blast/index-og.html', image: 'https://www.onlinegames.io/media/posts/876/responsive/block-blast-xs.jpg' },
      { title: 'Subway Idle 3D', embed: 'https://www.onlinegames.io/games/2022/unity4/subway-idle-3d/index.html', image: 'https://www.onlinegames.io/media/posts/586/responsive/Subway-Idle-xs.jpg' },
      { title: 'Highway Racer Pro', embed: 'https://www.onlinegames.io/games/2024/unity/highway-racer-pro/index.html', image: 'https://www.onlinegames.io/media/posts/822/responsive/Highway-Racer-Pro-xs.jpg' },
      { title: 'Basketball io', embed: 'https://www.onlinegames.io/games/2022/unity3/basketball-io/index.html', image: 'https://www.onlinegames.io/media/posts/302/responsive/Basketball-io-2-xs.jpg' },
      { title: 'Mob City', embed: 'https://www.onlinegames.io/games/2021/unity3/mob-city/index.html', image: 'https://www.onlinegames.io/media/posts/418/responsive/Mob-City-xs.jpg' },
      { title: 'Crazy Drifter', embed: 'https://www.onlinegames.io/games/2022/unity3/crazy-drifter/index.html', image: 'https://www.onlinegames.io/media/posts/314/responsive/Crazy-Drifter-xs.jpg' },
      { title: 'Archer Hero', embed: 'https://www.onlinegames.io/games/2023/unity/archer-hero/index.html', image: 'https://www.onlinegames.io/media/posts/364/responsive/Archer-Hero-Online-xs.jpg' },
      { title: 'F1 Drift Racer', embed: 'https://www.onlinegames.io/games/2022/construct/134/f1-drift-racer/index.html', image: 'https://www.onlinegames.io/media/posts/504/responsive/F1-Drift-Racer-xs.jpg' },
      { title: 'Cat Simulator', embed: 'https://www.onlinegames.io/games/2022/unity4/cat-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/330/responsive/Cat-Simulator-Online-xs.jpg' },
      { title: 'Highway Cars', embed: 'https://www.onlinegames.io/games/2023/construct/211/highway-cars/index.html', image: 'https://www.onlinegames.io/media/posts/598/responsive/Highway-Cars-xs.jpg' },
      { title: 'Car Football', embed: 'https://www.onlinegames.io/games/2023/construct/198/car-football/index.html', image: 'https://www.onlinegames.io/media/posts/405/responsive/Car-Football-xs.jpg' },
      { title: 'ArmedForces.io', embed: 'https://www.onlinegames.io/games/2021/unity3/armedforces-io/index.html', image: 'https://www.onlinegames.io/media/posts/234/responsive/Armed-Forces-io-xs.jpg' },
      { title: 'Kick The Dummy', embed: 'https://www.onlinegames.io/games/2022/construct/153/kick-the-dummy/index.html', image: 'https://www.onlinegames.io/media/posts/414/responsive/Kick-The-Dummy-Game-xs.jpg' },
      { title: 'Cake Match Puzzle', embed: 'https://cloud.onlinegames.io/games/2024/unity3/cake-match-puzzle/index-og.html', image: 'https://www.onlinegames.io/media/posts/908/responsive/55-xs.jpg' },
      { title: 'FPS Strike', embed: 'https://cloud.onlinegames.io/games/2024/unity2/fps-strike/index-og.html', image: 'https://www.onlinegames.io/media/posts/902/responsive/fps-strike-online-xs.jpg' },
      { title: 'Drift Fury', embed: 'https://www.onlinegames.io/games/2023/unity/drift-fury/index.html', image: 'https://www.onlinegames.io/media/posts/650/responsive/Drift-Fury-xs.jpg' },
      { title: 'Rooftop Duel', embed: 'https://cloud.onlinegames.io/games/2025/construct/213/rooftop-duel/index-og.html', image: 'https://www.onlinegames.io/media/posts/1002/responsive/Rooftop-Duel-Online-xs.jpg' },
      { title: 'Mini Cars Racing', embed: 'https://cloud.onlinegames.io/games/2021/unity/mini-cars-racing/index-og.html', image: 'https://www.onlinegames.io/media/posts/1010/responsive/Mini-Cars-Racing-xs.jpg' },
      { title: 'Geometry Dasher FreezeNova', embed: 'https://www.onlinegames.io/games/2023/q2/geometry-dash-freezenova/index.html', image: 'https://www.onlinegames.io/media/posts/510/responsive/Geometry-Dash-FreezeNova-xs.jpg' },
      { title: 'Head Soccer 2022', embed: 'https://www.onlinegames.io/games/2023/construct/280/head-soccer-2022/index.html', image: 'https://www.onlinegames.io/media/posts/624/responsive/Head-Soccer-2022-xs.jpg' },
      { title: '8 Ball Pool Billiard', embed: 'https://www.onlinegames.io/games/2022/unity3/8-ball-pool-billiard/index.html', image: 'https://www.onlinegames.io/media/posts/442/responsive/8-Ball-Pool-Billiard-xs.jpg' },
      { title: 'Click Master Pro', embed: 'https://cloud.onlinegames.io/games/2025/unity/cookie-clicker-pro/index-og.html', image: 'https://www.onlinegames.io/media/posts/971/responsive/Cookie-Clicker-Pro-Game-xs.jpg' },
      { title: 'Secret Sniper Agent', embed: 'https://www.onlinegames.io/games/2022/construct/129/secret-sniper-agent/index.html', image: 'https://www.onlinegames.io/media/posts/753/responsive/Secret-Sniper-Agent-xs.jpg' },
      { title: 'Basketball King', embed: 'https://cloud.onlinegames.io/games/2024/construct/316/basketball-king/index-og.html', image: 'https://www.onlinegames.io/media/posts/907/responsive/basketball-king-xs.jpg' },
      { title: 'Nuts and Bolts Puzzle', embed: 'https://cloud.onlinegames.io/games/2025/unity/nuts-and-bolts-puzzle/index-og.html', image: 'https://www.onlinegames.io/media/posts/965/responsive/nuts-and-bolts-puzzle-xs.jpg' },
      { title: 'Monster Survivors', embed: 'https://cloud.onlinegames.io/games/2025/unity/monster-survivors/index-og.html', image: 'https://www.onlinegames.io/media/posts/942/responsive/Monster-survivors-xs.jpg' },
      { title: 'Fort Drifter', embed: 'https://www.onlinegames.io/games/2022/unity3/fort-drifter/index.html', image: 'https://www.onlinegames.io/media/posts/592/responsive/Fort-Drifter-xs.jpg' },
      { title: 'Supercars Drift', embed: 'https://www.onlinegames.io/games/2023/unity3/supercars-drift/index.html', image: 'https://www.onlinegames.io/media/posts/628/responsive/SuperCars-Drift-xs.jpg' },
      { title: 'Deer Hunter', embed: 'https://www.onlinegames.io/games/2021/1/deer-hunter/index.html', image: 'https://www.onlinegames.io/media/posts/591/responsive/Deer-Hunter-xs.jpg' },
      { title: 'Crazy Parking Fury', embed: 'https://www.onlinegames.io/games/2022/unity3/crazy-parking-fury/index.html', image: 'https://www.onlinegames.io/media/posts/643/responsive/Crazy-Parking-Fury-xs.jpg' },
      { title: 'Wasteland Shooters', embed: 'https://www.onlinegames.io/games/2021/unity2/wasteland-shooters/index.html', image: 'https://www.onlinegames.io/media/posts/218/responsive/Wasteland-Shooters-xs.jpg' },
      { title: 'Motorbike Traffic', embed: 'https://www.onlinegames.io/games/2021/unity/motorbike-traffic/index.html', image: 'https://www.onlinegames.io/media/posts/419/responsive/Motorbike-Traffic-Game-xs.jpg' },
      { title: 'Rome Simulator', embed: 'https://www.onlinegames.io/games/2021/unity/rome-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/634/responsive/Rome-Simulator-2-xs.jpg' },
      { title: 'Taxi Simulator', embed: 'https://www.onlinegames.io/games/2022/unity/taxi-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/465/responsive/Taxi-Simulator-xs.jpg' },
      { title: 'Block World', embed: 'https://cloud.onlinegames.io/games/2025/unity/voxel-world/index-og.html', image: 'https://www.onlinegames.io/media/posts/937/responsive/voxel-world-xs.jpg' },
      { title: 'Crazy Car Arena', embed: 'https://www.onlinegames.io/games/2022/unity3/crazy-car-arena/index.html', image: 'https://www.onlinegames.io/media/posts/317/responsive/Crazy-Car-Arena-Game-xs.jpg' },
      { title: 'ATV Highway Traffic', embed: 'https://www.onlinegames.io/games/2021/unity/atv-highway-traffic/index.html', image: 'https://www.onlinegames.io/media/posts/668/responsive/ATV-Highway-Traffic-xs.jpg' },
      { title: 'Poop Clicker', embed: 'https://www.onlinegames.io/games/2024/construct/292/poop-clicker/index.html', image: 'https://www.onlinegames.io/media/posts/742/responsive/Poop-Clicker-xs.jpg' },
      { title: 'Police Traffic', embed: 'https://www.onlinegames.io/games/2021/unity/police-traffic/index.html', image: 'https://www.onlinegames.io/media/posts/187/responsive/Pollice-Traffic-xs.jpg' },
      { title: 'Burnout Drift Hunter', embed: 'https://www.onlinegames.io/games/2022/unity4/burnout-drift-hunter/index.html', image: 'https://www.onlinegames.io/media/posts/327/responsive/Burnout-Drift-Hunter-Online-xs.jpg' },
      { title: 'Jeep Driver', embed: 'https://cloud.onlinegames.io/games/2021/1/jeep-driver/index-og.html', image: 'https://www.onlinegames.io/media/posts/1039/responsive/jeep-driver-game-3-xs.webp' },
      { title: 'Airplane Racer', embed: 'https://www.onlinegames.io/games/2022/unity/airplane-racer/index.html', image: 'https://www.onlinegames.io/media/posts/268/responsive/Airplane-Racer-xs.jpg' },
      { title: 'Solitaire', embed: 'https://cloud.onlinegames.io/games/2025/html/solitaire/index-og.html', image: 'https://www.onlinegames.io/media/posts/1007/responsive/solitaire-xs.jpg' },
      { title: '2 Player Crazy Racer', embed: 'https://www.onlinegames.io/games/2022/unity3/2-player-crazy-racer/index.html', image: 'https://www.onlinegames.io/media/posts/617/responsive/2-Player-Crazy-Racer-xs.jpg' },
      { title: 'Masked Forces Zombie Survival', embed: 'https://www.onlinegames.io/games/2021/unity3/masked-forces-zombie-survival/index.html', image: 'https://www.onlinegames.io/media/posts/225/responsive/Masked-Forces-Zombie-Survival-Online-xs.jpg' },
      { title: 'Highway Racer 2', embed: 'https://www.onlinegames.io/games/2022/unity2/highway-racer-2/index.html', image: 'https://www.onlinegames.io/media/posts/323/responsive/Highway-Racer-2-xs.jpg' },
      { title: 'Hero Rush Tower Defense', embed: 'https://www.onlinegames.io/games/2023/unity/hero-rush-tower-defense/index.html', image: 'https://www.onlinegames.io/media/posts/491/responsive/Hero-Rush-Tower-Defense-Play-xs.jpg' },
      { title: 'Kick the Alien', embed: 'https://cloud.onlinegames.io/games/2021/4/kick-the-alien/index-og.html', image: 'https://www.onlinegames.io/media/posts/997/responsive/Kick-the-Alien-xs.jpg' },
      { title: 'Alien Sky Invasion', embed: 'https://www.onlinegames.io/games/2021/unity3/alien-sky-invasion/index.html', image: 'https://www.onlinegames.io/media/posts/594/responsive/Alien-Sky-Invasion-xs.jpg' },
      { title: 'Kingdom Attack', embed: 'https://www.onlinegames.io/games/2021/unity3/kingdom-attack/index.html', image: 'https://www.onlinegames.io/media/posts/371/responsive/Kingdom-Attack-xs.jpg' },
      { title: 'Fun Party Makeup', embed: 'https://www.onlinegames.io/games/2021/4/fun-party-makeup/index.html', image: 'https://www.onlinegames.io/media/posts/723/responsive/Fun-Party-Makeup-xs.jpg' },
      { title: 'Wedding Beauty Salon', embed: 'https://www.onlinegames.io/games/2021/2/wedding-beauty-salon/index.html', image: 'https://www.onlinegames.io/media/posts/421/responsive/Wedding-Beauty-Salon-xs.jpg' },
      { title: 'Survival Karts', embed: 'https://cloud.onlinegames.io/games/2024/unity3/survival-karts/index-og.html', image: 'https://www.onlinegames.io/media/posts/887/responsive/survival-karts-play-xs.jpg' },
      { title: 'Super Mini Racing', embed: 'https://www.onlinegames.io/games/2022/unity4/super-mini-racing/index.html', image: 'https://www.onlinegames.io/media/posts/819/responsive/Super-Mini-Racing-xs.jpg' },
      { title: 'Survival Craft', embed: 'https://www.onlinegames.io/games/2022/unity/survival-craft/index.html', image: 'https://www.onlinegames.io/media/posts/593/responsive/Survival-Craft-Game-xs.jpg' },
      { title: 'Bus Subway Runner', embed: 'https://www.onlinegames.io/games/2022/unity/bus-subway-runner/index.html', image: 'https://www.onlinegames.io/media/posts/235/responsive/Bus-Subway-Runner-Game-xs.jpg' },
      { title: 'City Stunts', embed: 'https://www.onlinegames.io/games/2023/unity3/city-stunts/index.html', image: 'https://www.onlinegames.io/media/posts/629/responsive/City-Stunts-Game-xs.jpg' },
      { title: 'Snake Football', embed: 'https://www.onlinegames.io/games/2023/construct/200/snake-football/index.html', image: 'https://www.onlinegames.io/media/posts/706/responsive/Snake-Football-xs.jpg' },
      { title: 'Nova Clicker', embed: 'https://cloud.onlinegames.io/games/2024/construct/314/nova-clicker/index-og.html', image: 'https://www.onlinegames.io/media/posts/981/responsive/Nova-Clicker-xs.jpg' },
      { title: 'Farming Island', embed: 'https://cloud.onlinegames.io/games/2025/unity/farming-island/index-og.html', image: 'https://www.onlinegames.io/media/posts/988/responsive/farming-island-xs.jpg' },
      { title: 'Urban Sniper', embed: 'https://www.onlinegames.io/games/2022/unity2/urban-sniper/index.html', image: 'https://www.onlinegames.io/media/posts/322/responsive/Urban-Sniper-Game-xs.jpg' },
      { title: 'Draw the Car Path', embed: 'https://cloud.onlinegames.io/games/2021/4/draw-the-car-path/index-og.html', image: 'https://www.onlinegames.io/media/posts/936/responsive/draw-the-car-path-xs.jpg' },
      { title: 'Troll Level', embed: 'https://cloud.onlinegames.io/games/2024/unity2/troll-level/index-og.html', image: 'https://www.onlinegames.io/media/posts/857/responsive/troll-level-online-xs.jpg' },
      { title: 'SpartaHoppers', embed: 'https://cloud.onlinegames.io/games/2025/construct/227/spartahoppers/index-og.html', image: 'https://www.onlinegames.io/media/posts/949/responsive/sparta-hoppers-game-xs.jpg' },
      { title: 'Army Combat', embed: 'https://www.onlinegames.io/games/2021/unity/army-combat/index.html', image: 'https://www.onlinegames.io/media/posts/664/responsive/Army-Combat-xs.jpg' },
      { title: 'Crazy Karts', embed: 'https://www.onlinegames.io/games/2024/unity/crazy-karts/index.html', image: 'https://www.onlinegames.io/media/posts/740/responsive/Crazy-Karts-xs.jpg' },
      { title: 'Tank Arena', embed: 'https://cloud.onlinegames.io/games/2025/construct/293/tank-arena/index-og.html', image: 'https://www.onlinegames.io/media/posts/956/responsive/Tank-Arena-Online-xs.jpg' },
      { title: 'Julie Beauty Salon', embed: 'https://cloud.onlinegames.io/games/2021/1/julie-beauty-salon/index-og.html', image: 'https://www.onlinegames.io/media/posts/1011/responsive/Julie-Beauty-Salon-xs.jpg' },
      { title: 'Egg Car Racing', embed: 'https://cloud.onlinegames.io/games/2024/construct/289/egg-car-racing/index-og.html', image: 'https://www.onlinegames.io/media/posts/910/responsive/egg-car-racing-xs.jpg' },
      { title: 'Moto Trials', embed: 'https://www.onlinegames.io/games/2021/unity/moto-trials/index.html', image: 'https://www.onlinegames.io/media/posts/523/responsive/Moto-Trials-xs.jpg' },
      { title: 'Pixel Driver', embed: 'https://cloud.onlinegames.io/games/2021/unity3/pixel-driver/index-og.html', image: 'https://www.onlinegames.io/media/posts/990/responsive/Pixel-Driver-xs.jpg' },
      { title: 'Night Shift Security', embed: 'https://cloud.onlinegames.io/games/2025/unity2/five-nights-at-poppy/index-og.html', image: 'https://www.onlinegames.io/media/posts/992/responsive/Five-Nights-at-Poppy-xs.jpg' },
      { title: 'Offroad Rally', embed: 'https://www.onlinegames.io/games/2023/unity2/offroad-rally/index.html', image: 'https://www.onlinegames.io/media/posts/461/responsive/Offroad-Rally-xs.jpg' },
      { title: 'Skibidi Toilet io', embed: 'https://www.onlinegames.io/games/2023/construct/242/skibidi-toilet-io/index.html', image: 'https://www.onlinegames.io/media/posts/540/responsive/Skibidi-Toilet-xs.jpg' },
      { title: 'Survival Island', embed: 'https://cloud.onlinegames.io/games/2024/unity2/survival-island/index-og.html', image: 'https://www.onlinegames.io/media/posts/970/responsive/Survival-Island-xs.jpg' },
      { title: 'State io Wars', embed: 'https://www.onlinegames.io/games/2024/construct/233/state-io-wars/index.html', image: 'https://www.onlinegames.io/media/posts/685/responsive/State-io-Wars-xs.jpg' },
      { title: 'Hero Dragon Power', embed: 'https://www.onlinegames.io/games/2023/unity/hero-dragon-power/index.html', image: 'https://www.onlinegames.io/media/posts/365/responsive/Hero-Dragon-Power-Game-xs.jpg' },
      { title: 'Battle Royale Simulator', embed: 'https://www.onlinegames.io/games/2022/unity3/battle-royale-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/633/responsive/Battle-Royale-Simulator-xs.jpg' },
      { title: 'Monster Truck City Parking', embed: 'https://www.onlinegames.io/games/2021/unity/monster-truck-city-parking/index.html', image: 'https://www.onlinegames.io/media/posts/582/responsive/Monster-Truck-City-Parking-xs.jpg' },
      { title: 'Geometry Dasher Escape', embed: 'https://cloud.onlinegames.io/games/2024/construct/299/geometry-escape/index-og.html', image: 'https://www.onlinegames.io/media/posts/905/responsive/Geometry-Escape-xs.jpg' },
      { title: 'Dark Ninja Hanjo', embed: 'https://www.onlinegames.io/games/2023/unity/dark-ninja-hanjo/index.html', image: 'https://www.onlinegames.io/media/posts/451/responsive/Dark-Ninja-Hanjo-xs.jpg' },
      { title: 'Princess Influencer Salon', embed: 'https://www.onlinegames.io/games/2021/3/princess-influencer-salon/index.html', image: 'https://www.onlinegames.io/media/posts/485/responsive/Princess-Influencer-Salon-xs.jpg' },
      { title: 'Four Colors', embed: 'https://www.onlinegames.io/games/2023/code/four-colors/index.html', image: 'https://www.onlinegames.io/media/posts/535/responsive/Four-Colors-xs.jpg' },
      { title: 'Precision Sniper', embed: 'https://www.onlinegames.io/games/2021/1/sniper-elite/index.html', image: 'https://www.onlinegames.io/media/posts/127/responsive/Sniper-Elite-Online-xs.jpg' },
      { title: 'Tile Match', embed: 'https://cloud.onlinegames.io/games/2025/unity/tile-match/index-og.html', image: 'https://www.onlinegames.io/media/posts/939/responsive/tile-match-xs.jpg' },
      { title: 'Bandits Multiplayer PvP', embed: 'https://www.onlinegames.io/games/2021/unity2/bandits-multiplayer-pvp/index.html', image: 'https://www.onlinegames.io/media/posts/487/responsive/Bandits-Multiplayer-PvP-xs.jpg' },
      { title: 'Agent Smith', embed: 'https://www.onlinegames.io/games/2021/unity/agent-smith/index.html', image: 'https://www.onlinegames.io/media/posts/189/responsive/Agent-Smith-2-xs.jpg' },
      { title: 'Stick Guys Defense', embed: 'https://www.onlinegames.io/games/2022/unity3/stick-guys-defense/index.html', image: 'https://www.onlinegames.io/media/posts/476/responsive/Stick-Guys-Defense-xs.jpg' },
      { title: 'CobraZ.io Classic', embed: 'https://www.onlinegames.io/games/2022/unity/cobraz-io-classic/index.html', image: 'https://www.onlinegames.io/media/posts/546/responsive/Cobraz.io-Classic-xs.jpg' },
      { title: 'Shortcut Race', embed: 'https://www.onlinegames.io/games/2023/construct/237/shortcut-race/index.html', image: 'https://www.onlinegames.io/media/posts/492/responsive/Shortcut-Race-xs.jpg' },
      { title: 'Monster Truck Mountain Climb', embed: 'https://cloud.onlinegames.io/games/2021/2/monster-truck-mountain-climb/index-og.html', image: 'https://www.onlinegames.io/media/posts/924/responsive/monster-truck-mountain-climb-xs.jpg' },
      { title: 'Basketball Slam Dunk', embed: 'https://www.onlinegames.io/games/2021/unity2/basketball-slam-dunk/index.html', image: 'https://www.onlinegames.io/media/posts/200/responsive/Basketball-Slam-Dunk-xs.jpg' },
      { title: 'Snake', embed: 'https://cloud.onlinegames.io/games/2024/phaser/snake/index-og.html', image: 'https://www.onlinegames.io/media/posts/919/responsive/snake-xs.jpg' },
      { title: 'Powerslide Kart Simulator', embed: 'https://www.onlinegames.io/games/2022/unity3/powerslide-kart-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/578/responsive/Powerslide-Kart-Simulator-xs.jpg' },
      { title: 'Stunt Simulator 2', embed: 'https://www.onlinegames.io/games/2021/unity3/stunt-simulator-2/index.html', image: 'https://www.onlinegames.io/media/posts/765/responsive/Stunt-simulator-2-xs.jpg' },
      { title: 'Blocky Parkour Ninja', embed: 'https://www.onlinegames.io/games/2022/construct/156/blocky-parkour-ninja/index.html', image: 'https://www.onlinegames.io/media/posts/440/responsive/Blocky-Parkour-Ninja-xs.jpg' },
      { title: 'Football King', embed: 'https://www.onlinegames.io/games/2024/construct/226/football-king/index.html', image: 'https://www.onlinegames.io/media/posts/739/responsive/Football-King-xs.jpg' },
      { title: 'American Touchdown', embed: 'https://www.onlinegames.io/games/2021/unity3/american-touchdown/index.html', image: 'https://www.onlinegames.io/media/posts/545/responsive/American-Touchdown-Game-xs.jpg' },
      { title: 'Hover Racer', embed: 'https://www.onlinegames.io/games/2021/unity3/hover-racer/index.html ', image: 'https://www.onlinegames.io/media/posts/224/responsive/Hover-Racer-Game-xs.jpg' },
      { title: 'Nova Craft', embed: 'https://cloud.onlinegames.io/games/2024/more2/nova-craft/index.html', image: 'https://www.onlinegames.io/media/posts/841/responsive/Nova-Craft-xs.jpg' },
      { title: 'Futuristic Racer', embed: 'https://cloud.onlinegames.io/games/2021/2/futuristic-racer/index-og.html', image: 'https://www.onlinegames.io/media/posts/1051/responsive/futuristic_racer_game-xs.webp' },
      { title: 'Music Battle 3D', embed: 'https://www.onlinegames.io/games/2022/unity/fnf-funk-3d/index.html', image: 'https://www.onlinegames.io/media/posts/613/responsive/FNF-Funk-3D-xs.jpg' },
      { title: 'Tractor Farming Simulator', embed: 'https://www.onlinegames.io/games/2022/unity/tractor-farming-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/552/responsive/Tractor-Farming-Simulator-xs.jpg' },
      { title: 'Dinosaur Game', embed: 'https://www.onlinegames.io/games/2023/q2/dinosaur-game/index.html', image: 'https://www.onlinegames.io/media/posts/417/responsive/Dinosaur-Game-Online-xs.jpg' },
      { title: 'Jeep Racing', embed: 'https://www.onlinegames.io/games/2023/freezenova.com/jeep-racing/index.html', image: 'https://www.onlinegames.io/media/posts/564/responsive/Jeep-Racing-xs.jpg' },
      { title: 'Mahjong', embed: 'https://cloud.onlinegames.io/games/2025/unity/mahjong/index-og.html', image: 'https://www.onlinegames.io/media/posts/966/responsive/Mahjong-xs.jpg' },
      { title: 'Fire and Water', embed: 'https://www.onlinegames.io/games/2023/construct/179/fire-and-water/index.html', image: 'https://www.onlinegames.io/media/posts/469/responsive/Fire-and-Water-xs.jpg' },
      { title: 'Mech Shooter', embed: 'https://www.onlinegames.io/games/2022/unity/mech-shooter/index.html', image: 'https://www.onlinegames.io/media/posts/649/responsive/Mech-Shooter-xs.jpg' },
      { title: 'Kick the Zombie', embed: 'https://www.onlinegames.io/games/2021/2/kick-the-zombie/index.html', image: 'https://www.onlinegames.io/media/posts/755/responsive/kick-the-zombie-xs.jpg' },
      { title: 'Jacks Village', embed: 'https://www.onlinegames.io/games/2021/unity/jacks-village/index.html', image: 'https://www.onlinegames.io/media/posts/493/responsive/Jacks-Village-xs.jpg' },
      { title: 'Crazy Stickman Physics', embed: 'https://www.onlinegames.io/games/2023/construct/185/crazy-stickman-physics/index.html', image: 'https://www.onlinegames.io/media/posts/715/responsive/Crazy-Stickman-Physics-xs.jpg' },
      { title: 'Galactic Sniper', embed: 'https://www.onlinegames.io/games/2021/2/galactic-sniper/index.html', image: 'https://www.onlinegames.io/media/posts/719/responsive/Galactic-Sniper-xs.jpg' },
      { title: 'Evil Santa', embed: 'https://www.onlinegames.io/games/2021/1/evil-santa/index.html', image: 'https://www.onlinegames.io/media/posts/539/responsive/Evil-Santa-Game-xs.jpg' },
      { title: 'Kingdom Battle 3D', embed: 'https://cloud.onlinegames.io/games/2025/unity2/kingdom-battle-3d/index-og.html', image: 'https://www.onlinegames.io/media/posts/991/responsive/Kingdom-Battle-3D-xs.jpg' },
      { title: 'Limousine Simulator', embed: 'https://www.onlinegames.io/games/2021/4/limousine-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/701/responsive/Limousine-Simulator-xs.jpg' },
      { title: 'Car Wash', embed: 'https://www.onlinegames.io/games/2023/unity2/car-wash/index.html', image: 'https://www.onlinegames.io/media/posts/407/responsive/Car-Wash-Online-Game-xs.jpg' },
      { title: 'Perfect First Date', embed: 'https://www.onlinegames.io/games/2021/3/perfect-first-date/index.html', image: 'https://www.onlinegames.io/media/posts/532/responsive/Perfect-First-Date-xs.jpg' },
      { title: 'Witch Beauty Salon', embed: 'https://www.onlinegames.io/games/2021/2/witch-beauty-salon/index.html', image: 'https://www.onlinegames.io/media/posts/544/responsive/Witch-Beauty-Salon-xs.jpg' },
      { title: 'Paw Clicker', embed: 'https://cloud.onlinegames.io/games/2025/construct/331/paw-clicker/index-og.html', image: 'https://www.onlinegames.io/media/posts/1077/responsive/Paw-Clicker-xs.webp' },
      { title: 'Head Basketball', embed: 'https://www.onlinegames.io/games/2022/unity/head-basketball/index.html', image: 'https://www.onlinegames.io/media/posts/486/responsive/Head-Basketball-xs.jpg' },
      { title: 'Find It', embed: 'https://cloud.onlinegames.io/games/2025/unity/find-it/index-og.html', image: 'https://www.onlinegames.io/media/posts/940/responsive/Find-It-xs.jpg' },
      { title: 'Crazy Moto Racing', embed: 'https://cloud.onlinegames.io/games/2022/unity3/crazy-moto-racing/index-og.html', image: 'https://www.onlinegames.io/media/posts/931/responsive/crazy-moto-racing-xs.jpg' },
      { title: 'Zombie Sniper', embed: 'https://www.onlinegames.io/games/2022/construct/116/zombie-sniper/index.html', image: 'https://www.onlinegames.io/media/posts/745/responsive/Zombie-Sniper-xs.jpg' },
      { title: 'Storm City Mafia', embed: 'https://www.onlinegames.io/games/2022/unity/storm-city-mafia/index.html', image: 'https://www.onlinegames.io/media/posts/480/responsive/Storm-City-Mafia-xs.jpg' },
      { title: 'Holiday Clicker', embed: 'https://www.onlinegames.io/games/2023/construct/288/xmas-cookie-clicker/index.html', image: 'https://www.onlinegames.io/media/posts/588/responsive/Xmas-Cookie-Clicker-xs.jpg' },
      { title: 'Dont Fall io', embed: 'https://www.onlinegames.io/games/2021/unity/dont-fall-io/index.html', image: 'https://www.onlinegames.io/media/posts/182/responsive/Dont-Fall-io-2-xs.jpg' },
      { title: 'Hover Racer Pro', embed: 'https://www.onlinegames.io/games/2021/unity/hover-racer-pro/index.html', image: 'https://www.onlinegames.io/media/posts/572/responsive/Hover-Racer-Pro-xs.jpg' },
      { title: 'Soul Essence Adventure', embed: 'https://www.onlinegames.io/games/2022/unity2/soul-essence-adventure/index.html', image: 'https://www.onlinegames.io/media/posts/549/responsive/Soul-Essence-Adventure-xs.jpg' },
      { title: 'Mini Shooters', embed: 'https://www.onlinegames.io/games/2021/5/mini-shooters/index.html', image: 'https://www.onlinegames.io/media/posts/206/responsive/Mini-Shooters-Online-xs.jpg' },
      { title: 'Idle Dev Startup', embed: 'https://www.onlinegames.io/games/2023/unity3/idle-dev-startup/index.html', image: 'https://www.onlinegames.io/media/posts/566/responsive/Idle-Dev-Startup-Game-xs.jpg' },
      { title: 'Formula 1 Driver', embed: 'https://www.onlinegames.io/games/2022/construct/133/formula-1-driver/index.html', image: 'https://www.onlinegames.io/media/posts/497/responsive/Formula-1-Driver-xs.jpg' },
      { title: 'Pinball Simulator', embed: 'https://www.onlinegames.io/games/2021/unity2/pinball-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/460/responsive/Pinball-Simulator-xs.jpg' },
      { title: 'Tiny Crash Fighters', embed: 'https://www.onlinegames.io/games/2023/construct/285/tiny-crash-fighters/index.html', image: 'https://www.onlinegames.io/media/posts/622/responsive/Tiny-Crash-Fighters-xs.jpg' },
      { title: 'Hook Wars', embed: 'https://www.onlinegames.io/games/2023/unity3/hook-wars/index.html', image: 'https://www.onlinegames.io/media/posts/610/responsive/Hook-Wars-xs.jpg' },
      { title: 'Romantic Secret Kiss', embed: 'https://www.onlinegames.io/games/2021/3/romantic-secret-kiss/index.html', image: 'https://www.onlinegames.io/media/posts/483/responsive/Romantic-Secret-Kiss-xs.jpg' },
      { title: 'Kings io', embed: 'https://cloud.onlinegames.io/games/2025/construct/208/kings-io/index-og.html', image: 'https://www.onlinegames.io/media/posts/952/responsive/Kings-io-xs.jpg' },
      { title: 'War of Ships io', embed: 'https://www.onlinegames.io/games/2022/unity3/war-of-ships-io/index.html', image: 'https://www.onlinegames.io/media/posts/509/responsive/War-of-Ships-io-xs.jpg' },
      { title: 'Baby Beauty Salon', embed: 'https://www.onlinegames.io/games/2021/2/baby-beauty-salon/index.html', image: 'https://www.onlinegames.io/media/posts/774/responsive/Baby-Beauty-Salon-xs.jpg' },
      { title: 'Solitaire Adventure', embed: 'https://www.onlinegames.io/games/2022/unity4/solitaire-adventure/index.html', image: 'https://www.onlinegames.io/media/posts/519/responsive/Solitaire-Adventure-Tripeaks-xs.jpg' },
      { title: 'Kawaii Shooter', embed: 'https://cloud.onlinegames.io/games/2024/unity/kawaii-shooter/index-og.html', image: 'https://www.onlinegames.io/media/posts/844/responsive/Kawaii-Shooter-xs.jpg' },
      { title: 'Draw The Bridge', embed: 'https://www.onlinegames.io/games/2021/4/draw-the-bridge/index.html', image: 'https://www.onlinegames.io/media/posts/164/responsive/Draw-the-Bridge-Game-xs.jpg' },
      { title: 'Mad Doctor', embed: 'https://www.onlinegames.io/games/2021/4/mad-doctor/index.html', image: 'https://www.onlinegames.io/media/posts/494/responsive/Mad-Doctor-xs.jpg' },
      { title: 'Pets Beauty Salon', embed: 'https://www.onlinegames.io/games/2021/2/pets-beauty-salon/index.html', image: 'https://www.onlinegames.io/media/posts/474/responsive/Pets-Beauty-Salon-xs.jpg' },
      { title: 'Speed Drift Racing', embed: 'https://www.onlinegames.io/games/2022/construct/124/speed-drift-racing/index.html', image: 'https://www.onlinegames.io/media/posts/801/responsive/Speed-Drift-Racing-xs.jpg' },
      { title: 'Princesses Prom Night', embed: 'https://www.onlinegames.io/games/2021/3/princesses-prom-night/index.html', image: 'https://www.onlinegames.io/media/posts/498/responsive/Princesses-Prom-Night-xs.jpg' },
      { title: 'Zombie War Defense', embed: 'https://www.onlinegames.io/games/2022/unity/zombie-war-defense/index.html', image: 'https://www.onlinegames.io/media/posts/466/responsive/Zombie-War-Defense-Game-xs.jpg' },
      { title: 'Princess Beauty Salon', embed: 'https://www.onlinegames.io/games/2021/1/princess-beauty-salon/index.html', image: 'https://www.onlinegames.io/media/posts/525/responsive/Princess-Beauty-Salon-xs.jpg' },
      { title: 'Skateboard Marathon', embed: 'https://www.onlinegames.io/games/2022/unity3/skateboard-marathon/index.html', image: 'https://www.onlinegames.io/media/posts/518/responsive/Skateboard-Marathon-xs.jpg' },
      { title: 'Head Soccer Football', embed: 'https://www.onlinegames.io/games/2022/unity/head-soccer-football/index.html', image: 'https://www.onlinegames.io/media/posts/482/responsive/Head-Soccer-Football-xs.jpg' },
      { title: 'First Day of School', embed: 'https://www.onlinegames.io/games/2021/3/first-day-of-school/index.html', image: 'https://www.onlinegames.io/media/posts/514/responsive/First-Day-of-School-xs.jpg' },
      { title: 'Army Driver', embed: 'https://www.onlinegames.io/games/2022/construct/63/army-driver/index.html', image: 'https://www.onlinegames.io/media/posts/424/responsive/Army-Driver-xs.jpg' },
      { title: 'Unicorn Beauty Salon', embed: 'https://www.onlinegames.io/games/2021/1/unicorn-beauty-salon/index.html', image: 'https://www.onlinegames.io/media/posts/517/responsive/Unicorn-Beauty-Salon-xs.jpg' },
      { title: 'War Simulator', embed: 'https://www.onlinegames.io/games/2021/unity2/war-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/821/responsive/War-Simulator-xs.jpg' },
      { title: 'Apocalypse Truck', embed: 'https://cloud.onlinegames.io/games/2021/1/apocalypse-truck/index-og.html', image: 'https://www.onlinegames.io/media/posts/1015/responsive/apocalypse-truck-xs.jpg' },
      { title: 'Cross the Road', embed: 'https://www.onlinegames.io/games/2023/unity/cross-the-road/index.html', image: 'https://www.onlinegames.io/media/posts/734/responsive/Cross-the-Road-xs.jpg' },
      { title: 'Draw Here', embed: 'https://www.onlinegames.io/games/2021/unity2/draw-here/index.html', image: 'https://www.onlinegames.io/media/posts/567/responsive/Draw-Here-xs.jpg' },
      { title: 'Highway Moto', embed: 'https://cloud.onlinegames.io/games/2024/unity/highway-moto/index-og.html', image: 'https://www.onlinegames.io/media/posts/851/responsive/highway-moto-xs.jpg' },
      { title: 'Train Racing', embed: 'https://www.onlinegames.io/games/2022/construct/120/train-racing/index.html', image: 'https://www.onlinegames.io/media/posts/445/responsive/Train-Racing-Game-xs.jpg' },
      { title: 'Draw the Truck Bridge', embed: 'https://www.onlinegames.io/games/2022/construct/149/draw-the-truck-bridge/index.html', image: 'https://www.onlinegames.io/media/posts/724/responsive/Draw-the-Truck-Bridge-xs.jpg' },
      { title: 'Blocky Blast', embed: 'https://www.onlinegames.io/games/2022/unity3/blocky-blast/index.html', image: 'https://www.onlinegames.io/media/posts/551/responsive/Blocky-Blast-xs.jpg' },
      { title: 'Trains io', embed: 'https://www.onlinegames.io/games/2023/construct/235/trains-io/index.html', image: 'https://www.onlinegames.io/media/posts/470/responsive/Trains-io-Game-xs.jpg' },
      { title: 'Monster Truck Race Arena', embed: 'https://cloud.onlinegames.io/games/2021/3/monster-truck-race-arena/index-og.html', image: 'https://www.onlinegames.io/media/posts/996/responsive/Monster-Truck-Race-Arena-xs.jpg' },
      { title: 'Idle Restaurant', embed: 'https://www.onlinegames.io/games/2023/unity2/idle-restaurant/index.html', image: 'https://www.onlinegames.io/media/posts/453/responsive/Idle-Restaurant-xs.jpg' },
      { title: 'Nova Billiard', embed: 'https://www.onlinegames.io/games/2021/unity2/nova-billiard/index.html', image: 'https://www.onlinegames.io/media/posts/456/responsive/Nova-Billiard-Game-xs.jpg' },
      { title: 'Dockyard Tank Parking', embed: 'https://www.onlinegames.io/games/2021/unity/dockyard-tank-parking/index.html', image: 'https://www.onlinegames.io/media/posts/603/responsive/Dockyard-Tank-Parking-xs.jpg' },
      { title: 'Pyramid Solitaire', embed: 'https://cloud.onlinegames.io/games/2025/html/solitaire/index-og.html#pyramid', image: 'https://www.onlinegames.io/media/posts/1006/responsive/pyramid-Solitaire-xs.jpg' },
      { title: 'The Farmer', embed: 'https://www.onlinegames.io/games/2022/unity/the-farmer/index.html', image: 'https://www.onlinegames.io/media/posts/533/responsive/The-Farmer-xs.jpg' },
      { title: 'Owl and Rabbit Fashion', embed: 'https://www.onlinegames.io/games/2021/2/owl-and-rabbit-fashion/index.html', image: 'https://www.onlinegames.io/media/posts/475/responsive/Owl-and-Rabbit-Fashion-xs.jpg' },
      { title: 'Snake Wars', embed: 'https://www.onlinegames.io/games/2024/unity/snake-wars/index.html', image: 'https://www.onlinegames.io/media/posts/638/responsive/Snake-Wars-Free-Game-xs.jpg' },
      { title: 'Zombie Road', embed: 'https://www.onlinegames.io/games/2021/unity2/zombie-road/index.html', image: 'https://www.onlinegames.io/media/posts/631/responsive/Zombie-Road-xs.jpg' },
      { title: 'ToonZ io', embed: 'https://www.onlinegames.io/games/2021/unity3/toonz-io/index.html', image: 'https://www.onlinegames.io/media/posts/230/responsive/Toonz-io-Game-xs.jpg' },
      { title: 'Paradise Girls', embed: 'https://www.onlinegames.io/games/2021/4/paradise-girls/index.html', image: 'https://www.onlinegames.io/media/posts/556/responsive/Pradise-Girls-xs.jpg' },
      { title: 'Darkness Survivors', embed: 'https://www.onlinegames.io/games/2024/q2/darkness-survivors/index.html', image: 'https://www.onlinegames.io/media/posts/696/responsive/Darkness-Survivors-xs.jpg' },
      { title: 'Monster Truck Booster', embed: 'https://cloud.onlinegames.io/games/2024/construct/223/monster-truck-booster/index-og.html', image: 'https://www.onlinegames.io/media/posts/925/responsive/monster-truck-booster-xs.jpg' },
      { title: 'Jul Moto Racing ', embed: 'https://cloud.onlinegames.io/games/2022/construct/122/jul-moto-racing/index-og.html', image: 'https://www.onlinegames.io/media/posts/1041/responsive/jul_moto_racing_game-2-xs.webp' },
      { title: 'Funny Shooter Bro', embed: 'https://www.onlinegames.io/games/2024/unity/funny-shooter-bro/index.html', image: 'https://www.onlinegames.io/media/posts/735/responsive/Funny-Shooter-Bro-xs.jpg' },
      { title: 'Tank Racing', embed: 'https://www.onlinegames.io/games/2022/construct/151/tank-racing/index.html', image: 'https://www.onlinegames.io/media/posts/484/responsive/Tank-Racing-Online-xs.jpg' },
      { title: 'Squid Race Simulator', embed: 'https://www.onlinegames.io/games/2021/unity3/squid-race-simulator/index.html', image: 'https://www.onlinegames.io/media/posts/950/responsive/squid-race-simulator-xs.jpg' },
      { title: 'Mafia Getaway Cars', embed: 'https://cloud.onlinegames.io/games/2025/construct/298/mafia-getaway-cars/index-og.html', image: 'https://www.onlinegames.io/media/posts/982/responsive/Mafia-Getaway-Cars-xs.jpg' },
      { title: 'Rescue Helicopter', embed: 'https://www.onlinegames.io/games/2021/2/rescue-helicopter/index.html', image: 'https://www.onlinegames.io/media/posts/468/responsive/Rescue-Helicopter-xs.jpg' },
      { title: 'Racing Cars', embed: 'https://www.onlinegames.io/games/2021/1/racing-cars/index.html', image: 'https://www.onlinegames.io/media/posts/661/responsive/Racing-Cars-xs.jpg' },
      { title: 'Monster Truck Racing', embed: 'https://www.onlinegames.io/games/2021/1/monster-truck-racing/index.html', image: 'https://www.onlinegames.io/media/posts/826/responsive/Monster-Truck-Racing-xs.jpg' },
      { title: 'Space Crew Mystery', embed: 'https://www.onlinegames.io/games/2023/construct/234/among-impostor/index.html', image: 'https://www.onlinegames.io/media/posts/472/responsive/Among-Impostor-xs.jpg' },
      { title: 'Speedrun Parkour', embed: 'https://www.onlinegames.io/games/2022/construct/145/speedrun-parkour/index.html', image: 'https://www.onlinegames.io/media/posts/759/responsive/Speedrun-Parkour-xs.jpg' },
      { title: 'Truck Racing', embed: 'https://www.onlinegames.io/games/2022/construct/144/truck-racing/index.html', image: 'https://www.onlinegames.io/media/posts/712/responsive/Truck-Racing-xs.jpg' },
      { title: 'Crazy Ball Adventures', embed: 'https://www.onlinegames.io/games/2021/unity2/crazy-ball-adventures/index.html', image: 'https://www.onlinegames.io/media/posts/760/responsive/Crazy-Ball-Game-xs.jpg' },
      { title: 'Beat Rush', embed: 'https://www.onlinegames.io/games/2023/construct/279/geometry-rash/index.html', image: 'https://www.onlinegames.io/media/posts/616/responsive/Geometry-Rash-xs.jpg' },
      { title: 'Legends Arena', embed: 'https://www.onlinegames.io/games/2023/unity2/legends-arena/index.html', image: 'https://www.onlinegames.io/media/posts/608/responsive/Legends-Arena-xs.jpg' },
      { title: 'Sweet Sugar Match', embed: 'https://www.onlinegames.io/games/2022/unity/sweet-sugar-match/index.html', image: 'https://www.onlinegames.io/media/posts/576/responsive/Sweet-Sugar-Match-xs.jpg' },
      { title: 'Racing Cars 2', embed: 'https://www.onlinegames.io/games/2021/4/racing-cars-2/index.html', image: 'https://www.onlinegames.io/media/posts/762/responsive/Racing-Cars-2-xs.jpg' },
      { title: 'Draw the Bird Path', embed: 'https://www.onlinegames.io/games/2022/construct/147/draw-the-bird-path/index.html', image: 'https://www.onlinegames.io/media/posts/587/responsive/Draw-the-Bird-Path-xs.jpg' },
      { title: 'Egg Helix', embed: 'https://www.onlinegames.io/games/2022/unity2/egg-helix/index.html', image: 'https://www.onlinegames.io/media/posts/604/responsive/Egg-Helix-xs.jpg' },
      { title: 'Mr Space Bullet', embed: 'https://www.onlinegames.io/games/2021/4/mr-space-bullet/index.html', image: 'https://www.onlinegames.io/media/posts/707/responsive/Mr-Space-Bullet-xs.jpg' },
      { title: 'Crazy Hill Climb', embed: 'https://www.onlinegames.io/games/2023/construct/209/crazy-hill-climb/index.html', image: 'https://www.onlinegames.io/media/posts/520/responsive/Crazy-Hill-Climb-xs.jpg' },
      { title: 'Treasure Hunter', embed: 'https://www.onlinegames.io/games/2022/construct/164/treasure-hunter/index.html', image: 'https://www.onlinegames.io/media/posts/812/responsive/Treasure-Hunter-xs.jpg' },
      { title: 'Dino Chaos Idle', embed: 'https://www.onlinegames.io/games/2023/unity3/dino-chaos-idle/index.html', image: 'https://www.onlinegames.io/media/posts/614/responsive/Dino-Chaos-Idle-xs.jpg' },
      { title: 'Kick the Pirate', embed: 'https://cloud.onlinegames.io/games/2022/construct/92/kick-the-pirate/index-og.html', image: 'https://www.onlinegames.io/media/posts/1012/responsive/Kick-The-Pirate-xs.jpg' },
      { title: 'Hill Climb Cars', embed: 'https://www.onlinegames.io/games/2021/3/hill-climb-cars/index.html', image: 'https://www.onlinegames.io/media/posts/648/responsive/Hill-Climb-Cars-xs.jpg' },
      { title: 'Run 3 Space', embed: 'https://www.onlinegames.io/games/2023/construct/192/run-3-space/index.html', image: 'https://www.onlinegames.io/media/posts/579/responsive/Run-3-Space-xs.jpg' },
      { title: 'Descent Runner', embed: 'https://game.azgame.io/slope-rider/', image: 'https://azgames.io/upload/cache/upload/imgs/sloperider4-m200x200.webp' },
      { title: 'Wacky Flip', embed: 'https://game.azgame.io/wacky-flip/', image: 'https://azgames.io/upload/cache/upload/imgs/wackyflip-m180x180.png' },
      { title: 'Steal Brainrots', embed: 'https://gamea.azgame.io/steal-brainrots/', image: 'https://azgames.io/upload/cache/upload/imgs/stealbrainrots3-m180x180.png' },
      { title: 'Escape Road', embed: 'https://azgames.io/escape-road.embed', image: 'https://azgames.io/upload/cache/upload/imgs/escaperoad-m180x180.png' },
      { title: 'Curve Rush', embed: 'https://game.azgame.io/curve-rush/', image: 'https://azgames.io/upload/cache/upload/imgs/curverush2-m180x180.png' },
      { title: 'Traffic Road', embed: 'https://azgames.io/traffic-road.embed', image: 'https://azgames.io/upload/cache/upload/imgs/trafficroad-m180x180.png' },
      { title: 'Italian Brainrot Clicker 2', embed: 'https://game.azgame.io/italian-brainrot-clicker-2/', image: 'https://azgames.io/upload/cache/upload/imgs/italianbrainrotclicker3-m180x180.png' },
      { title: 'Undead Corridor', embed: 'https://gamea.azgame.io/undead-corridor/', image: 'https://azgames.io/upload/cache/upload/imgs/undeadcorridor2-m200x200.webp' },
      { title: 'Golf Hit', embed: 'https://game.azgame.io/golf-hit/', image: 'https://azgames.io/upload/cache/upload/imgs/golfhit2-m180x180.png' },
      { title: 'Geometry Dash Lite', embed: 'https://gamecomets.com/game/geometry-dash-lite/', image: 'https://www.onlinegames.io/media/posts/510/responsive/Geometry-Dash-FreezeNova-xs.jpg' },
    { title: 'Slope Rider', embed: 'https://game.azgame.io/slope-rider/', image: 'https://azgames.io/upload/cache/upload/imgs/sloperider4-m180x180.png' }
]);
  
  
  // Fuzzy search function for game titles
  function fuzzySearch(query, text) {
      if (!query) return true;
      query = query.toLowerCase();
      text = text.toLowerCase();
      
      // Exact match gets highest priority
      if (text.includes(query)) return true;
      
      // Check if all characters in query appear in order in text
      let queryIndex = 0;
      for (let i = 0; i < text.length && queryIndex < query.length; i++) {
          if (text[i] === query[queryIndex]) {
              queryIndex++;
          }
      }
      return queryIndex === query.length;
  }
  
  // Calculate similarity score for sorting
  function calculateSimilarity(query, text) {
      query = query.toLowerCase();
      text = text.toLowerCase();
      
      if (text === query) return 100;
      if (text.startsWith(query)) return 90;
      if (text.includes(query)) return 80;
      
      // Count matching characters in order
      let matches = 0;
      let queryIndex = 0;
      for (let i = 0; i < text.length && queryIndex < query.length; i++) {
          if (text[i] === query[queryIndex]) {
              matches++;
              queryIndex++;
          }
      }
      
      return (matches / query.length) * 70;
  }
  
  // Helper function to create big-game-cube HTML (image-only with hover effects)
  function createBigGameCubeHTML(game, index, gameKey, ratingData, isDraggable = false) {
      const filename = `game-${game.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')}.html`;
      const avgRating = ratingData.average || 0;
      const ratingDisplay = avgRating > 0 ? avgRating.toFixed(1) : 'New';
      const draggableAttr = isDraggable ? 'draggable="true"' : '';
      const dragClass = isDraggable ? ' admin-draggable' : '';
      
      // Fix image path - if image is missing or empty, try to get it from gameSites
      let imageUrl = game.image || '';
      if (!imageUrl || imageUrl.trim() === '') {
          // Try to find the game in gameSites by embed URL
          if (typeof gameSites !== 'undefined' && gameSites && gameSites.length > 0) {
              const foundGame = gameSites.find(site => site.embed === game.embed);
              if (foundGame && foundGame.image) {
                  imageUrl = foundGame.image;
              }
          }
      }
      
      // Ensure image URL is valid for CSS
      const imageStyle = imageUrl && imageUrl.trim() !== '' ? `background-image: url('${imageUrl}');` : '';
      
      // Get game description
      const description = getGameDescription ? getGameDescription(game) : (game.description || '');
      const shortDescription = description.length > 120 ? description.substring(0, 120) + '...' : description;
      
      return `
          <div class="big-game-cube${dragClass}" data-embed="${game.embed}" data-title="${game.title}" data-filename="${filename}" data-game-key="${gameKey}" data-description="${description}" ${draggableAttr} style="${imageStyle} animation-delay: ${index * 0.03}s;">
              <div class="big-game-cube-gradient-ring"></div>
              <div class="big-game-cube-hover-overlay">
                  <div class="big-game-cube-title-overlay">${game.title}</div>
                  <div class="big-game-cube-rating-overlay">
                      ${avgRating > 0 ? `<i class="fas fa-star"></i> ${ratingDisplay}` : '<span>New</span>'}
                  </div>
                  ${description ? `<div class="big-game-cube-description-overlay">${shortDescription}</div>` : ''}
              </div>
              <div class="big-game-cube-gold-ring"></div>
              ${isDraggable ? '<div class="admin-drag-indicator"><i class="fas fa-grip-vertical"></i></div>' : ''}
          </div>
      `;
  }
  
  // Filter and render games
  // Render games in a specific container (for search results on main page)
  function renderGamesGridInContainer(filteredGames = null, container) {
      if (!container) return;
      
      const gamesToRender = filteredGames || gameSites;
      
      container.innerHTML = gamesToRender.map((site, index) => {
          const gameKey = getGameKey(site.embed);
          const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
          return createBigGameCubeHTML(site, index, gameKey, ratingData);
      }).join('');
      
        // Helper function to convert title to filename
        function titleToFilename(title) {
            return title.toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-|-$/g, '');
        }
      
      // Helper function to get correct games path based on current location
      function getGamesPath(filename) {
          const isInPagesFolder = window.location.pathname.includes('/pages/');
          return isInPagesFolder ? `../games/${filename}` : `games/${filename}`;
      }

        // Add click handlers - navigate to individual game pages
        container.querySelectorAll('.big-game-cube').forEach(cube => {
            cube.addEventListener('click', (e) => {
                const embed = cube.getAttribute('data-embed');
                const title = cube.getAttribute('data-title') || 'Game';
                openGamePageOrInline(embed, title);
            });
        });
    }
  
  function renderGamesGrid(filteredGames = null, resetPagination = false) {
      const gamesGrid = document.getElementById('gamesGrid');
      if (!gamesGrid) {
          console.warn('gamesGrid element not found in DOM');
          return;
      }
      
      const gamesToRender = filteredGames || gameSites;
      
      if (!gamesToRender || gamesToRender.length === 0) {
          console.warn('No games to render');
          gamesGrid.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">No games found. Please try refreshing the page.</p>';
          const loadMoreContainer = document.getElementById('loadMoreContainer');
          if (loadMoreContainer) loadMoreContainer.style.display = 'none';
          return;
      }
      
      // Check if we're on all-games page
      const isAllGamesPage = window.location.pathname.includes('all-games.html') || 
                            window.location.pathname.endsWith('all-games.html') ||
                            window.location.pathname.includes('/pages/all-games') ||
                            window.location.href.includes('all-games.html');
      
      // Handle pagination for all-games page
      // Skip pagination if filteredGames is provided (search results) - if filteredGames is passed, it means we're showing search results
      const isSearchResults = filteredGames !== null;
      
      if (isAllGamesPage && !isSearchResults) {
          if (resetPagination) {
              gamesDisplayedCount = 0;
              allGamesList = gamesToRender;
          }
          
          const gamesToShow = allGamesList.slice(0, gamesDisplayedCount + GAMES_PER_PAGE);
          gamesDisplayedCount = gamesToShow.length;
          
          // Show/hide load more button
          const loadMoreContainer = document.getElementById('loadMoreContainer');
          const loadMoreBtn = document.getElementById('loadMoreBtn');
          if (loadMoreContainer && loadMoreBtn) {
              if (gamesDisplayedCount >= allGamesList.length) {
                  loadMoreContainer.style.display = 'none';
              } else {
                  loadMoreContainer.style.display = 'flex';
                  loadMoreBtn.onclick = () => {
                      renderGamesGrid(null, false);
                  };
              }
          }
          
          console.log('Rendering', gamesToShow.length, 'of', allGamesList.length, 'games');
          
          // Load saved game order for admin
          let orderedGames = gamesToShow;
          if (isAdminAuthenticated) {
              const savedOrder = localStorage.getItem('adminGameOrder');
              if (savedOrder) {
                  try {
                      const orderArray = JSON.parse(savedOrder);
                      // Reorder games based on saved order
                      const gamesMap = new Map(gamesToShow.map(game => [getGameKey(game.embed), game]));
                      orderedGames = orderArray
                          .map(key => gamesMap.get(key))
                          .filter(Boolean)
                          .concat(gamesToShow.filter(game => !orderArray.includes(getGameKey(game.embed))));
                  } catch (e) {
                      console.error('Error loading saved game order:', e);
                  }
              }
          }
          
          gamesGrid.innerHTML = orderedGames.map((site, index) => {
          const gameKey = getGameKey(site.embed);
          const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
          return createBigGameCubeHTML(site, index, gameKey, ratingData, isAdminAuthenticated);
          }).join('');
          
          // Add drag-and-drop functionality if admin
          if (isAdminAuthenticated) {
              initDragAndDrop(gamesGrid, orderedGames);
          }
      } else if (isAllGamesPage && isSearchResults) {
          // Search results - show all results without pagination
          const loadMoreContainer = document.getElementById('loadMoreContainer');
          if (loadMoreContainer) {
              loadMoreContainer.style.display = 'none';
          }
          
          console.log('Rendering all search results:', gamesToRender.length, 'games');
          gamesGrid.innerHTML = gamesToRender.map((site, index) => {
              const gameKey = getGameKey(site.embed);
              const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
              return createBigGameCubeHTML(site, index, gameKey, ratingData);
          }).join('');
      } else {
          // Not on all-games page, render all games
          console.log('Rendering', gamesToRender.length, 'games');
          gamesGrid.innerHTML = gamesToRender.map((site, index) => {
              const gameKey = getGameKey(site.embed);
              const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
              return createBigGameCubeHTML(site, index, gameKey, ratingData);
          }).join('');
      }
      
      // Helper function to convert title to filename
      function titleToFilename(title) {
          return title.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-|-$/g, '');
      }
      
      // Helper function to get correct games path based on current location
      function getGamesPath(filename) {
          const isInPagesFolder = window.location.pathname.includes('/pages/');
          return isInPagesFolder ? `../games/${filename}` : `games/${filename}`;
      }
      
        // Add click handlers - navigate to individual game pages
        gamesGrid.querySelectorAll('.big-game-cube').forEach(cube => {
            cube.addEventListener('click', (e) => {
                // Don't navigate if dragging
                if (cube.classList.contains('dragging')) {
                    return;
                }
                // Navigate to game page
                const embed = cube.getAttribute('data-embed');
                const title = cube.getAttribute('data-title');
                if (title && title.toLowerCase().includes('clash royale')) {
                    alert('You need to make or log into a Clash Royale account before playing.');
                }
                
                openGamePageOrInline(embed, title || 'Game');
            });
        });
      
      // Add rating click handlers
      gamesGrid.querySelectorAll('.game-cube-stars .fa-star').forEach(star => {
          star.addEventListener('click', (e) => {
              e.stopPropagation();
              const rating = parseInt(star.getAttribute('data-rating'));
              const ratingContainer = star.closest('.game-cube-rating');
              const embed = ratingContainer.getAttribute('data-embed');
              const gameKey = ratingContainer.getAttribute('data-game-key');
              
              // Update UI immediately
              updateRatingDisplay(ratingContainer, rating, gameKey);
              
              // Submit to Firebase
              submitGameRating(gameKey, embed, rating);
          });
      });
  }
  
  // Load games from JSON and categorize
  // Note: allGamesFromJSON and categorizedGames are already declared at the top of the file
  
  // Helper: determine if an entry is really a collection/category placeholder (not a playable game)
  function isCollectionEntry(game) {
      const title = (game.title || '').trim().toLowerCase();
      const blacklistTitles = [
          'sports games',
          'casual games',
          'adventure games',
          'io games',
          'azgames portal',
          'trending games'
      ];
      const isBlacklistedTitle = blacklistTitles.includes(title);
      const embed = game.embed || '';
      const isCategoryEmbed = /azgame\.io\/category\//i.test(embed) ||
                              /azgames\.io\/category\//i.test(embed) ||
                              /azgame\.io\/trending-games/i.test(embed) ||
                              /azgames\.io\/trending-games/i.test(embed) ||
                              /azgames\.io\/?$/i.test(embed);
      return isBlacklistedTitle || isCategoryEmbed;
  }
  
  // Helper: check if a game is disabled
  function isDisabledGame(game) {
      return game && game.disabled === true;
  }
  
  async function loadGamesFromJSON() {
      console.time('loadGamesFromJSON');
      try {
          // Determine the correct path based on current page location
          const isInPagesFolder = window.location.pathname.includes('/pages/') || window.location.pathname.includes('/games/');
          const gamesJsonPath = isInPagesFolder ? '../data/games.json' : 'data/games.json';
          const response = await fetch(gamesJsonPath);
        const loadedGames = await response.json();
        allGamesFromJSON = loadedGames;
        
        // Convert to gameSites format and merge with existing, skipping category/portal placeholders
        const jsonGames = [];
        loadedGames.forEach((game, idx) => {
            if (isCollectionEntry(game)) return;
            jsonGames.push({
                title: game.title,
                embed: game.embed,
                image: game.image,
                tags: game.tags || '',
                description: game.description || '',
                addedIndex: idx
            });
        });
        
        // Merge with existing gameSites (prioritize JSON data)
        const existingEmbeds = new Set(jsonGames.map(g => g.embed));
        const additionalGames = gameSites
            .filter(g => !existingEmbeds.has(g.embed) && !isCollectionEntry(g))
            .map((g, idx) => ({ ...g, addedIndex: jsonGames.length + idx }));
        const combinedGames = [...jsonGames, ...additionalGames];
        gameSites = ensureAccurateDescriptions(combinedGames);
          
          // Initialize categories if not already initialized
          if (Object.keys(gameCategories).length === 0) {
            initializeGameCategories();
          }
          
          // Categorize games
          categorizeAllGames();
          
          // Initialize featured sections on homepage
          if (document.getElementById('featuredGamesSections')) {
              renderFeaturedSections();
          } else {
              // Fallback to old system if featured sections don't exist
              filterGamesByCategory('trending');
          }
          // Always try to render the mini Game of the Season cube if its container exists
          if (document.getElementById('slopeRiderCenterCard')) {
              renderSlopeRiderCenterCard();
          }
          
          return Promise.resolve();
      } catch (error) {
          console.error('Error loading games from JSON:', error);
          // Fallback to existing gameSites - add tags to them
          // Check if gameSites is initialized before using it
          if (typeof gameSites !== 'undefined' && gameSites && gameSites.length > 0) {
              gameSites = ensureAccurateDescriptions(gameSites.filter(g => !isCollectionEntry(g)));
          
          if (document.getElementById('featuredGamesSections')) {
              // Initialize categories if not already initialized
              if (Object.keys(gameCategories).length === 0) {
                initializeGameCategories();
              }
              categorizeAllGames();
              renderFeaturedSections();
          } else {
              filterGamesByCategory('trending');
          }
          if (document.getElementById('slopeRiderCenterCard')) {
              renderSlopeRiderCenterCard();
          }
          } else {
              console.warn('gameSites not initialized, cannot add tags');
              // Try to use the initial gameSites array if it exists
              if (typeof gameSites !== 'undefined' && gameSites && gameSites.length > 0) {
                  gameSites = ensureAccurateDescriptions(gameSites.filter(g => !isCollectionEntry(g)));
                  // Initialize categories if not already initialized
                  if (Object.keys(gameCategories).length === 0) {
                    initializeGameCategories();
                  }
                  // Just render what we have
                  if (document.getElementById('featuredGamesSections')) {
                      categorizeAllGames();
                      renderFeaturedSections();
                  }
                  if (document.getElementById('slopeRiderCenterCard')) {
                      renderSlopeRiderCenterCard();
                  }
              }
          }
          
          return Promise.resolve();
      }
  }

  // Helper constants/functions to keep "New" lists consistent across pages
  const RECENT_NEW_GAMES_COUNT = 80;
  const PRIORITY_NEW_EMBEDS = new Set([
      'https://azgames.io/tap-road.embed',
      'https://game.azgame.io/color-rush/',
      'https://azgames.io/retro-bowl.embed',
      'games/game-slime-rancher.html',
      'games/game-clash-royale.html'
  ]);
  // Explicit priority order for the "New This Week" strip (lower index = earlier)
  const PRIORITY_NEW_ORDER = [
      'https://azgames.io/tap-road.embed',
      'games/game-clash-royale.html',
      'https://game.azgame.io/color-rush/',
      'https://azgames.io/retro-bowl.embed',
      'games/game-slime-rancher.html'
  ];
  
  function isNewGameEntry(game, totalPlayableCount) {
      const totalGames = typeof totalPlayableCount === 'number' ? totalPlayableCount : (gameSites ? gameSites.length : 0);
      const cutoffIndex = Math.max(0, totalGames - RECENT_NEW_GAMES_COUNT);
      const addedIndex = typeof game.addedIndex === 'number' ? game.addedIndex : -1;
      const title = game.title || '';
      const assignedCategory = STATIC_GAME_CATEGORIES[title];
      const hasNewTag = (game.tags || '').toLowerCase().includes('new') || assignedCategory === 'new';
      const isPriority = PRIORITY_NEW_EMBEDS.has(game.embed);
      const isRecentAdd = addedIndex >= cutoffIndex;
      return isPriority || hasNewTag || isRecentAdd;
  }
  
  // Remove duplicate entries by embed (fallback to title if embed missing)
  function dedupeByEmbed(list = []) {
      const seen = new Set();
      return list.filter(item => {
          const key = item.embed || item.title;
          if (!key) return false;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
      });
  }
  
  function categorizeAllGames() {
      categorizedGames = {
          racing: [],
          puzzle: [],
          action: [],
          strategy: [],
          adventure: [],
          shooting: [],
          sports: [],
          simulation: [],
          new: [],
          popular: []
      };
      
      // Use the global gameCategories object (loaded from Firebase)
      // This is already loaded and kept in sync via the Firebase listener
      
      const playableGames = gameSites.filter(g => !isCollectionEntry(g));
      const totalGames = playableGames.length;
      
      playableGames.forEach((game, index) => {
          const tags = (game.tags || '').toLowerCase();
          const stats = getGameStats(game.embed);
          const gameKey = getGameKey(game.embed);
          const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
          
          // Get rating data - check both gameRatings and game object
          const finalRatingData = game.rating !== undefined ? 
              { average: game.rating, count: game.ratingCount || 0 } : 
              ratingData;
          
          const gameWithData = {
              ...game,
              clicks: stats ? stats.clicks : 0,
              rating: finalRatingData.average || 0,
              ratingCount: finalRatingData.count || 0,
              index: index,
              addedIndex: game.addedIndex !== undefined ? game.addedIndex : index
          };
          
          // Check if game has an assigned category (from static mapping)
          // Look up by game title since static mapping uses titles as keys
          const gameTitle = game.title || '';
          const assignedCategory = STATIC_GAME_CATEGORIES[gameTitle];
          
          // Always add to assigned category if it exists and is valid
          if (assignedCategory && assignedCategory !== 'none' && categorizedGames.hasOwnProperty(assignedCategory)) {
              categorizedGames[assignedCategory].push(gameWithData);
          }
          
          // Also categorize by tags (games can appear in multiple categories)
          // This ensures games show up in relevant sections even if they have an assigned category
          if (tags.includes('racing') || tags.includes('drift') || tags.includes('driving') || tags.includes('car')) {
              // Only add to racing if not already added via assigned category, or if assigned category is different
              if (assignedCategory !== 'racing') {
                  categorizedGames.racing.push(gameWithData);
              }
          }
          if (tags.includes('puzzle') || tags.includes('brain') || tags.includes('logic') || tags.includes('match')) {
              if (assignedCategory !== 'puzzle') {
                  categorizedGames.puzzle.push(gameWithData);
              }
          }
          if (tags.includes('action') || tags.includes('arcade') || tags.includes('battle')) {
              if (assignedCategory !== 'action') {
                  categorizedGames.action.push(gameWithData);
              }
          }
          if (tags.includes('strategy') || tags.includes('tower-defense') || tags.includes('defense')) {
              if (assignedCategory !== 'strategy') {
                  categorizedGames.strategy.push(gameWithData);
              }
          }
          if (tags.includes('adventure') || tags.includes('parkour') || tags.includes('platformer')) {
              if (assignedCategory !== 'adventure') {
                  categorizedGames.adventure.push(gameWithData);
              }
          }
          if (tags.includes('shooting') || tags.includes('sniper') || tags.includes('fps') || tags.includes('gun')) {
              if (assignedCategory !== 'shooting') {
                  categorizedGames.shooting.push(gameWithData);
              }
          }
          if (tags.includes('sports') || tags.includes('basketball') || tags.includes('football') || tags.includes('soccer')) {
              if (assignedCategory !== 'sports') {
                  categorizedGames.sports.push(gameWithData);
              }
          }
          if (tags.includes('simulator') || tags.includes('simulation') || tags.includes('tycoon')) {
              if (assignedCategory !== 'simulation') {
                  categorizedGames.simulation.push(gameWithData);
              }
          }
          
          // New games (recently added or explicitly tagged)
          if (isNewGameEntry(gameWithData, totalGames)) {
              categorizedGames.new.push(gameWithData);
          }
          
          // Add all games to popular category (will be sorted by rating)
          categorizedGames.popular.push(gameWithData);
      });
      
      // Dedupe each category to avoid repeated tiles, then sort
      categorizedGames.racing = dedupeByEmbed(categorizedGames.racing)
          .sort((a, b) => (b.rating * b.ratingCount) - (a.rating * a.ratingCount));
      categorizedGames.puzzle = dedupeByEmbed(categorizedGames.puzzle)
          .sort((a, b) => (b.rating * b.ratingCount) - (a.rating * a.ratingCount));
      categorizedGames.action = dedupeByEmbed(categorizedGames.action)
          .sort((a, b) => b.clicks - a.clicks);
      categorizedGames.strategy = dedupeByEmbed(categorizedGames.strategy)
          .sort((a, b) => (b.rating * b.ratingCount) - (a.rating * a.ratingCount));
      categorizedGames.adventure = dedupeByEmbed(categorizedGames.adventure)
          .sort((a, b) => b.clicks - a.clicks);
      categorizedGames.shooting = dedupeByEmbed(categorizedGames.shooting)
          .sort((a, b) => b.clicks - a.clicks);
      categorizedGames.sports = dedupeByEmbed(categorizedGames.sports)
          .sort((a, b) => (b.rating * b.ratingCount) - (a.rating * a.ratingCount));
      categorizedGames.simulation = dedupeByEmbed(categorizedGames.simulation)
          .sort((a, b) => b.clicks - a.clicks);
      // Sort popular games by highest rating first, then by number of reviews
      categorizedGames.popular = dedupeByEmbed(categorizedGames.popular).sort((a, b) => {
          // Primary sort: by rating (higher is better)
          if (a.rating !== b.rating) {
              return b.rating - a.rating;
          }
          // Secondary sort: by number of reviews (more reviews = more popular)
          if (a.ratingCount !== b.ratingCount) {
              return b.ratingCount - a.ratingCount;
          }
          // Tertiary sort: by clicks as tiebreaker
          return b.clicks - a.clicks;
      });
      // Sort new games: prioritize Tap Road, Color Rush, and Retro Bowl, then by index (newest first)
      categorizedGames.new = dedupeByEmbed(categorizedGames.new).sort((a, b) => {
          const rank = (embed) => {
              const idx = PRIORITY_NEW_ORDER.indexOf(embed);
              return idx === -1 ? Number.POSITIVE_INFINITY : idx;
          };
          const aRank = rank(a.embed);
          const bRank = rank(b.embed);
          if (aRank !== bRank) return aRank - bRank;
          
          const idxA = typeof a.addedIndex === 'number' ? a.addedIndex : -1;
          const idxB = typeof b.addedIndex === 'number' ? b.addedIndex : -1;
          if (idxA !== idxB) return idxB - idxA;
          
          // Tiebreaker: keep higher-rated new titles earlier
          if (a.rating !== b.rating) return b.rating - a.rating;
          return b.ratingCount - a.ratingCount;
      });
      // Force a hero/small/small/small/small/hero pattern for key new titles:
      // Slime Rancher first big cube, four smalls, then Clash Royale as next big cube.
      (() => {
          const list = [...categorizedGames.new];
          const pull = (embed) => {
              const idx = list.findIndex(g => g.embed === embed);
              return idx > -1 ? list.splice(idx, 1)[0] : null;
          };
          const slime = pull('games/game-slime-rancher.html');
          const clash = pull('games/game-clash-royale.html');
          let reordered = list;
          if (slime) reordered = [slime, ...reordered];
          if (clash) {
              const targetIndex = Math.min(5, reordered.length);
              reordered.splice(targetIndex, 0, clash);
          }
          categorizedGames.new = reordered;
      })();
  }

  // Helper: build a safe filename for game detail pages
  function getGameFilename(title = '') {
      const slug = (title || 'game')
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '')
          || 'game';
      return `game-${slug}.html`;
  }
  
  function renderFeaturedSections() {
      const container = document.getElementById('featuredGamesSections');
      if (!container) return;
      
      // Load recently played games from localStorage
      let recentlyPlayedGames = [];
      try {
          const stored = localStorage.getItem('recentlyPlayedGames');
          if (stored) {
              recentlyPlayedGames = JSON.parse(stored);
              // Games are stored with newest at index 0 (from unshift in saveToRecentlyPlayed)
              // So we don't need to reverse - most recent is already first
              // Keep as is for correct order (most recent on left)
              // Don't reverse - array is already [newest, ..., oldest]
              // Limit to 18 games
              recentlyPlayedGames = recentlyPlayedGames.slice(0, 18);
              // Fix image paths and ensure images are loaded from gameSites if missing
              recentlyPlayedGames = recentlyPlayedGames.map(game => {
                  let imageUrl = game.image || '';
                  // If image is missing, try to get it from gameSites
                  if (!imageUrl || imageUrl.trim() === '') {
                      if (typeof gameSites !== 'undefined' && gameSites && gameSites.length > 0) {
                          const foundGame = gameSites.find(site => site.embed === game.embed);
                          if (foundGame && foundGame.image) {
                              imageUrl = foundGame.image;
                          }
                      }
                  }
                  return { ...game, image: imageUrl };
              });
          }
      } catch (e) {
          console.error('Error loading recently played games:', e);
      }
      
      // Featured sections configuration
      const sections = [];
      
      // Add Recently Played section if there are any games
      if (recentlyPlayedGames.length > 0) {
          sections.push({
              title: '🕒 Recently Played',
              icon: 'fa-clock',
              games: recentlyPlayedGames,
              category: 'recently-played',
              link: 'pages/recently-played.html',
              hasClearButton: true
          });
      }
      
      // Add other sections
      sections.push(
          {
              title: '⭐ New This Week',
              icon: 'fa-star',
              games: categorizedGames.new.slice(0, 18),
              category: 'new',
              link: 'pages/games-new.html'
          },
          {
              title: '🔥 Most Popular',
              icon: 'fa-fire',
              games: categorizedGames.popular.slice(0, 18),
              category: 'popular',
              link: 'all-games.html?category=popular'
          },
          {
              title: '🏆 Top Rated Racing Games',
              icon: 'fa-trophy',
              games: categorizedGames.racing.slice(0, 18),
              category: 'racing',
              link: 'pages/games-racing.html'
          },
          {
              title: '🧩 Best Puzzle Games',
              icon: 'fa-puzzle-piece',
              games: categorizedGames.puzzle.slice(0, 18),
              category: 'puzzle',
              link: 'pages/games-puzzle.html'
          },
          {
              title: '🎯 Top Action Games',
              icon: 'fa-crosshairs',
              games: categorizedGames.action.slice(0, 18),
              category: 'action',
              link: 'pages/games-action.html'
          }
      );
      
      container.innerHTML = sections.map((section, sectionIndex) => {
          if (section.games.length === 0) return '';
          
          let gamesHTML = '';
          let gameIndex = 0;
          
          // Special handling for recently played section
          if (section.category === 'recently-played') {
              // First game (most recent) = big cube
              if (gameIndex < section.games.length) {
                  const bigGame = section.games[gameIndex];
                  const bigGameKey = getGameKey(bigGame.embed);
                  const bigRatingData = gameRatings[bigGameKey] || { average: 0, count: 0 };
                  gamesHTML += `<li class="primeCarouselLi">`;
                  gamesHTML += createBigGameCubeHTML(bigGame, gameIndex, bigGameKey, bigRatingData);
                  gamesHTML += `</li>`;
                  gameIndex++;
              }
              
              // Remaining games = small cubes in groups of 4, moving to the right
              while (gameIndex < section.games.length) {
                  gamesHTML += `<li class="primeCarouselLi">`;
                  gamesHTML += `<div class="small-games-container">`;
                  for (let i = 0; i < 4 && gameIndex < section.games.length; i++) {
                      const smallGame = section.games[gameIndex];
                      const smallGameKey = getGameKey(smallGame.embed);
                      const smallRatingData = gameRatings[smallGameKey] || { average: 0, count: 0 };
                      gamesHTML += createBigGameCubeHTML(smallGame, gameIndex, smallGameKey, smallRatingData);
                      gameIndex++;
                  }
                  gamesHTML += `</div>`;
                  gamesHTML += `</li>`;
              }
          } else {
              // Create alternating pattern: big game, then 4 small games, repeat (for other sections)
              while (gameIndex < section.games.length) {
                  // Big game (horizontal rectangle) - single <li>
                  if (gameIndex < section.games.length) {
                      const bigGame = section.games[gameIndex];
                      const bigGameKey = getGameKey(bigGame.embed);
                      const bigRatingData = gameRatings[bigGameKey] || { average: 0, count: 0 };
                      gamesHTML += `<li class="primeCarouselLi">`;
                      gamesHTML += createBigGameCubeHTML(bigGame, gameIndex, bigGameKey, bigRatingData);
                      gamesHTML += `</li>`;
                      gameIndex++;
                      
                      // 4 small games in a container - single <li> with div containing 4 games
                      if (gameIndex < section.games.length) {
                          gamesHTML += `<li class="primeCarouselLi">`;
                          gamesHTML += `<div class="small-games-container">`;
                          for (let i = 0; i < 4 && gameIndex < section.games.length; i++) {
                              const smallGame = section.games[gameIndex];
                              const smallGameKey = getGameKey(smallGame.embed);
                              const smallRatingData = gameRatings[smallGameKey] || { average: 0, count: 0 };
                              gamesHTML += createBigGameCubeHTML(smallGame, gameIndex, smallGameKey, smallRatingData);
                              gameIndex++;
                          }
                          gamesHTML += `</div>`;
                          gamesHTML += `</li>`;
                      }
                  }
              }
          }
          
          return `
              <div class="featured-section" data-section-index="${sectionIndex}" data-category="${section.category || ''}">
                  <div class="featured-section-header">
                      <h3><i class="fas ${section.icon}"></i> ${section.title}</h3>
                      <div class="featured-section-header-actions">
                          ${section.hasClearButton ? `<button class="clear-recently-played-btn" title="Clear Recently Played">
                              <i class="fas fa-trash-alt"></i> Clear
                          </button>` : ''}
                          <a href="${section.link}" class="view-more-btn">View All <i class="fas fa-arrow-right"></i></a>
                      </div>
                  </div>
                  <div class="featured-games-scroll-container prime-carousel ${section.category === 'recently-played' ? 'recently-played-carousel' : ''}">
                      <button class="scroll-arrow-left primeCarouselArrow primeCarouselArrowLeft" aria-label="Left arrow">
                          <i class="fas fa-chevron-left"></i>
                          <div class="scroll-arrow-overlay"></div>
                      </button>
                      <ul class="featured-games-grid primeCarouselContainer">
                          ${gamesHTML}
                      </ul>
                      <button class="scroll-arrow-right primeCarouselArrow primeCarouselArrowRight" aria-label="Right arrow">
                          <i class="fas fa-chevron-right"></i>
                          <div class="scroll-arrow-overlay"></div>
                      </button>
                  </div>
              </div>
          `;
      }).join('');
      
      // Add scroll functionality to arrow buttons and handle recently played carousel
      container.querySelectorAll('.featured-games-scroll-container').forEach(scrollContainer => {
          const gamesGrid = scrollContainer.querySelector('.featured-games-grid');
          const leftArrow = scrollContainer.querySelector('.scroll-arrow-left');
          const rightArrow = scrollContainer.querySelector('.scroll-arrow-right');
          const isRecentlyPlayed = scrollContainer.classList.contains('recently-played-carousel');
          
          // For recently played carousel, ensure it starts scrolled to the left (showing most recent first)
          if (isRecentlyPlayed) {
              // Scroll to the left immediately
              gamesGrid.scrollLeft = 0;
              // Also ensure after layout
              setTimeout(() => {
                  gamesGrid.scrollLeft = 0;
              }, 50);
              setTimeout(() => {
                  gamesGrid.scrollLeft = 0;
              }, 200);
          }
          
          // Right arrow functionality
          if (rightArrow) {
              rightArrow.addEventListener('click', () => {
                  const scrollAmount = gamesGrid.offsetWidth * 0.8; // Scroll 80% of visible width
                  gamesGrid.scrollBy({ left: scrollAmount, behavior: 'smooth' });
              });
          }
          
          // Left arrow functionality
          if (leftArrow) {
              leftArrow.addEventListener('click', () => {
                  const scrollAmount = gamesGrid.offsetWidth * 0.8; // Scroll 80% of visible width
                  gamesGrid.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
              });
          }
          
          // Show/hide arrows based on scroll position
          const updateArrowVisibility = () => {
              const isScrollable = gamesGrid.scrollWidth > gamesGrid.clientWidth;
              const isAtStart = gamesGrid.scrollLeft <= 10;
              const isAtEnd = gamesGrid.scrollLeft + gamesGrid.clientWidth >= gamesGrid.scrollWidth - 10;
              
              if (leftArrow) {
                  if (isScrollable && !isAtStart) {
                      leftArrow.classList.add('show');
                      leftArrow.style.opacity = '0.7';
                  } else {
                      leftArrow.classList.remove('show');
                      leftArrow.style.opacity = '0';
                  }
              }
              
              if (rightArrow) {
                  if (isScrollable && !isAtEnd) {
                      rightArrow.classList.add('show');
                      rightArrow.style.opacity = '0.7';
                  } else {
                      rightArrow.classList.remove('show');
                      rightArrow.style.opacity = '0';
                  }
              }
          };
          
          // Check on load and resize
          const checkVisibility = () => {
              updateArrowVisibility();
          };
          
          gamesGrid.addEventListener('scroll', updateArrowVisibility);
          window.addEventListener('resize', checkVisibility);
          // Initial check after a short delay to ensure layout is complete
          setTimeout(checkVisibility, 100);
      });
      
      // Add clear button handler for recently played
      container.querySelectorAll('.clear-recently-played-btn').forEach(clearBtn => {
          clearBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              
              // Confirm before clearing
              if (confirm('Are you sure you want to clear all recently played games?')) {
                  try {
                      localStorage.removeItem('recentlyPlayedGames');
                      // Reload the featured sections to update the UI
                      if (typeof renderFeaturedSections === 'function') {
                          renderFeaturedSections();
                      } else {
                          // Fallback: hide the recently played section
                          const recentlyPlayedSection = clearBtn.closest('.featured-section[data-category="recently-played"]');
                          if (recentlyPlayedSection) {
                              recentlyPlayedSection.style.display = 'none';
                          }
                      }
                  } catch (error) {
                      console.error('Error clearing recently played games:', error);
                      alert('Error clearing recently played games. Please try again.');
                  }
              }
          });
      });
      
      // Add click handlers for games
      container.querySelectorAll('.big-game-cube').forEach(cube => {
          cube.addEventListener('click', (e) => {
              const filename = cube.getAttribute('data-filename');
              const embed = cube.getAttribute('data-embed');
              const title = cube.getAttribute('data-title');
              
              // Save to recently played before navigating
              if (embed && title && typeof saveToRecentlyPlayed === 'function') {
                  const game = gameSites ? gameSites.find(site => site.embed === embed) : null;
                  if (game) {
                      saveToRecentlyPlayed({
                          title: title,
                          embed: embed,
                          image: game.image || '',
                          timestamp: Date.now()
                      });
                  }
              }
              
              if (filename) {
                  const isInPagesFolder = window.location.pathname.includes('/pages/');
                  const gamesPath = isInPagesFolder ? `../games/${filename}` : `games/${filename}`;
                  window.location.href = gamesPath;
              }
          });
      });
      
      // Random games section at the bottom with mixed sizes
      const hasFeaturedContainer = container && container.id === 'featuredGamesSections';
      
      if (hasFeaturedContainer) {
          const playable = (gameSites || []).filter(g => !isCollectionEntry(g) && !isDisabledGame(g));
          if (playable.length > 0) {
              const renderRandomGamesSection = () => {
                  const existingRandom = document.getElementById('randomGamesSection');
                  if (existingRandom) existingRandom.remove();
                  
                  const shuffled = [...playable].sort(() => Math.random() - 0.5);
                  const selection = shuffled.slice(0, 30);
                  const sizePattern = ['big', 'medium', 'small', 'medium', 'small', 'big', 'medium', 'small', 'small', 'medium', 'big', 'small', 'medium', 'small', 'small', 'medium', 'big', 'small', 'medium', 'small', 'small', 'medium', 'big', 'small', 'medium', 'small', 'small', 'medium', 'big', 'small'];
                  
                  const buildCard = (game, idx) => {
                      const size = sizePattern[idx % sizePattern.length];
                      const key = getGameKey(game.embed);
                      const ratingData = gameRatings[key] || { average: 0, count: 0 };
                      const ratingDisplay = ratingData.average ? ratingData.average.toFixed(1) : 'New';
                      const filename = getGameFilename(game.title);
                      return `
                          <div class="random-game-card size-${size}" data-embed="${game.embed}" data-title="${game.title}" data-filename="${filename}" style="background-image: url('${game.image || ''}')">
                              <div class="random-game-overlay">
                                  <span class="random-game-tag">${size === 'big' ? 'Spotlight' : size === 'medium' ? 'Pick' : 'Mini'}</span>
                                  <div class="random-game-title">${game.title}</div>
                                  <div class="random-game-meta">${ratingData.count ? `<i class="fas fa-star"></i> ${ratingDisplay}` : 'Unrated'}</div>
                              </div>
                          </div>
                      `;
                  };
                  
                  const randomSectionHTML = `
                      <div class="random-games-section" id="randomGamesSection">
                          <div class="random-games-header">
                              <div class="random-games-heading">
                                  <h3><i class="fas fa-random"></i> Random Games</h3>
                                  <p>A fresh mix of big, medium, and mini picks</p>
                              </div>
                              <button class="random-games-refresh" type="button"><i class="fas fa-sync"></i> Refresh</button>
                          </div>
                          <div class="random-games-grid">
                              ${selection.map(buildCard).join('')}
                          </div>
                      </div>
                  `;
                  
                  const gamesGridContainer = document.getElementById('gamesGridContainer');
                  if (gamesGridContainer) {
                      gamesGridContainer.insertAdjacentHTML('afterend', randomSectionHTML);
                  } else {
                      container.insertAdjacentHTML('afterend', randomSectionHTML);
                  }
                  
                  setTimeout(() => {
                      const randomSection = document.getElementById('randomGamesSection');
                      if (!randomSection) return;
                      const cards = randomSection.querySelectorAll('.random-game-card');
                      cards.forEach(card => {
                          card.addEventListener('click', () => {
                              const embed = card.dataset.embed;
                              const title = card.dataset.title;
                              const filename = card.dataset.filename;
                              
                              if (embed && title && typeof saveToRecentlyPlayed === 'function') {
                                  const game = gameSites ? gameSites.find(site => site.embed === embed) : null;
                                  if (game) {
                                      saveToRecentlyPlayed({
                                          title,
                                          embed,
                                          image: game.image || '',
                                          timestamp: Date.now()
                                      });
                                  }
                              }
                              
                              if (filename) {
                                  const isInPagesFolder = window.location.pathname.includes('/pages/');
                                  const gamesPath = isInPagesFolder ? `../games/${filename}` : `games/${filename}`;
                                  window.location.href = gamesPath;
                              }
                          });
                      });
                      
                      const refreshBtn = randomSection.querySelector('.random-games-refresh');
                      if (refreshBtn) {
                          refreshBtn.addEventListener('click', renderRandomGamesSection);
                      }
                  }, 80);
              };
              
              renderRandomGamesSection();
          }
      }
      
      // Helper function to get correct games path based on current location
      function getGamesPath(filename) {
          const isInPagesFolder = window.location.pathname.includes('/pages/');
          return isInPagesFolder ? `../games/${filename}` : `games/${filename}`;
      }
      
      // Add click handlers - navigate to individual game pages
      container.querySelectorAll('.game-cube').forEach(cube => {
          cube.addEventListener('click', (e) => {
              if (e.target.closest('.game-cube-rating')) return;
              const embed = cube.getAttribute('data-embed');
              const title = cube.querySelector('.game-cube-title').textContent;
              const filename = `game-${title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')}.html`;
              if (title && title.toLowerCase().includes('clash royale')) {
                  alert('You need to make or log into a Clash Royale account before playing.');
              }
              
              // Navigate to the individual game page
              window.location.href = getGamesPath(filename);
          });
      });
      
      // Add rating handlers
      container.querySelectorAll('.game-cube-stars .fa-star').forEach(star => {
          star.addEventListener('click', (e) => {
              e.stopPropagation();
              const rating = parseInt(star.getAttribute('data-rating'));
              const ratingContainer = star.closest('.game-cube-rating');
              const embed = ratingContainer.getAttribute('data-embed');
              const gameKey = ratingContainer.getAttribute('data-game-key');
              
              // Update UI immediately
              updateRatingDisplay(ratingContainer, rating, gameKey);
              
              // Submit to Firebase
              submitGameRating(gameKey, embed, rating);
          });
      });
  }
  
  // Update rating display immediately after user clicks a star
  function updateRatingDisplay(ratingContainer, userRating, gameKey) {
      if (!ratingContainer) return;
      
      const stars = ratingContainer.querySelectorAll('.game-cube-stars .fa-star');
      const ratingText = ratingContainer.querySelector('.game-cube-rating-text');
      
      // Update star display to show user's rating
      stars.forEach((star, index) => {
          const starRating = index + 1;
          if (starRating <= userRating) {
              star.classList.add('active');
          } else {
              star.classList.remove('active');
          }
      });
      
      // Get current rating data
      const currentRatingData = gameRatings[gameKey] || { average: 0, count: 0 };
      
      // Calculate new average (optimistic update)
      // This will be corrected when Firebase updates come through
      let newCount = currentRatingData.count || 0;
      let newAverage = currentRatingData.average || 0;
      
      // If user hasn't rated before, increment count
      const userId = localStorage.getItem('userId');
      const userRatings = currentRatingData.ratings || {};
      const previousUserRating = userRatings[userId];
      
      if (!previousUserRating) {
          newCount = newCount + 1;
      }
      
      // Calculate new average (simplified - will be corrected by Firebase)
      const totalRatings = Object.keys(userRatings).length;
      if (totalRatings > 0) {
          const sum = Object.values(userRatings).reduce((a, b) => a + b, 0);
          newAverage = (sum - (previousUserRating || 0) + userRating) / totalRatings;
      } else {
          newAverage = userRating;
      }
      
      // Update rating text optimistically
      if (ratingText) {
          ratingText.textContent = `${newAverage.toFixed(1)} ${newCount > 0 ? `(${newCount})` : ''}`;
      }
      
      // Add visual feedback
      ratingContainer.style.transform = 'scale(1.05)';
      setTimeout(() => {
          ratingContainer.style.transform = '';
      }, 200);
  }
  
  // Render Slope Rider Center Card (compact mini card)
  function renderSlopeRiderCenterCard() {
      const container = document.getElementById('slopeRiderCenterCard');
      if (!container) return;
      
      // Wait for gameSites to be populated
      if (!gameSites || gameSites.length === 0) {
          setTimeout(() => renderSlopeRiderCenterCard(), 300);
          return;
      }
      
      // Find Slope Rider game
      const slopeRider = gameSites.find(game => game.title && game.title.toLowerCase().includes('slope rider'));
      if (!slopeRider) {
          container.style.display = 'none';
          return;
      }
      
      container.style.display = 'flex';
      
      const gameKey = getGameKey(slopeRider.embed);
      const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
      const avgRating = ratingData.average || 0;
      const filename = `game-${slopeRider.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')}.html`;
      const description = getGameDescription(slopeRider);
      
      function getGamesPath(file) {
          const isInPagesFolder = window.location.pathname.includes('/pages/');
          return isInPagesFolder ? `../games/${file}` : `games/${file}`;
      }
      
      container.innerHTML = `
          <div class="slope-rider-center-card festive-game-cube game-cube">
              <div class="game-cube-inner">
                  <div class="game-cube-image" style="background-image: url('${slopeRider.image}');"></div>
                  <div class="game-cube-title">${slopeRider.title}</div>
                  <div class="game-cube-description">${description.substring(0, 100)}${description.length > 100 ? '...' : ''}</div>
                  <div class="game-cube-rating" data-embed="${slopeRider.embed}" data-game-key="${gameKey}">
                      <div class="game-cube-stars">
                          ${[1, 2, 3, 4, 5].map(star => `
                              <i class="fas fa-star ${star <= Math.round(avgRating) ? 'active' : ''}" 
                                 data-rating="${star}"></i>
                          `).join('')}
                      </div>
                      <div class="game-cube-rating-text">
                          ${avgRating > 0 ? avgRating.toFixed(1) : 'No ratings'} 
                          ${ratingData.count > 0 ? `(${ratingData.count})` : ''}
                      </div>
                  </div>
                  <div class="game-cube-glow"></div>
              </div>
          </div>
      `;
      
      // Add click handler (open in about:blank wrapper like other cubes)
      const card = container.querySelector('.slope-rider-center-card');
      if (card) {
          card.addEventListener('click', (e) => {
              const embed = slopeRider.embed;
              const aboutBlankHtml = `
<!DOCTYPE html>
<html>
<head>
  <title>${slopeRider.title}</title>
  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #0b0c12; overflow: hidden; }
    iframe { width: 100%; height: 100%; border: none; display: block; }
  </style>
</head>
<body>
  <iframe src="${embed}" allowfullscreen allow="fullscreen; autoplay; clipboard-write; accelerometer; gyroscope; picture-in-picture; magnetometer" sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-downloads allow-top-navigation-by-user-activation"></iframe>
</body>
</html>`;
              const newWin = window.open('about:blank', '_blank');
              if (newWin) {
                  newWin.document.write(aboutBlankHtml);
                  newWin.document.close();
              } else {
                  // Fallback: navigate current window
                  window.location.href = embed;
              }
          });
      }
      
      // Add rating click handlers (reuse existing functions)
      container.querySelectorAll('.game-cube-stars .fa-star').forEach(star => {
          star.addEventListener('click', (e) => {
              e.stopPropagation();
              const rating = parseInt(star.getAttribute('data-rating'));
              const ratingContainer = star.closest('.game-cube-rating');
              const embed = ratingContainer.getAttribute('data-embed');
              const gKey = ratingContainer.getAttribute('data-game-key');
              const existing = gameRatings[gKey] || { average: 0, count: 0 };
              const newAverage = ((existing.average * existing.count) + rating) / (existing.count + 1);
              
              // Update UI immediately
              ratingContainer.querySelectorAll('.fa-star').forEach(s => {
                  const starValue = parseInt(s.getAttribute('data-rating'));
                  s.classList.toggle('active', starValue <= rating);
              });
              const ratingText = ratingContainer.querySelector('.game-cube-rating-text');
              if (ratingText) {
                  const newCount = (existing.count || 0) + 1;
                  ratingText.textContent = `${newAverage.toFixed(1)} (${newCount})`;
              }
              
              // Submit rating
              submitGameRating(gKey, embed, rating);
          });
      });
  }
  
  // Render Game of the Season card (disabled big card)
  function renderGameOfSeason() {}
  
  // Initialize games grid
  function initGamesGrid() {
      // Ensure games grid is visible
      const gamesGridContainer = document.getElementById('gamesGridContainer');
      if (gamesGridContainer) {
          gamesGridContainer.style.display = 'block';
      }
      
      // Load games from JSON and render featured sections
      // If on a category page, wait for games to load before filtering
      const urlParams = new URLSearchParams(window.location.search);
      // Check for category in URL parameter (for all-games.html?category=racing)
      let categoryFromUrl = urlParams.get('category');
      // Fallback: check if we're on an old category page (games-racing.html, etc.)
      if (!categoryFromUrl && window.location.pathname.includes('games-')) {
          categoryFromUrl = window.location.pathname.split('games-')[1]?.replace('.html', '');
      }
      
      // Check if we're on all-games page (multiple ways to detect)
      const isAllGamesPage = window.location.pathname.includes('all-games.html') || 
                            window.location.pathname.endsWith('all-games.html') ||
                            window.location.pathname.includes('/pages/all-games') ||
                            window.location.href.includes('all-games.html');
      
      // Function to render games on all-games page
      function renderAllGames(resetPagination = false) {
          if (!gameSites || gameSites.length === 0) {
              console.warn('No games available to render');
              return;
          }
          
          const gamesGrid = document.getElementById('gamesGrid');
          if (!gamesGrid) {
              console.warn('gamesGrid element not found');
              return;
          }
          
          if (typeof filterGamesByCategory === 'function') {
              filterGamesByCategory('all', resetPagination);
          } else if (typeof renderGamesGrid === 'function') {
              renderGamesGrid(null, resetPagination);
          } else {
              console.error('Neither filterGamesByCategory nor renderGamesGrid functions available');
          }
      }
      
      loadGamesFromJSON().then(() => {
          // Ensure games are loaded before filtering
          if (!gameSites || gameSites.length === 0) {
              console.warn('Games not loaded yet, retrying...');
              setTimeout(() => {
                  if (gameSites && gameSites.length > 0) {
                      initRandomGameButton();
                      // Check for URL parameters after games are loaded
                      handleUrlParameters();
                      if (isAllGamesPage) {
                          if (categoryFromUrl && typeof filterGamesByCategory === 'function') {
                              // Activate the corresponding category button
                              const categoryBtn = document.querySelector(`.category-btn[data-category="${categoryFromUrl}"]`);
                              if (categoryBtn) {
                                  document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
                                  categoryBtn.classList.add('active');
                              }
                              filterGamesByCategory(categoryFromUrl, true);
                          } else {
                              renderAllGames();
                          }
                      } else if (categoryFromUrl && typeof filterGamesByCategory === 'function') {
                          filterGamesByCategory(categoryFromUrl);
                      }
                  } else {
                      console.error('Games still not loaded after retry');
                  }
              }, 500);
              return;
          }
          
          initRandomGameButton();
          // Check for URL parameters after games are loaded
          handleUrlParameters();
          
          // If we're on all-games page with a category parameter, filter and activate the button
          if (isAllGamesPage) {
              if (categoryFromUrl && typeof filterGamesByCategory === 'function') {
                  // Activate the corresponding category button
                  const categoryBtn = document.querySelector(`.category-btn[data-category="${categoryFromUrl}"]`);
                  if (categoryBtn) {
                      // Remove active from all buttons
                      document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
                      // Add active to the matching button
                      categoryBtn.classList.add('active');
                  }
                  // Filter games by category
                  filterGamesByCategory(categoryFromUrl, true);
              } else {
                  // On all-games page, show all games by default
                  renderAllGames(true);
              }
          } else if (categoryFromUrl && typeof filterGamesByCategory === 'function') {
              // Old category pages (games-racing.html, etc.) - filter by category
              filterGamesByCategory(categoryFromUrl);
          }
      }).catch((error) => {
          console.error('Error loading games:', error);
          // Fallback: try to render games anyway if gameSites has data
          if (gameSites && gameSites.length > 0) {
              initRandomGameButton();
              // Check for URL parameters after games are loaded
              handleUrlParameters();
              if (isAllGamesPage) {
                  renderAllGames();
              } else if (typeof renderGamesGrid === 'function') {
                  renderGamesGrid();
              }
          } else {
              // If still no games, wait a bit and try again
              setTimeout(() => {
                  if (gameSites && gameSites.length > 0) {
                      // Check for URL parameters after games are loaded
                      handleUrlParameters();
                      if (isAllGamesPage) {
                          renderAllGames();
                      } else if (typeof filterGamesByCategory === 'function') {
                          filterGamesByCategory('all');
                      }
                  } else {
                      console.error('Games failed to load after multiple attempts');
                  }
              }, 1000);
          }
      });
      
      // Setup search functionality
      const searchInput = document.getElementById('gamesSearchInput');
      const clearSearchBtn = document.getElementById('clearSearchBtn');
      
      if (searchInput) {
          // Debounce search for real-time updates
          let searchTimeout;
          searchInput.addEventListener('input', (e) => {
              clearTimeout(searchTimeout);
              searchTimeout = setTimeout(() => {
                  const query = e.target.value.trim();
                  
                  if (query === '') {
                      // If no search query, hide search results and show normal view
                      const searchResultsGrid = document.getElementById('searchResultsGrid');
                      const featuredSections = document.getElementById('featuredGamesSections');
                      if (searchResultsGrid) searchResultsGrid.style.display = 'none';
                      if (featuredSections) featuredSections.style.display = 'block';
                      
                      // If on all-games page, apply category filter
                      const activeCategory = document.querySelector('.category-btn.active');
                      if (activeCategory) {
                          const category = activeCategory.getAttribute('data-category');
                          filterGamesByCategory(category);
                      } else {
                          const gamesGrid = document.getElementById('gamesGrid');
                          if (gamesGrid) {
                              renderGamesGrid();
                          }
                      }
                      if (clearSearchBtn) clearSearchBtn.style.display = 'none';
                      return;
                  }
                  
                  // Show clear button
                  if (clearSearchBtn) clearSearchBtn.style.display = 'flex';
                  
                  // Check if we're on all-games page first
                  const isAllGamesPage = window.location.pathname.includes('all-games.html') || 
                                        window.location.pathname.endsWith('all-games.html') ||
                                        window.location.pathname.includes('/pages/all-games') ||
                                        window.location.href.includes('all-games.html');
                  
                  // Hide featured sections and show search results on main page only
                  if (!isAllGamesPage) {
                      const featuredSections = document.getElementById('featuredGamesSections');
                      const searchResultsGrid = document.getElementById('searchResultsGrid');
                      if (featuredSections) featuredSections.style.display = 'none';
                      if (searchResultsGrid) searchResultsGrid.style.display = 'grid';
                  } else {
                      // On all-games page, ensure gamesGrid is visible
                      const gamesGrid = document.getElementById('gamesGrid');
                      if (gamesGrid) gamesGrid.style.display = 'grid';
                  }
                  
                  // Get current category filter
                  const activeCategory = document.querySelector('.category-btn.active');
                  const category = activeCategory ? activeCategory.getAttribute('data-category') : 'all';
                  
                  // When searching on all-games page, always search through ALL games regardless of category
                  // Start with ALL games from gameSites
                  // Ensure games are loaded before searching
                  if (!gameSites || gameSites.length === 0) {
                      console.warn('No games loaded yet, waiting for games to load...');
                      // Retry after a short delay if games aren't loaded
                      setTimeout(() => {
                          if (searchInput && searchInput.value.trim() === query) {
                              searchInput.dispatchEvent(new Event('input'));
                          }
                      }, 500);
                      return;
                  }
                  
                  let gamesToSearch = [...gameSites].filter(g => {
                      if (isCollectionEntry(g)) return false;
                      if (typeof isDisabledGame === 'function' && isDisabledGame(g)) return false;
                      return true;
                  });
                  
                  // Add stats and ratings to all games for filtering/sorting
                  gamesToSearch = gamesToSearch.map(site => {
                      const stats = getGameStats(site.embed);
                      const gameKey = getGameKey(site.embed);
                      const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
                      return {
                          ...site,
                          clicks: stats ? stats.clicks : 0,
                          lastClicked: stats ? stats.lastClicked : 0,
                          firstClicked: stats && stats.firstClicked ? stats.firstClicked : 0,
                          rating: ratingData.average || 0,
                          ratingCount: ratingData.count || 0
                      };
                  });
                  
                  // When searching, always search through ALL games regardless of category
                  // Only apply category filter when NOT searching (query is empty)
                  // On all-games page, when searching, always search through ALL games
                  if (category !== 'all' && query === '' && !isAllGamesPage) {
                      if (category === 'popular') {
                          // Filter to games with ratings, then sort by rating and review count
                          gamesToSearch = gamesToSearch.filter(game => game.ratingCount > 0);
                          gamesToSearch.sort((a, b) => {
                              // Primary sort: by rating (higher is better)
                              if (a.rating !== b.rating) {
                                  return b.rating - a.rating;
                              }
                              // Secondary sort: by number of reviews (more reviews = more popular)
                              return b.ratingCount - a.ratingCount;
                          });
                      } else if (category === 'trending') {
                          const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
                          gamesToSearch = gamesToSearch.filter(game => game.clicks > 0 && game.lastClicked > oneDayAgo);
                      } else if (category === 'new') {
                          gamesToSearch = gamesToSearch.filter(game => isNewGameEntry(game, gamesToSearch.length));
                      } else if (category === 'racing') {
                          gamesToSearch = gamesToSearch.filter(game => {
                              const tags = (game.tags || '').toLowerCase();
                              return tags.includes('racing') || tags.includes('drift') || tags.includes('driving') || tags.includes('car');
                          });
                      } else if (category === 'puzzle') {
                          gamesToSearch = gamesToSearch.filter(game => {
                              const tags = (game.tags || '').toLowerCase();
                              return tags.includes('puzzle') || tags.includes('brain') || tags.includes('logic');
                          });
                      } else if (category === 'action') {
                          gamesToSearch = gamesToSearch.filter(game => {
                              const tags = (game.tags || '').toLowerCase();
                              return tags.includes('action') || tags.includes('arcade') || tags.includes('battle');
                          });
                      } else if (category === 'shooting') {
                          gamesToSearch = gamesToSearch.filter(game => {
                              const tags = (game.tags || '').toLowerCase();
                              return tags.includes('shooting') || tags.includes('fps') || tags.includes('gun');
                          });
                      }
                  }
                  
                  // Then apply search filter
                  console.log('Searching for:', query, 'in', gamesToSearch.length, 'games');
                  const filtered = gamesToSearch
                      .map(site => ({
                          ...site,
                          similarity: calculateSimilarity(query, site.title || '')
                      }))
                      .filter(site => {
                          const matches = fuzzySearch(query, site.title || '');
                          return matches;
                      })
                      .sort((a, b) => b.similarity - a.similarity);
                  
                  console.log('Search completed. Found', filtered.length, 'games for query:', query);
                  
                  // Render in appropriate container
                  const gamesGrid = document.getElementById('gamesGrid');
                  const searchResultsGrid = document.getElementById('searchResultsGrid');
                  
                  if (isAllGamesPage && gamesGrid) {
                      // On all-games page, render in gamesGrid
                      console.log('Rendering search results in gamesGrid:', filtered.length, 'games found for query:', query);
                      gamesGrid.style.display = 'grid';
                      renderGamesGrid(filtered, false);
                  } else if (searchResultsGrid) {
                      // On main page, render in searchResultsGrid
                      console.log('Rendering search results in searchResultsGrid:', filtered.length, 'games found for query:', query);
                      renderGamesGridInContainer(filtered, searchResultsGrid);
                  } else if (gamesGrid) {
                      // Fallback: if gamesGrid exists but we're not sure about the page
                      console.log('Rendering search results in gamesGrid (fallback):', filtered.length, 'games found');
                      gamesGrid.style.display = 'grid';
                      renderGamesGrid(filtered, false);
                  } else {
                      console.error('No container found for search results! gamesGrid exists:', !!gamesGrid, 'searchResultsGrid exists:', !!searchResultsGrid);
                  }
              }, 150);
          });
      }
      
      // Clear search button
      if (clearSearchBtn) {
          clearSearchBtn.addEventListener('click', () => {
              if (searchInput) {
                  searchInput.value = '';
                  searchInput.dispatchEvent(new Event('input'));
              }
              clearSearchBtn.style.display = 'none';
          });
      }
      
        // Default game button
      const defaultGameBtn = document.getElementById('defaultGameBtn');
      if (defaultGameBtn) {
          defaultGameBtn.addEventListener('click', () => {
                // Load slope game directly (not through privacy browser proxy)
                const iframeContainer = document.getElementById('iframeContainer');
                const gamesGridContainer = document.getElementById('gamesGridContainer');
                const embeddedSite = document.getElementById('embeddedSite');
              const currentSiteTitle = document.getElementById('currentSiteTitle');
              
              if (!iframeContainer || !embeddedSite) {
                  console.error('Iframe container or embedded site not found');
                  return;
              }
              
              // Track the game click
              trackGameClick('https://slopeonline.online/', 'Descent Runner - Default Game');
              
                // Hide games grid if it exists
                if (gamesGridContainer) {
                    gamesGridContainer.style.display = 'none';
                }
                
                // Show iframe
                iframeContainer.style.display = 'block';
                // Pause heavy visuals while default game is active
                if (typeof pauseHomeVisuals === 'function') pauseHomeVisuals();
              
                // Set title
                if (currentSiteTitle) {
                    currentSiteTitle.textContent = 'Descent Runner - Default Game';
              }
              
              // Clear any existing content
              embeddedSite.removeAttribute('srcdoc');
              embeddedSite.src = 'about:blank';
              
              // Add sandbox attributes to iframe for better security
              embeddedSite.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms allow-downloads allow-top-navigation-by-user-activation');
              
              // Load site directly (no proxy)
              setTimeout(() => {
                  embeddedSite.src = 'https://slopeonline.online/';
                  
                  // Scroll to iframe
                  setTimeout(() => {
                      iframeContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                  }, 100);
              }, 100);
          });
      }
      
      // Category buttons
      const categoryButtons = document.querySelectorAll('.category-btn');
      categoryButtons.forEach(btn => {
          btn.addEventListener('click', () => {
              // Remove active class from all buttons
              categoryButtons.forEach(b => b.classList.remove('active'));
              // Add active class to clicked button
              btn.classList.add('active');
              
              // Filter games by category (reset pagination when changing category)
              const category = btn.getAttribute('data-category');
              const isAllGamesPage = window.location.pathname.includes('all-games.html') || 
                                    window.location.pathname.endsWith('all-games.html') ||
                                    window.location.pathname.includes('/pages/all-games') ||
                                    window.location.href.includes('all-games.html');
              filterGamesByCategory(category, isAllGamesPage);
              
              // Clear search when changing category
              if (searchInput) {
                  searchInput.value = '';
                  if (clearSearchBtn) clearSearchBtn.style.display = 'none';
              }
          });
      });
      
      // Initialize game stats tracking
      initGameStats();
      
      // Initialize game ratings tracking
      initGameRatings();
  }
  
  // Game stats tracking
  // Note: gameStats and gameStatsListener are already declared at the top of the file
  
  // Game ratings tracking
  // Note: gameRatings and gameRatingsListener are already declared at the top of the file
  
  // Generate consistent game key from embed URL
  function getGameKey(embed) {
      if (!embed) return null;
      try {
          // Use a more consistent key generation
          const url = new URL(embed);
          const path = url.pathname + url.search;
          // Create a hash-like key from the full URL
          let hash = 0;
          const str = embed;
          for (let i = 0; i < str.length; i++) {
              const char = str.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash; // Convert to 32bit integer
          }
          return 'game_' + Math.abs(hash).toString(36);
      } catch (e) {
          // Fallback to base64 if URL parsing fails
          return 'game_' + btoa(embed).replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);
      }
  }
  
  // Get game stats for a specific embed URL
  function getGameStats(embed) {
      if (!embed || !gameStats) return null;
      const gameKey = getGameKey(embed);
      if (!gameKey) return null;
      return gameStats[gameKey] || null;
  }
  
  // Filter games by category
  function filterGamesByCategory(category, resetPagination = false) {
      try {
          // Ensure games are loaded
          if (!gameSites || gameSites.length === 0) {
              console.warn('No games loaded yet, waiting...');
              // Try to load games if not already loaded
              if (typeof loadGamesFromJSON === 'function') {
                  loadGamesFromJSON().then(() => {
                      filterGamesByCategory(category, resetPagination);
                  });
              }
              return;
          }
          
          let filtered = gameSites.filter(g => !isCollectionEntry(g));
          
          if (category === 'all') {
              // Show all games with a predictable order: rated first, then newest additions, then the rest
              const gamesWithMeta = filtered.map(site => {
                  const stats = getGameStats(site.embed);
                  const gameKey = getGameKey(site.embed);
                  const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
                  return {
                      ...site,
                      clicks: stats ? stats.clicks : 0,
                      lastClicked: stats ? stats.lastClicked : 0,
                      firstClicked: stats && stats.firstClicked ? stats.firstClicked : 0,
                      rating: ratingData.average || 0,
                      ratingCount: ratingData.count || 0
                  };
              });
              
              const totalGames = gamesWithMeta.length;
              const ratedGames = [];
              const newGames = [];
              const remainingGames = [];
              
              gamesWithMeta.forEach(game => {
                  if (game.ratingCount > 0) {
                      ratedGames.push(game);
                      return;
                  }
                  
                  if (isNewGameEntry(game, totalGames)) {
                      newGames.push(game);
                      return;
                  }
                  
                  remainingGames.push(game);
              });
              
              ratedGames.sort((a, b) => {
                  if (a.rating !== b.rating) return b.rating - a.rating;
                  if (a.ratingCount !== b.ratingCount) return b.ratingCount - a.ratingCount;
                  const idxA = typeof a.addedIndex === 'number' ? a.addedIndex : -1;
                  const idxB = typeof b.addedIndex === 'number' ? b.addedIndex : -1;
                  return idxB - idxA;
              });
              
              newGames.sort((a, b) => {
                  const aIsPriority = PRIORITY_NEW_EMBEDS.has(a.embed);
                  const bIsPriority = PRIORITY_NEW_EMBEDS.has(b.embed);
                  if (aIsPriority !== bIsPriority) return aIsPriority ? -1 : 1;
                  
                  const idxA = typeof a.addedIndex === 'number' ? a.addedIndex : -1;
                  const idxB = typeof b.addedIndex === 'number' ? b.addedIndex : -1;
                  if (idxA !== idxB) return idxB - idxA;
                  
                  if (a.rating !== b.rating) return b.rating - a.rating;
                  return b.ratingCount - a.ratingCount;
              });
              
              remainingGames.sort((a, b) => {
                  const idxA = typeof a.addedIndex === 'number' ? a.addedIndex : -1;
                  const idxB = typeof b.addedIndex === 'number' ? b.addedIndex : -1;
                  if (idxA !== idxB) return idxB - idxA;
                  return (b.clicks || 0) - (a.clicks || 0);
              });
              
              const orderedGames = [...ratedGames, ...newGames, ...remainingGames];
              
              console.log('Filtering all games, total:', orderedGames.length, 'rated:', ratedGames.length, 'new:', newGames.length);
              renderGamesGrid(orderedGames, resetPagination);
              return;
          }
          
          // Filter by game tags/category (only if category is tag-based)
          if (category === 'racing') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  const title = (game.title || '').toLowerCase();
                  return tags.includes('racing') || tags.includes('drift') || tags.includes('driving') || tags.includes('car') ||
                         title.includes('race') || title.includes('drift') || title.includes('car') || title.includes('highway') ||
                         title.includes('traffic') || title.includes('racer');
              });
          } else if (category === 'puzzle') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  const title = (game.title || '').toLowerCase();
                  return tags.includes('puzzle') || tags.includes('brain') || tags.includes('logic') || tags.includes('match') ||
                         title.includes('puzzle') || title.includes('match') || title.includes('block') || title.includes('chess');
              });
          } else if (category === 'action') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  const title = (game.title || '').toLowerCase();
                  return tags.includes('action') || tags.includes('arcade') || tags.includes('battle') ||
                         title.includes('battle') || title.includes('combat') || title.includes('war') || title.includes('strike');
              });
          } else if (category === 'shooting') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  const title = (game.title || '').toLowerCase();
                  return tags.includes('shooting') || tags.includes('sniper') || tags.includes('fps') || tags.includes('gun') ||
                         title.includes('shooter') || title.includes('sniper') || title.includes('gun') || title.includes('shoot');
              });
          } else if (category === 'strategy') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  return tags.includes('strategy') || tags.includes('tower-defense') || tags.includes('defense');
              });
          } else if (category === 'adventure') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  return tags.includes('adventure') || tags.includes('parkour') || tags.includes('platformer');
              });
          } else if (category === 'sports') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  const title = (game.title || '').toLowerCase();
                  return tags.includes('sports') || tags.includes('basketball') || tags.includes('football') || tags.includes('soccer') ||
                         title.includes('basketball') || title.includes('football') || title.includes('soccer');
              });
          } else if (category === 'simulation') {
              filtered = filtered.filter(game => {
                  const tags = (game.tags || '').toLowerCase();
                  const title = (game.title || '').toLowerCase();
                  return tags.includes('simulator') || tags.includes('simulation') || tags.includes('tycoon') ||
                         title.includes('simulator') || title.includes('simulation');
              });
          }
          
          // If no games match, show all games with a warning
          if (filtered.length === 0) {
              console.warn(`No games found for category: ${category}, showing all games`);
              filtered = [...gameSites];
          }
          
          // Add stats and ratings to each game (with error handling)
          filtered = filtered.map(site => {
              try {
                  const stats = getGameStats(site.embed);
                  const gameKey = getGameKey(site.embed);
                  const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
                  return {
                      ...site,
                      clicks: stats ? stats.clicks : 0,
                      lastClicked: stats ? stats.lastClicked : 0,
                      firstClicked: stats && stats.firstClicked ? stats.firstClicked : 0,
                      rating: ratingData.average || 0,
                      ratingCount: ratingData.count || 0
                  };
              } catch (e) {
                  // If stats fail, just use defaults
                  const gameKey = getGameKey(site.embed);
                  const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
                      return {
                          ...site,
                          clicks: 0,
                          lastClicked: 0,
                          firstClicked: 0,
                          rating: ratingData.average || 0,
                          ratingCount: ratingData.count || 0
                      };
              }
          });
      
      if (category === 'popular') {
          // Sort by highest star rating and most reviews (most popular)
          // Prioritize games with ratings, but include all games
          filtered.sort((a, b) => {
              // Primary sort: by rating (higher is better)
              // Games with ratings should come before games without ratings
              if (a.rating > 0 && b.rating === 0) return -1;
              if (a.rating === 0 && b.rating > 0) return 1;
              if (a.rating !== b.rating) {
                  return b.rating - a.rating;
              }
              // Secondary sort: by number of reviews (more reviews = more popular)
              if (a.ratingCount !== b.ratingCount) {
                  return b.ratingCount - a.ratingCount;
              }
              // Tertiary sort: by clicks as tiebreaker
              return b.clicks - a.clicks;
          });
      } else if (category === 'trending') {
          // Sort by recent activity (last 24-48 hours weighted heavily)
          const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
          const twoDaysAgo = Date.now() - (48 * 60 * 60 * 1000);
          
          // Calculate trending scores for all games
          const allGamesWithScores = filtered.map(game => {
              const now = Date.now();
              let trendingScore = 0;
              
              if (game.clicks > 0) {
                  // Base score from total clicks (logarithmic to prevent old games from dominating)
                  const baseScore = Math.log10(game.clicks + 1) * 10;
                  
                  // Recent activity boost
                  if (game.lastClicked > oneDayAgo) {
                      // Very recent (last 24 hours) - high boost
                      trendingScore = baseScore * 3;
                  } else if (game.lastClicked > twoDaysAgo) {
                      // Recent (last 48 hours) - medium boost
                      trendingScore = baseScore * 1.5;
                  } else {
                      // Older - lower score
                      trendingScore = baseScore * 0.5;
                  }
                  
                  // Add recency decay factor
                  const hoursSinceLastClick = (now - game.lastClicked) / (1000 * 60 * 60);
                  const recencyFactor = Math.max(0, 1 - (hoursSinceLastClick / 72)); // Decay over 3 days
                  trendingScore *= (1 + recencyFactor);
              }
              
              return { ...game, trendingScore: trendingScore };
          });
          
          // Separate trending games (with clicks) from non-trending games
          const trendingGames = allGamesWithScores
              .filter(game => game.clicks > 0)
              .sort((a, b) => b.trendingScore - a.trendingScore);
          
          // Get non-trending games (games with 0 clicks or very low scores)
          const nonTrendingGames = allGamesWithScores
              .filter(game => game.clicks === 0 || game.trendingScore < 1)
              .sort((a, b) => {
                  // Sort by clicks first, then by array position (newer games first)
                  if (b.clicks !== a.clicks) return b.clicks - a.clicks;
                  // For games with same clicks, prefer newer ones (higher index in original array)
                  const indexA = gameSites.findIndex(s => s.embed === a.embed);
                  const indexB = gameSites.findIndex(s => s.embed === b.embed);
                  return indexB - indexA;
              });
          
          // Combine: trending games first, then fill with other games
          filtered = [...trendingGames, ...nonTrendingGames];
      } else if (category === 'new') {
          // Focus the "New" section on recently added and explicitly tagged games
          const totalGames = filtered.length;
          filtered = filtered.filter(game => isNewGameEntry(game, totalGames));
          
          // Sort by priority list, explicit "new" assignments, then recency
          filtered.sort((a, b) => {
              const titleA = a.title || '';
              const titleB = b.title || '';
              const assignedA = STATIC_GAME_CATEGORIES[titleA];
              const assignedB = STATIC_GAME_CATEGORIES[titleB];
              const aIsPriority = PRIORITY_NEW_EMBEDS.has(a.embed);
              const bIsPriority = PRIORITY_NEW_EMBEDS.has(b.embed);
              
              if (aIsPriority !== bIsPriority) return aIsPriority ? -1 : 1;
              
              // Prioritize games assigned to "new" category
              if (assignedA === 'new' && assignedB !== 'new') return -1;
              if (assignedA !== 'new' && assignedB === 'new') return 1;
              
              // Then sort by newest additions
              const idxA = typeof a.addedIndex === 'number' ? a.addedIndex : -1;
              const idxB = typeof b.addedIndex === 'number' ? b.addedIndex : -1;
              if (idxA !== idxB) return idxB - idxA;
              
              // Keep higher-rated new titles slightly earlier
              if (a.rating !== b.rating) return b.rating - a.rating;
              return b.ratingCount - a.ratingCount;
          });
      }
      
          renderGamesGrid(filtered, resetPagination);
      } catch (e) {
          console.error('Error filtering games:', e);
          // Fallback: just render all games
          if (gameSites && gameSites.length > 0) {
              renderGamesGrid([...gameSites], resetPagination);
          } else {
              console.error('No games available to render');
          }
      }
  }
  
  // Initialize game stats listener
  function initGameStats() {
      if (backendApi) {
          backendApi.getGameStats().then((stats) => {
              gameStats = stats || {};
              const activeCategory = document.querySelector('.category-btn.active');
              if (activeCategory) {
                  const category = activeCategory.getAttribute('data-category');
                  filterGamesByCategory(category);
              }
          }).catch(err => console.error('Error loading game stats:', err));
          return;
      }

      if (!db) return;
      
      const statsRef = db.ref('gameStats');
      
      // Make Descent Runner popular by initializing it with clicks
      const slopeRiderEmbed = 'https://game.azgame.io/slope-rider/';
      const slopeRiderKey = getGameKey(slopeRiderEmbed);
      if (slopeRiderKey) {
          const slopeRiderRef = db.ref(`gameStats/${slopeRiderKey}`);
          slopeRiderRef.once('value', (snapshot) => {
              if (!snapshot.exists()) {
                  // Initialize with popularity boost
                  slopeRiderRef.set({
                      embed: slopeRiderEmbed,
                      title: 'Descent Runner',
                      clicks: 50,
                      lastClicked: Date.now(),
                      firstClicked: Date.now() - (7 * 24 * 60 * 60 * 1000) // 7 days ago to make it seem established
                  });
              }
          });
      }
      
      // Listen for real-time updates
      gameStatsListener = statsRef.on('value', (snapshot) => {
          const stats = snapshot.val() || {};
          gameStats = stats;
          
          // Update UI if category is active
          const activeCategory = document.querySelector('.category-btn.active');
          if (activeCategory) {
              const category = activeCategory.getAttribute('data-category');
              filterGamesByCategory(category);
          }
      }, (error) => {
          console.error('Error loading game stats:', error);
      });
  }
  
  // Initialize game ratings listener
  function initGameRatings() {
      if (backendApi) {
          backendApi.getGameRatings().then(ratings => {
              gameRatings = ratings || {};
              updateAllRatingDisplays();
              categorizeAllGames();
              
              if (document.getElementById('featuredGamesSections')) {
                  renderFeaturedSections();
                  renderGameOfSeason();
              }
              if (document.getElementById('slopeRiderCenterCard')) {
                  renderSlopeRiderCenterCard();
              }
              
              const gamesGrid = document.getElementById('gamesGrid');
              if (gamesGrid && gamesGrid.children.length > 0) {
                  const activeCategory = document.querySelector('.category-btn.active');
                  if (activeCategory) {
                      const category = activeCategory.getAttribute('data-category');
                      filterGamesByCategory(category);
                  } else {
                      renderGamesGrid();
                  }
              }
          }).catch(err => console.error('Error loading game ratings:', err));
          return;
      }

      if (!db) return;
      
      const ratingsRef = db.ref('gameRatings');
      
      // Listen for real-time updates
      gameRatingsListener = ratingsRef.on('value', (snapshot) => {
          const ratings = snapshot.val() || {};
          gameRatings = ratings;
          
          // Update all rating displays on the page
          updateAllRatingDisplays();
          
          // Re-categorize games with updated ratings
          categorizeAllGames();
          
          // Update featured sections on home page if they exist
          if (document.getElementById('featuredGamesSections')) {
              renderFeaturedSections();
              renderGameOfSeason();
          }
          if (document.getElementById('slopeRiderCenterCard')) {
              renderSlopeRiderCenterCard();
          }
          
          // Update UI if games grid is visible
          const gamesGrid = document.getElementById('gamesGrid');
          if (gamesGrid && gamesGrid.children.length > 0) {
              const activeCategory = document.querySelector('.category-btn.active');
              if (activeCategory) {
                  const category = activeCategory.getAttribute('data-category');
                  filterGamesByCategory(category);
              } else {
                  renderGamesGrid();
              }
          }
      }, (error) => {
          console.error('Error loading game ratings:', error);
      });
  }
  
  // Update all rating displays on the page
  function updateAllRatingDisplays() {
      document.querySelectorAll('.game-cube-rating').forEach(ratingContainer => {
          const gameKey = ratingContainer.getAttribute('data-game-key');
          if (!gameKey) return;
          
          const ratingData = gameRatings[gameKey] || { average: 0, count: 0 };
          const avgRating = ratingData.average || 0;
          
          // Update stars
          const stars = ratingContainer.querySelectorAll('.game-cube-stars .fa-star');
          stars.forEach((star, index) => {
              const starRating = index + 1;
              if (starRating <= Math.round(avgRating)) {
                  star.classList.add('active');
              } else {
                  star.classList.remove('active');
              }
          });
          
          // Update rating text
          const ratingText = ratingContainer.querySelector('.game-cube-rating-text');
          if (ratingText) {
              ratingText.textContent = `${avgRating > 0 ? avgRating.toFixed(1) : 'No ratings'} ${ratingData.count > 0 ? `(${ratingData.count})` : ''}`;
          }
      });
  }
  
  // Submit game rating
  function submitGameRating(gameKey, embed, rating) {
      if (!db || !gameKey) return;
      
      // Get user identifier (use localStorage to track per-user ratings)
      let userId = localStorage.getItem('userId');
      if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('userId', userId);
      }
      
      const gameRatingRef = db.ref(`gameRatings/${gameKey}`);
      
      gameRatingRef.transaction((current) => {
          const ratingData = current || {
              embed: embed,
              ratings: {},
              total: 0,
              count: 0,
              average: 0
          };
          
          // Check if user already rated
          const previousRating = ratingData.ratings[userId];
          
          // Update or add rating
          ratingData.ratings[userId] = rating;
          
          // Recalculate average
          if (previousRating) {
              // User is updating their rating
              ratingData.total = ratingData.total - previousRating + rating;
          } else {
              // New rating
              ratingData.total = (ratingData.total || 0) + rating;
              ratingData.count = (ratingData.count || 0) + 1;
          }
          
          // Calculate average from total and count
          const ratingCount = Object.keys(ratingData.ratings).length;
          ratingData.average = ratingCount > 0 ? ratingData.total / ratingCount : 0;
          ratingData.count = ratingCount;
          
          return ratingData;
      }, (error, committed, snapshot) => {
          if (error) {
              console.error('Error submitting rating:', error);
          } else if (committed) {
              // Rating saved successfully
              console.log('Rating submitted successfully');
          }
      });
  }
  
  // Track game click
  function trackGameClick(embed, title) {
      if (!db) return;
      
      const gameKey = getGameKey(embed);
      if (!gameKey) return;
      
      const gameRef = db.ref(`gameStats/${gameKey}`);
      
      gameRef.transaction((current) => {
          const now = Date.now();
          const stats = current || {
              embed: embed,
              title: title,
              clicks: 0,
              lastClicked: now,
              firstClicked: now
          };
          
          stats.clicks = (stats.clicks || 0) + 1;
          stats.lastClicked = now;
          if (!stats.firstClicked) stats.firstClicked = now;
          if (!stats.embed) stats.embed = embed;
          if (!stats.title) stats.title = title;
          
          return stats;
      });
  }
  
  // Helper function to convert title to URL-friendly slug
  function titleToSlug(title) {
      return title.toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-|-$/g, '');
  }
  
  // Load game from slug (URL parameter)
  function loadGameFromSlug(slug) {
      // Check if we're on index.html (has iframe container)
      const iframeContainer = document.getElementById('iframeContainer');
      if (!iframeContainer) {
          // On other pages - navigate to index.html with game parameter
          const basePath = window.location.pathname.includes('/pages/') ? '../' : '';
          window.location.href = basePath + 'index.html?game=' + encodeURIComponent(slug);
          return;
      }
      
      // Find game by matching slug with title
      const game = gameSites.find(site => {
          const gameSlug = titleToSlug(site.title);
          return gameSlug === slug;
      });
      
      if (game) {
          const newUrl = window.location.pathname + '?game=' + encodeURIComponent(slug);
          window.history.pushState({ game: slug }, '', newUrl);
          loadGameSite(game.embed, game.title);
      } else {
          console.error('Game not found for slug:', slug);
      }
  }
  
  // Ad-blocking proxy function - routes games through ad-blocking proxy
  function getAdBlockedUrl(url) {
      // Check if ad-blocking is enabled (can be toggled)
      const adBlockEnabled = localStorage.getItem('adBlockGames') !== 'false'; // Default to enabled
      
      if (!adBlockEnabled || !url || url.startsWith('about:') || url.startsWith('data:') || url.includes('proxyyy.up.railway.app')) {
          return url; // Return original URL if ad-blocking disabled or already proxied
      }
      
      const encodedUrl = encodeURIComponent(url);
      return `https://proxyyy.up.railway.app/?url=${encodedUrl}`;
  }
  
  // Save game to recently played
  function saveToRecentlyPlayed(game) {
      try {
          const recentlyPlayed = JSON.parse(localStorage.getItem('recentlyPlayedGames') || '[]');
          // Remove if already exists
          const filtered = recentlyPlayed.filter(g => g.embed !== game.embed);
          // Add to beginning
          filtered.unshift(game);
          // Keep only last 50 games
          const limited = filtered.slice(0, 50);
          localStorage.setItem('recentlyPlayedGames', JSON.stringify(limited));
      } catch (e) {
          console.error('Error saving to recently played:', e);
      }
  }

  // Load game site in iframe with security checks
  function loadGameSite(embed, title) {
      // Security check: rate limiting for game loads
      if (!SecuritySystem.trackRequest('gameLoads', embed)) {
          if (typeof notifications !== 'undefined' && notifications.show) {
              notifications.show('Too many games loaded. Please wait before loading another game.', 'warning', 3000);
          }
          return;
      }

      // Security check: validate embed URL
      if (SecuritySystem.shouldBlockRequest(embed)) {
          SecuritySystem.blockIP(SecuritySystem.getClientIP(), 'Suspicious game URL');
          if (typeof notifications !== 'undefined' && notifications.show) {
              notifications.show('Game blocked by security system', 'error', 3000);
          }
          return;
      }

      const iframeContainer = document.getElementById('iframeContainer');
      const gamesGridContainer = document.getElementById('gamesGridContainer');
      const embeddedSite = document.getElementById('embeddedSite');
      const currentSiteTitle = document.getElementById('currentSiteTitle');

      if (!iframeContainer || !embeddedSite) {
          console.error('Iframe container or embedded site not found');
          return;
      }
      
      // Find the game in the array to check for custom embed
      const game = gameSites.find(site => site.embed === embed);
      
      // Save to recently played
      if (game) {
          saveToRecentlyPlayed({
              title: title,
              embed: embed,
              image: game.image || '',
              timestamp: Date.now()
          });
      }
      
      // Track the game click
      trackGameClick(embed, title);
      
      // Hide games grid if it exists
      if (gamesGridContainer) {
          gamesGridContainer.style.display = 'none';
      }
      
      // Show iframe
      iframeContainer.style.display = 'block';
      // Pause heavy home visuals while a game is active
      if (typeof pauseHomeVisuals === 'function') pauseHomeVisuals();

      // Per-game performance tweak: Fast Food Manager in homepage iframe
      try {
          if (embed && embed.includes('fast-food-manager')) {
              embeddedSite.style.maxWidth = '960px';
              embeddedSite.style.height = '520px';
          } else {
              embeddedSite.style.removeProperty('max-width');
              embeddedSite.style.removeProperty('height');
          }
      } catch (e) {
          // Non-critical
      }
      
      // Set title
      if (currentSiteTitle) {
          currentSiteTitle.textContent = title;
      }
      
      // Clear any existing content
      embeddedSite.removeAttribute('srcdoc');
      embeddedSite.src = 'about:blank';
      
      // Add sandbox attributes to iframe for better security and ad blocking
      embeddedSite.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms allow-downloads allow-top-navigation-by-user-activation');
      
      // Load site - use custom HTML if available, otherwise use src with ad-blocking proxy
      setTimeout(() => {
          if (game && game.customEmbed && game.customHTML) {
              // Use srcdoc for custom HTML
              embeddedSite.srcdoc = game.customHTML;
          } else {
              // Use ad-blocking proxy for regular game URLs
              const adBlockedUrl = getAdBlockedUrl(embed);
              embeddedSite.src = adBlockedUrl;
          }
          
          // Scroll to iframe
          setTimeout(() => {
              iframeContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }, 100);
        }, 100);
    }
    
    // Load a game inline on the homepage; if no iframe exists, bounce to index with game param
    function resolveGamePageUrl(embed, title) {
        const pagePath = getGamePagePathFromTitle(title);
        if (pagePath) {
            try {
                return new URL(pagePath, window.location.href).href;
            } catch (_) {
                return pagePath;
            }
        }
        if (embed) {
            try {
                const embeddedUrl = new URL(embed, window.location.href);
                if (/\/game-[a-z0-9-]+\.html$/i.test(embeddedUrl.pathname || '')) {
                    return embeddedUrl.href;
                }
            } catch (_) {
                // ignore
            }
        }
        return null;
    }

  function openGamePageOrInline(embed, title) {
      const targetUrl = resolveGamePageUrl(embed, title);
      if (targetUrl) {
          window.location.href = targetUrl;
          return;
      }
      openGameInline(embed, title);
  }

  // Polling removed - Worker WebSocket handles all real-time updates

    function openGameInline(embed, title) {
        if (!embed) return;
        // If the embed itself is a game detail page, navigate directly so full page loads
        try {
            const embeddedUrl = new URL(embed, window.location.href);
            const isGameHtml = /\/game-[a-z0-9-]+\.html$/i.test(embeddedUrl.pathname || '');
            if (isGameHtml) {
                window.location.href = embeddedUrl.href;
                return;
            }
        } catch (_) {
            // if URL parsing fails, fall back to inline behavior
        }
        const slug = titleToSlug(title || 'game');
        const iframeContainer = document.getElementById('iframeContainer');
        if (!iframeContainer) {
            const basePath = window.location.pathname.includes('/pages/') ? '../' : '';
            window.location.href = `${basePath}index.html?game=${encodeURIComponent(slug)}`;
            return;
        }
        const basePath = window.location.pathname.split('?')[0];
        const newUrl = `${basePath}?game=${encodeURIComponent(slug)}`;
        window.history.pushState({ game: slug }, '', newUrl);
        loadGameSite(embed, title || 'Game');
    }
    
    // Handle URL parameters on page load and browser navigation
    function handleUrlParameters() {
        const urlParams = new URLSearchParams(window.location.search);
        const gameSlug = urlParams.get('game');
      const openModal = urlParams.get('open');
      
      if (gameSlug && typeof gameSites !== 'undefined' && gameSites.length > 0) {
          loadGameFromSlug(gameSlug);
      }
      
      // Auto-open modals based on URL parameter
      if (openModal) {
          // Wait a bit for page to fully load before opening modal
          setTimeout(() => {
              if (openModal === 'drawing') {
                  if (typeof openDrawingModal === 'function') {
                      openDrawingModal();
                  } else {
                      const drawingModal = document.getElementById('drawingModal');
                      if (drawingModal) {
                          drawingModal.style.display = 'flex';
                          drawingModal.setAttribute('aria-hidden', 'false');
                          if (window.initializeCanvasOnOpen) {
                              window.initializeCanvasOnOpen();
                          }
                      }
                  }
                  // Clean up URL parameter
                  const newUrl = window.location.pathname + (gameSlug ? '?game=' + gameSlug : '');
                  window.history.replaceState({}, '', newUrl);
              } else if (openModal === 'chat') {
                  const chatContainer = document.getElementById('chatContainer');
                  if (chatContainer) {
                      chatContainer.style.display = 'flex';
                      if (typeof initializeChat === 'function') {
                          initializeChat();
                      }
                      setTimeout(() => {
                          const chatMessages = document.getElementById('chatMessages');
                          if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
                      }, 100);
                      // Clean up URL parameter
                      const newUrl = window.location.pathname + (gameSlug ? '?game=' + gameSlug : '');
                      window.history.replaceState({}, '', newUrl);
                  }
              }
          }, 500);
      }
  }
  
  // Handle browser back/forward buttons
  window.addEventListener('popstate', (e) => {
      handleUrlParameters();
  });
  
  // Back to games button
    document.addEventListener('DOMContentLoaded', () => {
        initGamesGrid();
        
        const backToGamesBtn = document.getElementById('backToGamesBtn');
        if (backToGamesBtn) {
            backToGamesBtn.addEventListener('click', () => {
                // Clear URL parameter and go back to games grid
                const newUrl = window.location.pathname;
                window.history.pushState({}, '', newUrl);
                
                const iframeContainer = document.getElementById('iframeContainer');
                const gamesGridContainer = document.getElementById('gamesGridContainer');
                const embeddedSite = document.getElementById('embeddedSite');
                const privacyBtn = document.getElementById('privacyBtn');
                
                // Exit fullscreen if active
                if (document.fullscreenElement) {
                    document.exitFullscreen().catch(() => {});
                }
                
                if (iframeContainer && gamesGridContainer) {
                    // Hide iframe
                    iframeContainer.style.display = 'none';
                    
                    // Show games grid
                    gamesGridContainer.style.display = 'block';
                    if (typeof setBrowserOnlyMode === 'function') setBrowserOnlyMode(false);
                    
                    // Clear iframe src
                    if (embeddedSite) {
                        embeddedSite.src = '';
                    }

                    // Reset Browser button label/state
                    if (privacyBtn) {
                        privacyBtn.innerHTML = '<i class="fas fa-shield-alt"></i> Browser';
                    }
                    
                    // Scroll to games grid
                    setTimeout(() => {
                        gamesGridContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                    
                    // Resume visuals when returning to games grid
                    if (typeof resumeHomeVisuals === 'function') resumeHomeVisuals();
                }
            });
        }
    });
  
  // ================= Back to Top Button =================
  const backToTopBtn = document.getElementById('backToTopBtn');
  
  // Show/hide button based on scroll position
  function handleScroll() {
      if (window.pageYOffset > 300) {
          backToTopBtn?.classList.add('show');
      } else {
          backToTopBtn?.classList.remove('show');
      }
  }
  
  // Scroll to top when button is clicked
  backToTopBtn?.addEventListener('click', () => {
      window.scrollTo({
          top: 0,
          behavior: 'smooth'
      });
  });
  
  // Listen for scroll events
  window.addEventListener('scroll', Utils.throttle(handleScroll, 100));
  
  // Check initial scroll position
  handleScroll();
  
  // Navigation button handlers
  document.addEventListener('DOMContentLoaded', () => {
      // Dropdown click support for all devices (hover works on desktop, click works everywhere)
      console.log('[DEBUG] Initializing dropdowns...');
      const navDropdowns = document.querySelectorAll('.nav-dropdown');
      console.log('[DEBUG] Found', navDropdowns.length, 'dropdowns');
      
      navDropdowns.forEach((dropdown, index) => {
          const dropdownLink = dropdown.querySelector('.nav-link');
          const dropdownContent = dropdown.querySelector('.nav-dropdown-content');
          
          console.log(`[DEBUG] Dropdown ${index}:`, {
              hasLink: !!dropdownLink,
              hasContent: !!dropdownContent,
              classes: dropdown.className,
              href: dropdownLink?.getAttribute('href')
          });
          
          if (dropdownLink) {
              // Add click handler for all devices (works as fallback and for mobile)
              dropdownLink.addEventListener('click', (e) => {
                  // Don't handle if clicking on a child link inside dropdown content
                  if (e.target.closest('.nav-dropdown-content')) {
                      return;
                  }
                  
                  const href = dropdownLink.getAttribute('href');
                  
                  // If the link has a real href (not just '#'), navigate immediately
                  // This allows "All Games" and similar links to work on first click
                  if (href && href !== '#' && !href.startsWith('javascript:')) {
                      // Check if user is clicking directly on the link (not just hovering)
                      // Allow navigation on first click for links with real destinations
                      window.location.href = href;
                      return; // Navigate immediately
                  }
                  
                  // Check if dropdown is already active
                  const wasActive = dropdown.classList.contains('active');
                  
                  // If dropdown is already open, navigate to the link
                  if (wasActive) {
                      if (href && href !== '#') {
                          window.location.href = href;
                          return; // Allow default navigation
                      }
                  }
                  
                  // Otherwise, prevent default and toggle dropdown
                  e.preventDefault();
                  e.stopPropagation();
                  
                  // Close other dropdowns
                  navDropdowns.forEach(other => {
                      if (other !== dropdown) {
                          other.classList.remove('active');
                      }
                  });
                  
                  // Toggle current dropdown
                  dropdown.classList.toggle('active');
                  const isActive = dropdown.classList.contains('active');
                  
                  // Debug: Log dropdown state and positioning
                  if (dropdownContent && isActive) {
                      // Force correct positioning
                      const dropdownRect = dropdown.getBoundingClientRect();
                      dropdownContent.style.left = '0px';
                      dropdownContent.style.right = 'auto';
                      dropdownContent.style.position = 'absolute';
                      
                      const rect = dropdownContent.getBoundingClientRect();
                      const styles = window.getComputedStyle(dropdownContent);
                      console.log('[DEBUG] Dropdown opened - positioning:', {
                          top: rect.top,
                          left: rect.left,
                          width: rect.width,
                          height: rect.height,
                          opacity: styles.opacity,
                          visibility: styles.visibility,
                          zIndex: styles.zIndex,
                          position: styles.position,
                          transform: styles.transform,
                          display: styles.display,
                          parentLeft: dropdownRect.left
                      });
                  }
                  
                  // Close when clicking outside (use mousedown to avoid conflicts with the click that opened it)
                  if (isActive) {
                      // Remove any existing close handlers first
                      if (dropdown._closeHandler) {
                          document.removeEventListener('mousedown', dropdown._closeHandler);
                      }
                      
                      // Add new close handler
                      dropdown._closeHandler = (event) => {
                          // Don't close if clicking inside the dropdown
                          if (!dropdown.contains(event.target)) {
                              console.log('[DEBUG] Clicked outside, closing dropdown');
                              dropdown.classList.remove('active');
                              document.removeEventListener('mousedown', dropdown._closeHandler);
                              dropdown._closeHandler = null;
                          }
                      };
                      
                      // Use mousedown instead of click, and delay to avoid immediate trigger
                      setTimeout(() => {
                          document.addEventListener('mousedown', dropdown._closeHandler);
                      }, 200);
                  } else {
                      // If closing, remove the handler
                      if (dropdown._closeHandler) {
                          document.removeEventListener('mousedown', dropdown._closeHandler);
                          dropdown._closeHandler = null;
                      }
                  }
              });
              
              // Add hover event listeners - manually show dropdown on hover as fallback
              dropdown.addEventListener('mouseenter', () => {
                  console.log(`[DEBUG] Mouse entered dropdown ${index}`);
                  if (dropdownContent) {
                      // Disable transition temporarily to show immediately
                      dropdownContent.style.setProperty('transition', 'none', 'important');
                      
                      // Force correct positioning - absolute relative to parent
                      dropdownContent.style.setProperty('position', 'absolute', 'important');
                      dropdownContent.style.setProperty('left', '0', 'important');
                      dropdownContent.style.setProperty('right', 'auto', 'important');
                      dropdownContent.style.setProperty('top', 'calc(100% + 8px)', 'important');
                      dropdownContent.style.setProperty('margin-left', '0', 'important');
                      dropdownContent.style.setProperty('margin-right', '0', 'important');
                      dropdownContent.style.setProperty('z-index', '10000', 'important');
                      
                      // Manually set styles with !important to override CSS
                      dropdownContent.style.setProperty('opacity', '1', 'important');
                      dropdownContent.style.setProperty('visibility', 'visible', 'important');
                      dropdownContent.style.setProperty('transform', 'translateY(0) scale(1)', 'important');
                      dropdownContent.style.setProperty('pointer-events', 'auto', 'important');
                      dropdownContent.style.setProperty('display', 'block', 'important');
                      
                      // Re-enable transition after a brief moment
                      setTimeout(() => {
                          dropdownContent.style.setProperty('transition', '', 'important');
                      }, 10);
                  }
              });
              
              dropdown.addEventListener('mouseleave', () => {
                  console.log(`[DEBUG] Mouse left dropdown ${index}`);
                  if (dropdownContent && !dropdown.classList.contains('active')) {
                      // Only hide if not active (clicked) - remove inline styles
                      dropdownContent.style.removeProperty('opacity');
                      dropdownContent.style.removeProperty('visibility');
                      dropdownContent.style.removeProperty('transform');
                      dropdownContent.style.removeProperty('pointer-events');
                      dropdownContent.style.removeProperty('display');
                  }
              });
              
              // Keep dropdown visible when hovering over it
              if (dropdownContent) {
                  dropdownContent.addEventListener('mouseenter', () => {
                      dropdownContent.style.setProperty('opacity', '1', 'important');
                      dropdownContent.style.setProperty('visibility', 'visible', 'important');
                      dropdownContent.style.setProperty('position', 'absolute', 'important');
                      dropdownContent.style.setProperty('left', '0', 'important');
                      dropdownContent.style.setProperty('right', 'auto', 'important');
                  });
                  
                  dropdownContent.addEventListener('mouseleave', () => {
                      if (!dropdown.classList.contains('active')) {
                          dropdownContent.style.removeProperty('opacity');
                          dropdownContent.style.removeProperty('visibility');
                      }
                  });
              }
          } else {
              console.warn(`[DEBUG] Dropdown ${index} has no link element!`);
          }
      });
      
      
      // Run debug check after a short delay
      setTimeout(() => {
          console.log('[DEBUG] Running initial debug check...');
          if (window.debugDropdown) {
              window.debugDropdown();
          }
      }, 1000);
      
      // Navigation collapse/expand button
      const navCollapseBtn = document.getElementById('navCollapseBtn');
      const mainNavigation = document.querySelector('.main-navigation');
      if (navCollapseBtn && mainNavigation) {
          // Check if collapsed state is saved in localStorage
          const isCollapsed = localStorage.getItem('navCollapsed') === 'true';
          if (isCollapsed) {
              mainNavigation.classList.add('collapsed');
          }
          
          navCollapseBtn.addEventListener('click', () => {
              mainNavigation.classList.toggle('collapsed');
              const isNowCollapsed = mainNavigation.classList.contains('collapsed');
              
              // Save state to localStorage
              localStorage.setItem('navCollapsed', isNowCollapsed.toString());
              
              // Update aria-label for accessibility
              navCollapseBtn.setAttribute('aria-label', 
                  isNowCollapsed ? 'Expand navigation' : 'Collapse navigation');
          });
      }
      
      // Profile/leaderboard nav buttons temporarily disabled
      // const navProfileBtn = document.getElementById('navProfileBtn');
      // if (navProfileBtn) {
      //     navProfileBtn.addEventListener('click', (e) => {
      //         e.preventDefault();
      //         const profileBtn = document.getElementById('profileBtn');
      //         if (profileBtn) profileBtn.click();
      //     });
      // }
      
      // const navLeaderboardBtn = document.getElementById('navLeaderboardBtn');
      // if (navLeaderboardBtn) {
      //     navLeaderboardBtn.addEventListener('click', (e) => {
      //         e.preventDefault();
      //         const leaderboardBtn = document.getElementById('leaderboardBtn');
      //         if (leaderboardBtn) leaderboardBtn.click();
      //     });
      // }
      
      // Community dropdown buttons
      // Community dropdown buttons - close dropdown after clicking
      function getCommunityDropdown() {
          const navPollsBtn = document.getElementById('navPollsBtn');
          return navPollsBtn ? navPollsBtn.closest('.nav-item.nav-dropdown') : null;
      }
      
      const navForumsBtn = document.getElementById('navForumsBtn');
      if (navForumsBtn) {
          navForumsBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const dropdown = getCommunityDropdown();
              if (dropdown) dropdown.classList.remove('active');
              // Forums functionality - can be implemented later
              alert('Forums feature coming soon!');
          });
      }
      
      const navPollsBtn = document.getElementById('navPollsBtn');
      if (navPollsBtn) {
          navPollsBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const dropdown = getCommunityDropdown();
              if (dropdown) dropdown.classList.remove('active');
              const pollsBtn = document.getElementById('pollsBtn');
              if (pollsBtn) pollsBtn.click();
          });
      }
      
      // const navFriendsBtn = document.getElementById('navFriendsBtn');
      // if (navFriendsBtn) {
      //     navFriendsBtn.addEventListener('click', (e) => {
      //         e.preventDefault();
      //         const friendsBtn = document.getElementById('friendsBtn');
      //         if (friendsBtn) friendsBtn.click();
      //     });
      // }
      
      // Resources dropdown buttons
      const navGuidesBtn = document.getElementById('navGuidesBtn');
      if (navGuidesBtn) {
          navGuidesBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const dropdown = getCommunityDropdown();
              if (dropdown) dropdown.classList.remove('active');
              // Guides functionality - can link to blog or guides page
              window.location.href = 'blog/blog.html';
          });
      }
      
      const navTipsBtn = document.getElementById('navTipsBtn');
      if (navTipsBtn) {
          navTipsBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const dropdown = getCommunityDropdown();
              if (dropdown) dropdown.classList.remove('active');
              // Tips functionality - can link to tips page or blog
              window.location.href = 'blog/blog.html';
          });
      }
      
      const navTutorialsBtn = document.getElementById('navTutorialsBtn');
      if (navTutorialsBtn) {
          navTutorialsBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const dropdown = getCommunityDropdown();
              if (dropdown) dropdown.classList.remove('active');
              // Tutorials functionality - can link to tutorials page or blog
              window.location.href = 'blog/blog-mastering-controls.html';
          });
      }
      
      // Drawing button in navigation
      const navDrawingBtn = document.getElementById('navDrawingBtn');
      if (navDrawingBtn) {
          navDrawingBtn.addEventListener('click', () => {
              const openDrawingBtn = document.getElementById('openDrawingBtn');
              if (openDrawingBtn) openDrawingBtn.click();
          });
      }
      
      // YouTube button in navigation (from Community dropdown)
      const navYouTubeBtn = document.getElementById('navYouTubeBtn');
      if (navYouTubeBtn) {
          navYouTubeBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const dropdown = getCommunityDropdown();
              if (dropdown) dropdown.classList.remove('active');
          openYoutubePrompt(e);
          });
      }
      
      // Footer Legal Pages
      const privacyPolicyBtn = document.getElementById('privacyPolicyBtn');
      const aboutUsBtn = document.getElementById('aboutUsBtn');
      const contactUsBtn = document.getElementById('contactUsBtn');
      const privacyPolicyModal = document.getElementById('privacyPolicyModal');
      const aboutUsModal = document.getElementById('aboutUsModal');
      const contactUsModal = document.getElementById('contactUsModal');
      
      // Open Privacy Policy
      if (privacyPolicyBtn) {
          privacyPolicyBtn.addEventListener('click', () => {
              if (privacyPolicyModal) {
                  privacyPolicyModal.classList.add('active');
                  document.body.style.overflow = 'hidden';
              }
          });
      }
      
      // Open About Us
      if (aboutUsBtn) {
          aboutUsBtn.addEventListener('click', () => {
              if (aboutUsModal) {
                  aboutUsModal.classList.add('active');
                  document.body.style.overflow = 'hidden';
              }
          });
      }
      
      // Open Contact Us
      if (contactUsBtn) {
          contactUsBtn.addEventListener('click', () => {
              if (contactUsModal) {
                  contactUsModal.classList.add('active');
                  document.body.style.overflow = 'hidden';
              }
          });
      }
      
      // Close modals
      const legalModalCloses = document.querySelectorAll('.legal-modal-close');
      legalModalCloses.forEach(closeBtn => {
          closeBtn.addEventListener('click', () => {
              const modal = closeBtn.closest('.legal-modal');
              if (modal) {
                  modal.classList.remove('active');
                  document.body.style.overflow = '';
              }
          });
      });
      
      // Close modals when clicking outside
      [privacyPolicyModal, aboutUsModal, contactUsModal].forEach(modal => {
          if (modal) {
              modal.addEventListener('click', (e) => {
                  if (e.target === modal) {
                      modal.classList.remove('active');
                      document.body.style.overflow = '';
                  }
              });
          }
      });
      
      // Contact form submission (for modal on index.html)
      const contactForm = document.getElementById('contactForm');
      const contactFormSuccess = document.getElementById('contactFormSuccess');
      if (contactForm) {
          contactForm.addEventListener('submit', async (e) => {
              e.preventDefault();
              
              const submitBtn = contactForm.querySelector('button[type="submit"]');
              if (submitBtn) submitBtn.disabled = true;
              
              const subjectEl = document.getElementById('contactSubject');
              const subjectLabel = subjectEl && subjectEl.selectedIndex >= 0
                  ? (subjectEl.options[subjectEl.selectedIndex]?.text || subjectEl.value)
                  : '';
              
              const formData = {
                  name: document.getElementById('contactName').value,
                  email: document.getElementById('contactEmail').value,
                  subject: document.getElementById('contactSubject').value,
                  message: document.getElementById('contactMessage').value,
                  timestamp: Date.now(),
                  date: new Date().toISOString()
              };
              
              // Save to Firebase (best-effort)
              if (db) {
                  try {
                      const messagesRef = db.ref('contactMessages');
                      await messagesRef.push(formData);
                      console.log('Contact message saved to Firebase');
                  } catch (error) {
                      console.warn('Error saving contact message to Firebase (continuing):', error);
                  }
              }

              async function sendContactEmailToGlobalGameHall(data, subjectText) {
                  const endpoint = 'https://formsubmit.co/ajax/globalgamehall@gmail.com';
                  const payload = {
                      name: data.name,
                      email: data.email,
                      subject: subjectText || data.subject || '',
                      message: data.message,
                      _subject: `Nebulo Contact - ${subjectText || data.subject || 'Message'}`,
                      _replyto: data.email
                  };
                  const res = await fetch(endpoint, {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'Accept': 'application/json'
                      },
                      body: JSON.stringify(payload)
                  });
                  if (!res.ok) {
                      const text = await res.text().catch(() => '');
                      throw new Error(`Email send failed (${res.status}) ${text}`);
                  }
                  return true;
              }

              // Send email (primary)
              try {
                  await sendContactEmailToGlobalGameHall(formData, subjectLabel);

                  // Show success message
                  contactForm.style.display = 'none';
                  if (contactFormSuccess) {
                      contactFormSuccess.style.display = 'block';
                  }

                  // Reset form after 5 seconds
                  setTimeout(() => {
                      contactForm.reset();
                      contactForm.style.display = 'block';
                      if (contactFormSuccess) {
                          contactFormSuccess.style.display = 'none';
                      }
                      if (submitBtn) submitBtn.disabled = false;
                  }, 5000);
              } catch (error) {
                  console.error('Error sending contact email:', error);
                  alert('There was an error sending your message. Please try again.');
                  if (submitBtn) submitBtn.disabled = false;
              }
          });
      }
      
      // Links from within modals
      const contactFromPrivacyBtn = document.getElementById('contactFromPrivacyBtn');
      const contactFromAboutBtn = document.getElementById('contactFromAboutBtn');
      
      if (contactFromPrivacyBtn) {
          contactFromPrivacyBtn.addEventListener('click', () => {
              if (privacyPolicyModal) privacyPolicyModal.classList.remove('active');
              if (contactUsModal) {
                  contactUsModal.classList.add('active');
              }
          });
      }
      
      if (contactFromAboutBtn) {
          contactFromAboutBtn.addEventListener('click', () => {
              if (aboutUsModal) aboutUsModal.classList.remove('active');
              if (contactUsModal) {
                  contactUsModal.classList.add('active');
              }
          });
      }
      
      // Footer quick links
      const footerGamesBtn = document.getElementById('footerGamesBtn');
      const footerLeaderboardBtn = document.getElementById('footerLeaderboardBtn');
      const footerChatBtn = document.getElementById('footerChatBtn');
      
      if (footerGamesBtn) {
          footerGamesBtn.addEventListener('click', () => {
              document.getElementById('gamesGridContainer')?.scrollIntoView({ behavior: 'smooth' });
          });
      }
      
      if (footerLeaderboardBtn) {
          footerLeaderboardBtn.addEventListener('click', () => {
              const leaderboardBtn = document.getElementById('leaderboardBtn');
              if (leaderboardBtn) leaderboardBtn.click();
          });
      }
      
      if (footerChatBtn) {
          footerChatBtn.addEventListener('click', () => {
              const toggleChatBtn = document.getElementById('toggleChatBtn');
              if (toggleChatBtn) toggleChatBtn.click();
          });
      }
      
      // Footer scroll behavior - show on scroll down, hide on scroll up
      let lastScrollTop = 0;
      const footer = document.querySelector('.site-footer');
      
      if (footer) {
          const handleFooterScroll = Utils.throttle(() => {
              const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
              
              // Only trigger if scrolled more than 5px difference
              if (Math.abs(scrollTop - lastScrollTop) > 5) {
                  if (scrollTop > lastScrollTop && scrollTop > 100) {
                      // Scrolling down - show footer
                      footer.classList.add('visible');
                  } else if (scrollTop < lastScrollTop) {
                      // Scrolling up - hide footer
                      footer.classList.remove('visible');
                  }
                  
                  lastScrollTop = scrollTop;
              }
              
              // Hide footer if at the very top
              if (scrollTop < 50) {
                  footer.classList.remove('visible');
              }
          }, 100);
          
          window.addEventListener('scroll', handleFooterScroll, { passive: true });
          
          // Check initial position
          handleFooterScroll();
      }
      
      // Category side panel scroll behavior
      function initCategorySidePanel() {
          const categoryPanel = document.getElementById('categorySidePanel');
          const closePanelBtn = document.getElementById('closeCategoryPanel');
          
          if (!categoryPanel) return;
          
          // Sidebar is now permanent - always visible
          categoryPanel.classList.add('open');
          
          // Hide close button since sidebar is permanent
          if (closePanelBtn) {
              closePanelBtn.style.display = 'none';
          }
          
          // Connect side panel buttons to their functionality - works on all pages
          const sidePanelDrawingBtn = document.getElementById('sidePanelDrawingBtn');
          const sidePanelProfileBtn = document.getElementById('sidePanelProfileBtn');
          const sidePanelLeaderboardBtn = document.getElementById('sidePanelLeaderboardBtn');
          const sidePanelFriendsBtn = document.getElementById('sidePanelFriendsBtn');
          const sidePanelYouTubeBtn = document.getElementById('sidePanelYouTubeBtn');
          const sidePanelRandomGameBtn = document.getElementById('sidePanelRandomGameBtn');
          const sidePanelThemeBtn = document.getElementById('sidePanelThemeBtn');
          const sidePanelStatsBtn = document.getElementById('sidePanelStatsBtn');
          const sidePanelAchievementsBtn = document.getElementById('sidePanelAchievementsBtn');
          
          // Remove sidebar YouTube/Random buttons entirely
          if (sidePanelYouTubeBtn && sidePanelYouTubeBtn.parentElement) {
              sidePanelYouTubeBtn.parentElement.removeChild(sidePanelYouTubeBtn);
          }
          if (sidePanelRandomGameBtn && sidePanelRandomGameBtn.parentElement) {
              sidePanelRandomGameBtn.parentElement.removeChild(sidePanelRandomGameBtn);
          }
          
          // Drawing button - call function directly or try to click button
          // Helper function to get homepage path based on current location
          function getHomepagePath() {
              const path = window.location.pathname;
              // Remove leading slash and split by /
              const parts = path.replace(/^\//, '').split('/').filter(p => p);
              
              // If we're at root or in root directory, just return index.html
              if (parts.length === 0 || (parts.length === 1 && parts[0].endsWith('.html'))) {
                  return 'index.html';
              }
              
              // Count how many directories deep we are (excluding the filename)
              const directories = parts.filter(p => !p.endsWith('.html'));
              const depth = directories.length;
              
              // Build relative path: go up depth levels, then to index.html
              if (depth === 0) {
                  return 'index.html';
              }
              return '../'.repeat(depth) + 'index.html';
          }
          
          // Helper function to attach sidebar button handlers
          function attachSidebarButtonHandlers() {
              const sidePanelDrawingBtn = document.getElementById('sidePanelDrawingBtn');
              const sidePanelThemeBtn = document.getElementById('sidePanelThemeBtn');
              const sidePanelLiteToggleBtn = document.getElementById('sidePanelLiteToggleBtn');
              const sidePanelStatsBtn = document.getElementById('sidePanelStatsBtn');
              const sidePanelAchievementsBtn = document.getElementById('sidePanelAchievementsBtn');
              const themeBtn = document.getElementById('themeBtn');
              const statsBtn = document.getElementById('statsBtn');
              const achievementsBtn = document.getElementById('achievementsBtn');
              
              // Lite mode toggle (persist preference and reload to fully apply)
              const updateLiteToggleUI = () => {
                  if (!sidePanelLiteToggleBtn) return;
                  const enabled = document.documentElement.classList.contains('lite-mode');
                  const label = sidePanelLiteToggleBtn.querySelector('.category-panel-label-container');
                  if (label) {
                      label.textContent = `Lite Mode: ${enabled ? 'On' : 'Off'}`;
                  }
                  sidePanelLiteToggleBtn.classList.toggle('active', enabled);
              };
              const setLiteMode = (enabled) => {
                  if (enabled) {
                      document.documentElement.classList.add('lite-mode');
                  } else {
                      document.documentElement.classList.remove('lite-mode');
                  }
                  try {
                      localStorage.setItem('liteModePreference', enabled ? 'on' : 'off');
                  } catch (_) {}
                  updateLiteToggleUI();
                  setTimeout(() => window.location.reload(), 50);
              };
              if (sidePanelLiteToggleBtn && !sidePanelLiteToggleBtn.hasAttribute('data-handler-attached')) {
                  sidePanelLiteToggleBtn.setAttribute('data-handler-attached', 'true');
                  sidePanelLiteToggleBtn.addEventListener('click', (e) => {
                      e.preventDefault();
                      const enabled = document.documentElement.classList.contains('lite-mode');
                      setLiteMode(!enabled);
                  });
                  updateLiteToggleUI();
              }
              
              // Drawing button handler
              if (sidePanelDrawingBtn && !sidePanelDrawingBtn.hasAttribute('data-handler-attached')) {
                  sidePanelDrawingBtn.setAttribute('data-handler-attached', 'true');
                  sidePanelDrawingBtn.addEventListener('click', (e) => {
                      e.preventDefault();
                      if (typeof openDrawingModal === 'function') {
                          openDrawingModal();
                      }
                  });
              }
              
              // Theme toggle
              if (sidePanelThemeBtn && !sidePanelThemeBtn.hasAttribute('data-handler-attached')) {
                  sidePanelThemeBtn.setAttribute('data-handler-attached', 'true');
                  sidePanelThemeBtn.addEventListener('click', (e) => {
                      if (e && typeof e.preventDefault === 'function') e.preventDefault();
                      if (themeBtn) {
                          themeBtn.click();
                      }
                  });
              }

              // Stats modal
              if (sidePanelStatsBtn && !sidePanelStatsBtn.hasAttribute('data-handler-attached')) {
                  sidePanelStatsBtn.setAttribute('data-handler-attached', 'true');
                  sidePanelStatsBtn.addEventListener('click', (e) => {
                      if (e && typeof e.preventDefault === 'function') e.preventDefault();
                      if (statsBtn) {
                          statsBtn.click();
                      }
                  });
              }

              // Achievements modal
              if (sidePanelAchievementsBtn && !sidePanelAchievementsBtn.hasAttribute('data-handler-attached')) {
                  sidePanelAchievementsBtn.setAttribute('data-handler-attached', 'true');
                  sidePanelAchievementsBtn.addEventListener('click', (e) => {
                      if (e && typeof e.preventDefault === 'function') e.preventDefault();
                      if (achievementsBtn) {
                          achievementsBtn.click();
                      }
                  });
              }
          }
          
          // Attach handlers for existing buttons
          attachSidebarButtonHandlers();
          
          // Also check periodically for dynamically injected buttons (for game pages, blog pages)
          const checkInterval = setInterval(() => {
              const drawingBtn = document.getElementById('sidePanelDrawingBtn');
              if (drawingBtn && !drawingBtn.hasAttribute('data-handler-attached')) {
                  attachSidebarButtonHandlers();
              }
          }, 500);
          
          // Stop checking after 10 seconds
          setTimeout(() => clearInterval(checkInterval), 10000);
          
          // Profile/leaderboard/friends sidebar handlers disabled
          // if (sidePanelProfileBtn) {
          //     sidePanelProfileBtn.addEventListener('click', (e) => {
          //         e.preventDefault();
          //         const profileModal = document.getElementById('profileModal');
          //         if (profileModal) {
          //             if (typeof isProfileModalLocked !== 'undefined') {
          //                 isProfileModalLocked = false;
          //             }
          //             const profileModalTitle = document.getElementById('profileModalTitle');
          //             if (profileModalTitle) {
          //                 profileModalTitle.textContent = 'My Profile';
          //             }
          //             const closeProfileBtn = document.getElementById('closeProfileBtn');
          //             if (closeProfileBtn) {
          //                 closeProfileBtn.style.display = 'block';
          //             }
          //             profileModal.style.display = 'flex';
          //             if (typeof updateProfileDisplay === 'function') {
          //                 updateProfileDisplay();
          //             }
          //         } else {
          //             // Fallback: try to click profile button
          //             const profileBtn = document.getElementById('profileBtn') || document.getElementById('navProfileBtn');
          //             if (profileBtn) profileBtn.click();
          //         }
          //     });
          // }
          
          // if (sidePanelLeaderboardBtn) {
          //     sidePanelLeaderboardBtn.addEventListener('click', (e) => {
          //         e.preventDefault();
          //         const leaderboardModal = document.getElementById('leaderboardModal');
          //         if (leaderboardModal) {
          //             if (!requireProfileForOnlineFeature('Leaderboard', () => {
          //                 leaderboardModal.style.display = 'flex';
          //                   if (typeof loadLeaderboardBackend === 'function') {
          //                       loadLeaderboardBackend('active');
          //                   }
          //             })) {
          //                 return;
          //             }
          //             leaderboardModal.style.display = 'flex';
          //           if (typeof loadLeaderboardBackend === 'function') {
          //               loadLeaderboardBackend('active');
          //           }
          //         } else {
          //             // Fallback: try to click leaderboard button
          //             const leaderboardBtn = document.getElementById('leaderboardBtn');
          //             if (leaderboardBtn) leaderboardBtn.click();
          //         }
          //     });
          // }
          
          // if (sidePanelFriendsBtn) {
          //     sidePanelFriendsBtn.addEventListener('click', (e) => {
          //         e.preventDefault();
          //         const friendsModal = document.getElementById('friendsModal');
          //         if (friendsModal) {
          //             if (!requireProfileForOnlineFeature('Friends', () => {
          //                 friendsModal.style.display = 'block';
          //                 friendsModal.style.visibility = 'visible';
          //                 friendsModal.style.opacity = '1';
          //                 if (typeof loadFriendsFromFirebase === 'function') {
          //                     loadFriendsFromFirebase();
          //                 }
          //                 if (typeof renderFriendsTab === 'function') {
          //                     renderFriendsTab();
          //                 }
          //             })) {
          //                 return;
          //             }
          //             friendsModal.style.display = 'block';
          //             friendsModal.style.visibility = 'visible';
          //             friendsModal.style.opacity = '1';
          //             if (typeof loadFriendsFromFirebase === 'function') {
          //                 loadFriendsFromFirebase();
          //             }
          //             if (typeof renderFriendsTab === 'function') {
          //                 renderFriendsTab();
          //             }
          //         } else {
          //             // Fallback: try to click friends button
          //             const friendsBtn = document.getElementById('friendsBtn');
          //             if (friendsBtn) friendsBtn.click();
          //         }
          //     });
          // }
      }
      
      // Inject modals if they don't exist (for pages like recently-played, all-games, etc.)
      function injectModalsIfNeeded() {
          // Check if we're on a page that might not have modals
          const isSubPage = window.location.pathname.includes('/pages/') || 
                           window.location.pathname.includes('/blog/') ||
                           window.location.pathname.includes('/games/');
          
          if (!isSubPage) return; // Main page already has modals
          
          // Inject drawing modal if missing - redirect to homepage instead since it needs full canvas structure
          if (!document.getElementById('drawingModal')) {
              const drawingModalHTML = `
                  <div id="drawingModal" aria-hidden="true" style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); backdrop-filter:blur(10px); z-index:20000; display:none; align-items:center; justify-content:center; padding:20px;">
                      <div class="modalInner" role="dialog" style="width:min(1200px, 96%); max-height:92%; overflow:auto; border-radius:24px; background:rgba(15,15,25,0.95); backdrop-filter:blur(12px); border:1px solid rgba(255,215,0,0.2); box-shadow:0 25px 60px rgba(0,0,0,0.5); padding:30px; position:relative; color:rgba(255,255,255,0.9);">
                          <button class="closeDrawing" id="closeDrawingBtn" style="position:absolute; top:10px; right:10px; border:none; background:#007bff; color:#ffffff; font-size:20px; cursor:pointer; width:30px; height:30px; border-radius:4px;">&times;</button>
                          <div id="sharedCanvasContainer" style="position:relative;">
                              <p style="text-align:center; color:rgba(255,255,255,0.7); padding:40px;">Drawing feature requires full page structure. <a href="../index.html#drawing" style="color:#FFD700;">Go to homepage to use drawing</a></p>
                          </div>
                      </div>
                  </div>
              `;
              document.body.insertAdjacentHTML('beforeend', drawingModalHTML);
          }
          
          // Inject chat container if missing - use full structure
          if (!document.getElementById('chatContainer')) {
              const chatContainerHTML = `
                  <div id="chatContainer" class="chat-container" style="display:none; position:fixed; bottom:20px; right:20px; width:380px; max-height:600px; background:rgba(15,15,25,0.95); backdrop-filter:blur(20px); border-radius:16px; border:1px solid rgba(255,215,0,0.2); z-index:15000; box-shadow:0 10px 40px rgba(0,0,0,0.5); flex-direction:column;">
                      <div class="chat-header" style="display:flex; justify-content:space-between; align-items:center; padding:16px; border-bottom:1px solid rgba(255,215,0,0.1);">
                          <div style="display:flex; align-items:center; gap:12px;">
                              <div style="width:32px; height:32px; border-radius:50%; background:rgba(255,215,0,0.2); display:flex; align-items:center; justify-content:center; color:#FFD700;">
                                  <i class="fas fa-comments"></i>
                              </div>
                              <div>
                                  <h3 class="chat-title" style="margin:0; color:#FFD700; font-size:16px;">Chat</h3>
                                  <span id="typingIndicator" class="typing-indicator" style="font-size:12px; color:rgba(255,255,255,0.6);"></span>
                              </div>
                          </div>
                          <div style="display:flex; gap:8px;">
                              <button id="chatSettingsBtn" class="chat-header-btn" style="border:none; background:transparent; color:#FFD700; cursor:pointer; padding:4px 8px;" title="Settings"><i class="fas fa-cog"></i></button>
                              <button id="expandChatBtn" class="chat-header-btn" style="border:none; background:transparent; color:#FFD700; cursor:pointer; padding:4px 8px;" title="Expand"><i class="fas fa-expand"></i></button>
                              <button id="minimizeChatBtn" class="chat-header-btn" style="border:none; background:transparent; color:#FFD700; cursor:pointer; padding:4px 8px;" title="Minimize"><i class="fas fa-compress"></i></button>
                          </div>
                      </div>
                      <div id="chatMessages" class="chat-messages" style="flex:1; height:400px; overflow-y:auto; padding:16px;"></div>
                      <div class="chat-input-area" style="padding:16px; border-top:1px solid rgba(255,215,0,0.1);">
                          <div class="chat-toolbar" style="display:flex; gap:8px; margin-bottom:8px;">
                              <button id="emojiBtn" class="chat-toolbar-btn" style="border:none; background:rgba(255,215,0,0.1); color:#FFD700; padding:6px 10px; border-radius:6px; cursor:pointer;" title="Emoji"><i class="fas fa-smile"></i></button>
                              <button id="attachLinkBtn" class="chat-toolbar-btn" style="border:none; background:rgba(255,215,0,0.1); color:#FFD700; padding:6px 10px; border-radius:6px; cursor:pointer;" title="Link"><i class="fas fa-link"></i></button>
                              <button id="changeNameBtn" class="chat-toolbar-btn" style="border:none; background:rgba(255,215,0,0.1); color:#FFD700; padding:6px 10px; border-radius:6px; cursor:pointer;" title="Change Name"><i class="fas fa-user-edit"></i></button>
                          </div>
                          <div class="chat-input-wrapper" style="display:flex; gap:8px;">
                              <input type="text" id="chatInput" class="chat-input" placeholder="Type a message..." style="flex:1; padding:10px; border-radius:8px; border:1px solid rgba(255,215,0,0.2); background:rgba(255,255,255,0.05); color:rgba(255,255,255,0.9);">
                              <button id="sendChatBtn" class="chat-send-btn" style="padding:10px 16px; background:rgba(255,215,0,0.2); border:1px solid rgba(255,215,0,0.4); border-radius:8px; color:#FFD700; cursor:pointer;" title="Send"><i class="fas fa-paper-plane"></i></button>
                          </div>
                      </div>
                      <div id="emojiPicker" class="emoji-picker" style="display:none; position:absolute; bottom:100px; left:16px; right:16px; background:rgba(15,15,25,0.98); border:1px solid rgba(255,215,0,0.2); border-radius:12px; padding:12px; max-height:200px; overflow-y:auto;">
                          <div class="emoji-grid" style="display:grid; grid-template-columns:repeat(8, 1fr); gap:8px;">
                              <span class="emoji-option" style="cursor:pointer; padding:8px; text-align:center; border-radius:6px; transition:background 0.2s;">😀</span>
                              <span class="emoji-option" style="cursor:pointer; padding:8px; text-align:center; border-radius:6px; transition:background 0.2s;">😂</span>
                              <span class="emoji-option" style="cursor:pointer; padding:8px; text-align:center; border-radius:6px; transition:background 0.2s;">❤️</span>
                              <span class="emoji-option" style="cursor:pointer; padding:8px; text-align:center; border-radius:6px; transition:background 0.2s;">👍</span>
                              <span class="emoji-option" style="cursor:pointer; padding:8px; text-align:center; border-radius:6px; transition:background 0.2s;">🔥</span>
                              <span class="emoji-option" style="cursor:pointer; padding:8px; text-align:center; border-radius:6px; transition:background 0.2s;">🎉</span>
                          </div>
                      </div>
                  </div>
              `;
              document.body.insertAdjacentHTML('beforeend', chatContainerHTML);
          }

          // Inject profile modal if missing - use FULL structure that matches index.html
          if (!document.getElementById('profileModal')) {
              const profileModalHTML = `
                  <div id="profileModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); backdrop-filter:blur(10px); z-index:16000; align-items:center; justify-content:center;">
                      <div style="width:min(600px, 95%); max-height:80%; overflow-y:auto; background:rgba(15,15,25,0.95); backdrop-filter:blur(30px); border-radius:24px; padding:30px; box-shadow:0 25px 60px rgba(0,0,0,0.5); border:1px solid rgba(255,215,0,0.2); color:rgba(255,255,255,0.9);">
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px; padding-bottom:16px; border-bottom:1px solid rgba(255,215,0,0.1);">
                              <h2 style="margin:0; color:#FFD700; font-weight:600; font-size:20px;"><i class="fas fa-user-circle"></i> <span id="profileModalTitle">My Profile</span></h2>
                              <button id="closeProfileBtn" style="border:none; background:rgba(255,215,0,0.1); color:#FFD700; font-size:20px; cursor:pointer; width:38px; height:38px; border-radius:12px; transition:all 0.3s ease; border:1px solid rgba(255,215,0,0.2);">&times;</button>
                          </div>
                          <div style="text-align:center; margin-bottom:20px;">
                              <div id="profileAvatarContainer" style="position:relative; display:inline-block; margin-bottom:15px;">
                                  <div id="profileAvatar" style="width:120px; height:120px; border-radius:50%; background:linear-gradient(135deg, #FFD700, #FFA500); margin:0 auto; display:flex; align-items:center; justify-content:center; font-size:48px; cursor:pointer; border:3px solid rgba(255,215,0,0.5); background-size:cover; background-position:center; background-repeat:no-repeat; position:relative;" title="Click to upload profile picture">
                                      <span id="profileAvatarEmoji" style="display:block;">👤</span>
                                      <button id="removePfpBtn" style="display:none; position:absolute; top:-5px; right:-5px; width:28px; height:28px; border-radius:50%; background:rgba(255,0,0,0.8); border:2px solid rgba(255,255,255,0.9); color:white; cursor:pointer; font-size:14px; font-weight:bold; z-index:10;">&times;</button>
                                  </div>
                                  <input type="file" id="profilePictureInput" accept="image/*" style="display:none;">
                                  <div style="display:flex; gap:8px; justify-content:center; margin-top:10px;">
                                      <button id="uploadPfpBtn" style="padding:8px 16px; background:rgba(255,215,0,0.1); border:1px solid rgba(255,215,0,0.3); border-radius:8px; color:#FFD700; cursor:pointer; font-size:12px;"><i class="fas fa-camera"></i> Upload Photo</button>
                                  </div>
                              </div>
                              <input type="text" id="profileUsername" placeholder="Enter your username..." style="width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,215,0,0.2); background:rgba(255,255,255,0.05); color:rgba(255,255,255,0.9); margin-bottom:10px; font-size:16px; font-weight:500;" required>
                              <input type="text" id="profileStatus" placeholder="Set your status message (optional)..." style="width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,215,0,0.2); background:rgba(255,255,255,0.05); color:rgba(255,255,255,0.9); margin-bottom:10px;">
                              <div class="profile-customization-panel" style="margin:15px 0 20px 0; padding:18px; border-radius:16px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,215,0,0.08); text-align:left;">
                                  <div class="profile-customization-heading" style="margin-bottom:14px;">
                                      <h3 style="margin:0; font-size:16px; color:#FFD700;">Make it yours <span style="font-size:12px; color:rgba(255,255,255,0.6); font-weight:400;">(everything below is optional)</span></h3>
                                      <p style="margin:6px 0 0 0; font-size:13px; color:rgba(255,255,255,0.65);">Add extra details so friends know a little more about you.</p>
                                  </div>
                                  <div class="profile-custom-grid" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(180px, 1fr)); gap:12px;">
                                      <div class="profile-custom-field" style="display:flex; flex-direction:column; gap:6px;">
                                          <label for="profilePronouns" style="font-size:12px; text-transform:uppercase; letter-spacing:0.08em; color:rgba(255,255,255,0.6);">Pronouns</label>
                                          <input type="text" id="profilePronouns" placeholder="they/them" maxlength="40" style="padding:9px; border-radius:8px; border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.9); font-size:14px;">
                                      </div>
                                      <div class="profile-custom-field" style="display:flex; flex-direction:column; gap:6px;">
                                          <label for="profileLocation" style="font-size:12px; text-transform:uppercase; letter-spacing:0.08em; color:rgba(255,255,255,0.6);">Location</label>
                                          <input type="text" id="profileLocation" placeholder="City, Country" maxlength="80" style="padding:9px; border-radius:8px; border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.9); font-size:14px;">
                                      </div>
                                      <div class="profile-custom-field" style="display:flex; flex-direction:column; gap:6px;">
                                          <label for="profileFavoriteColor" style="font-size:12px; text-transform:uppercase; letter-spacing:0.08em; color:rgba(255,255,255,0.6);">Favorite Color</label>
                                          <div style="display:flex; align-items:center; gap:10px; padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.02);">
                                              <input type="color" id="profileFavoriteColor" value="#FFD700" style="width:42px; height:32px; border:none; background:transparent; cursor:pointer;">
                                              <span id="profileFavoriteColorValue" style="font-size:13px; color:rgba(255,255,255,0.85); letter-spacing:0.05em;">#FFD700</span>
                                          </div>
                                      </div>
                                  </div>
                                  <div class="profile-custom-field" style="margin-top:14px; display:flex; flex-direction:column; gap:6px;">
                                      <label for="profileBio" style="font-size:12px; text-transform:uppercase; letter-spacing:0.08em; color:rgba(255,255,255,0.6);">Mini Bio</label>
                                      <textarea id="profileBio" rows="3" maxlength="200" placeholder="Share a sentence or two about yourself..." style="padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.9); font-size:14px; resize:vertical;"></textarea>
                                      <div id="profileBioCounter" style="text-align:right; font-size:12px; color:rgba(255,255,255,0.5);">0 / 200</div>
                                  </div>
                                  <div class="profile-custom-field" style="margin-top:12px;">
                                      <label style="font-size:12px; text-transform:uppercase; letter-spacing:0.08em; color:rgba(255,255,255,0.6); display:block; margin-bottom:8px;">Interests</label>
                                      <div class="profile-interests-grid" style="display:flex; flex-wrap:wrap; gap:10px;">
                                          <label class="profile-interest-chip" style="padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.85); font-size:13px; display:flex; align-items:center; gap:6px; cursor:pointer;">
                                              <input type="checkbox" class="profile-interest-input" value="gaming" style="accent-color:#FFD700;">
                                              <span>Gaming</span>
                                          </label>
                                          <label class="profile-interest-chip" style="padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.85); font-size:13px; display:flex; align-items:center; gap:6px; cursor:pointer;">
                                              <input type="checkbox" class="profile-interest-input" value="music" style="accent-color:#FFD700;">
                                              <span>Music</span>
                                          </label>
                                          <label class="profile-interest-chip" style="padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.85); font-size:13px; display:flex; align-items:center; gap:6px; cursor:pointer;">
                                              <input type="checkbox" class="profile-interest-input" value="art" style="accent-color:#FFD700;">
                                              <span>Art & Design</span>
                                          </label>
                                          <label class="profile-interest-chip" style="padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.85); font-size:13px; display:flex; align-items:center; gap:6px; cursor:pointer;">
                                              <input type="checkbox" class="profile-interest-input" value="tech" style="accent-color:#FFD700;">
                                              <span>Tech & Coding</span>
                                          </label>
                                          <label class="profile-interest-chip" style="padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.85); font-size:13px; display:flex; align-items:center; gap:6px; cursor:pointer;">
                                              <input type="checkbox" class="profile-interest-input" value="sports" style="accent-color:#FFD700;">
                                              <span>Sports</span>
                                          </label>
                                          <label class="profile-interest-chip" style="padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.03); color:rgba(255,255,255,0.85); font-size:13px; display:flex; align-items:center; gap:6px; cursor:pointer;">
                                              <input type="checkbox" class="profile-interest-input" value="travel" style="accent-color:#FFD700;">
                                              <span>Travel</span>
                                          </label>
                                      </div>
                                  </div>
                              </div>
                              <button id="saveProfileBtn" style="width:100%; padding:12px; background:rgba(255,215,0,0.2); border:1px solid rgba(255,215,0,0.4); border-radius:8px; color:#FFD700; cursor:pointer; font-weight:500; margin-bottom:15px;"><i class="fas fa-save"></i> Save Profile</button>
                          </div>
                          <div id="activityHistory" style="margin-top:20px; text-align:left;">
                              <h3 style="color:#FFD700; margin-bottom:15px;">Activity History</h3>
                              <div id="activityList" style="max-height:200px; overflow-y:auto;"></div>
                          </div>
                          <div style="margin-top:30px; padding-top:20px; border-top:1px solid rgba(255,215,0,0.1);">
                              <button id="deleteAccountBtn" style="width:100%; padding:12px; background:rgba(220,53,69,0.2); border:2px solid rgba(220,53,69,0.5); border-radius:8px; color:#dc3545; cursor:pointer; font-weight:600; transition:all 0.3s ease;"><i class="fas fa-trash-alt"></i> Delete Account</button>
                          </div>
                      </div>
                  </div>
              `;
              document.body.insertAdjacentHTML('beforeend', profileModalHTML);
          }
          
          // Inject leaderboard modal if missing
          if (!document.getElementById('leaderboardModal')) {
              const leaderboardModalHTML = `
                  <div id="leaderboardModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); backdrop-filter:blur(10px); z-index:16000; align-items:center; justify-content:center;">
                      <div style="width:min(800px, 95%); max-height:80%; overflow-y:auto; background:rgba(15,15,25,0.95); backdrop-filter:blur(30px); border-radius:24px; padding:30px; box-shadow:0 25px 60px rgba(0,0,0,0.5); border:1px solid rgba(255,215,0,0.2); color:rgba(255,255,255,0.9);">
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px; padding-bottom:16px; border-bottom:1px solid rgba(255,215,0,0.1);">
                              <h2 style="margin:0; color:#FFD700; font-weight:600; font-size:20px;"><i class="fas fa-medal"></i> Leaderboard</h2>
                              <button id="closeLeaderboardBtn" style="border:none; background:rgba(255,215,0,0.1); color:#FFD700; font-size:20px; cursor:pointer; width:38px; height:38px; border-radius:12px; transition:all 0.3s ease; border:1px solid rgba(255,215,0,0.2);">&times;</button>
                          </div>
                          <div style="display:flex; gap:10px; margin-bottom:20px;">
                              <button class="leaderboardTab" data-tab="active" style="flex:1; padding:10px; background:rgba(255,215,0,0.1); border:1px solid rgba(255,215,0,0.3); border-radius:8px; color:#FFD700; cursor:pointer;">Most Active</button>
                              <button class="leaderboardTab" data-tab="achievements" style="flex:1; padding:10px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,215,0,0.2); border-radius:8px; color:rgba(255,255,255,0.7); cursor:pointer;">Achievements</button>
                              <button class="leaderboardTab" data-tab="stats" style="flex:1; padding:10px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,215,0,0.2); border-radius:8px; color:rgba(255,255,255,0.7); cursor:pointer;">Daily/Weekly</button>
                          </div>
                          <div id="leaderboardContent"></div>
                      </div>
                  </div>
              `;
              document.body.insertAdjacentHTML('beforeend', leaderboardModalHTML);
          }
          
          // Inject friends modal if missing - use basic structure
          if (!document.getElementById('friendsModal')) {
              const friendsModalHTML = `
                  <div id="friendsModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.96); backdrop-filter:blur(20px); z-index:16000; overflow-y:auto;">
                      <div class="friends-container" style="max-width:1200px; margin:0 auto; padding:20px;">
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px; padding:20px; background:rgba(255,215,0,0.05); border-radius:16px; border:1px solid rgba(255,215,0,0.1);">
                              <div style="display:flex; align-items:center; gap:16px;">
                                  <div style="width:48px; height:48px; border-radius:50%; background:rgba(255,215,0,0.2); display:flex; align-items:center; justify-content:center; color:#FFD700; font-size:24px;">
                                      <i class="fas fa-user-friends"></i>
                                  </div>
                                  <div>
                                      <h1 style="margin:0; color:#FFD700; font-size:24px;">Friends</h1>
                                      <p style="margin:4px 0 0 0; color:rgba(255,255,255,0.6); font-size:14px;">Connect, chat, and stay in touch</p>
                                  </div>
                              </div>
                              <button id="closeFriendsBtn" style="border:none; background:rgba(255,215,0,0.1); color:#FFD700; font-size:24px; cursor:pointer; width:40px; height:40px; border-radius:12px; transition:all 0.3s ease; border:1px solid rgba(255,215,0,0.2);">&times;</button>
                          </div>
                          <div class="friends-tabs-container" style="display:flex; gap:8px; margin-bottom:24px; border-bottom:1px solid rgba(255,215,0,0.1);">
                              <button class="friends-tab-btn active" data-tab="friends" style="padding:12px 20px; background:rgba(255,215,0,0.1); border:none; border-bottom:2px solid #FFD700; color:#FFD700; cursor:pointer; font-weight:500;">
                                  <i class="fas fa-users"></i> <span>My Friends</span> <span class="friends-badge" id="friendsCountBadge" style="margin-left:8px; padding:2px 6px; background:rgba(255,215,0,0.2); border-radius:10px; font-size:12px;">0</span>
                              </button>
                              <button class="friends-tab-btn" data-tab="requests" style="padding:12px 20px; background:transparent; border:none; color:rgba(255,255,255,0.7); cursor:pointer;">
                                  <i class="fas fa-user-plus"></i> <span>Requests</span>
                              </button>
                              <button class="friends-tab-btn" data-tab="search" style="padding:12px 20px; background:transparent; border:none; color:rgba(255,255,255,0.7); cursor:pointer;">
                                  <i class="fas fa-search"></i> <span>Find Friends</span>
                              </button>
                          </div>
                          <div class="friends-content-wrapper" id="friendsContent" style="min-height:400px;">
                              <p style="text-align:center; color:rgba(255,255,255,0.6); padding:40px;">Loading friends...</p>
                          </div>
                      </div>
                  </div>
              `;
              document.body.insertAdjacentHTML('beforeend', friendsModalHTML);
          }
          
          // Attach close button handlers for injected modals
          const closeDrawingBtn = document.getElementById('closeDrawingBtn');
          if (closeDrawingBtn && !closeDrawingBtn.hasAttribute('data-handler-attached')) {
              closeDrawingBtn.setAttribute('data-handler-attached', 'true');
              closeDrawingBtn.addEventListener('click', () => {
                  const drawingModal = document.getElementById('drawingModal');
                  if (drawingModal) {
                      drawingModal.style.display = 'none';
                      drawingModal.setAttribute('aria-hidden', 'true');
                  }
              });
          }
          
          const closeProfileBtn = document.getElementById('closeProfileBtn');
          if (closeProfileBtn && !closeProfileBtn.hasAttribute('data-handler-attached')) {
              closeProfileBtn.setAttribute('data-handler-attached', 'true');
              closeProfileBtn.addEventListener('click', () => {
                  const profileModal = document.getElementById('profileModal');
                  if (profileModal) {
                      profileModal.style.display = 'none';
                  }
              });
          }
          
          const closeLeaderboardBtn = document.getElementById('closeLeaderboardBtn');
          if (closeLeaderboardBtn && !closeLeaderboardBtn.hasAttribute('data-handler-attached')) {
              closeLeaderboardBtn.setAttribute('data-handler-attached', 'true');
              closeLeaderboardBtn.addEventListener('click', () => {
                  const leaderboardModal = document.getElementById('leaderboardModal');
                  if (leaderboardModal) {
                      leaderboardModal.style.display = 'none';
                  }
              });
          }
          
          const closeFriendsBtn = document.getElementById('closeFriendsBtn');
          if (closeFriendsBtn && !closeFriendsBtn.hasAttribute('data-handler-attached')) {
              closeFriendsBtn.setAttribute('data-handler-attached', 'true');
              closeFriendsBtn.addEventListener('click', () => {
                  const friendsModal = document.getElementById('friendsModal');
                  if (friendsModal) {
                      friendsModal.style.display = 'none';
                  }
              });
          }
          
          const minimizeChatBtn = document.getElementById('minimizeChatBtn');
          if (minimizeChatBtn && !minimizeChatBtn.hasAttribute('data-handler-attached')) {
              minimizeChatBtn.setAttribute('data-handler-attached', 'true');
              minimizeChatBtn.addEventListener('click', () => {
                  const chatContainer = document.getElementById('chatContainer');
                  if (chatContainer) {
                      chatContainer.style.display = 'none';
                  }
              });
          }
          
          // Attach click-outside-to-close handlers
          const profileModal = document.getElementById('profileModal');
          if (profileModal && !profileModal.hasAttribute('data-handler-attached')) {
              profileModal.setAttribute('data-handler-attached', 'true');
              profileModal.addEventListener('click', (e) => {
                  if (e.target === profileModal) {
                      profileModal.style.display = 'none';
                  }
              });
          }
          
          const leaderboardModal = document.getElementById('leaderboardModal');
          if (leaderboardModal && !leaderboardModal.hasAttribute('data-handler-attached')) {
              leaderboardModal.setAttribute('data-handler-attached', 'true');
              leaderboardModal.addEventListener('click', (e) => {
                  if (e.target === leaderboardModal) {
                      leaderboardModal.style.display = 'none';
                  }
              });
          }
          
          const friendsModal = document.getElementById('friendsModal');
          if (friendsModal && !friendsModal.hasAttribute('data-handler-attached')) {
              friendsModal.setAttribute('data-handler-attached', 'true');
              friendsModal.addEventListener('click', (e) => {
                  if (e.target === friendsModal) {
                      friendsModal.style.display = 'none';
                  }
              });
          }
      }
      
      // Initialize category side panel when DOM is ready
      if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
              injectModalsIfNeeded();
              initCategorySidePanel();
          });
      } else {
          injectModalsIfNeeded();
          initCategorySidePanel();
      }
      
      // ================= Drag and Drop for Admin Game Reordering =================
      function initDragAndDrop(container, gamesList) {
          if (!container) return;
          
          let draggedElement = null;
          let draggedIndex = null;
          
          container.querySelectorAll('.big-game-cube.admin-draggable').forEach((cube, index) => {
              cube.addEventListener('dragstart', (e) => {
                  draggedElement = cube;
                  draggedIndex = index;
                  cube.classList.add('dragging');
                  e.dataTransfer.effectAllowed = 'move';
                  e.dataTransfer.setData('text/html', cube.outerHTML);
                  e.dataTransfer.setData('text/plain', index.toString());
              });
              
              cube.addEventListener('dragend', (e) => {
                  cube.classList.remove('dragging');
                  container.querySelectorAll('.big-game-cube').forEach(c => {
                      c.classList.remove('drag-over');
                  });
              });
              
              cube.addEventListener('dragover', (e) => {
                  e.preventDefault();
                  e.dataTransfer.dropEffect = 'move';
                  
                  const afterElement = getDragAfterElement(container, e.clientX, e.clientY);
                  const cubes = Array.from(container.querySelectorAll('.big-game-cube:not(.dragging)'));
                  
                  cubes.forEach(c => c.classList.remove('drag-over'));
                  
                  if (afterElement == null) {
                      cubes[cubes.length - 1]?.classList.add('drag-over');
                  } else {
                      const index = cubes.indexOf(afterElement);
                      if (index > 0) {
                          cubes[index - 1]?.classList.add('drag-over');
                      } else {
                          cubes[0]?.classList.add('drag-over');
                      }
                  }
              });
              
              cube.addEventListener('drop', (e) => {
                  e.preventDefault();
                  
                  if (!draggedElement || draggedElement === cube) return;
                  
                  const cubes = Array.from(container.querySelectorAll('.big-game-cube'));
                  const draggedIndex = cubes.indexOf(draggedElement);
                  const dropIndex = cubes.indexOf(cube);
                  
                  if (draggedIndex < dropIndex) {
                      container.insertBefore(draggedElement, cube.nextSibling);
                  } else {
                      container.insertBefore(draggedElement, cube);
                  }
                  
                  // Save new order to localStorage
                  saveGameOrder(container, gamesList);
                  
                  // Remove drag-over classes
                  cubes.forEach(c => c.classList.remove('drag-over'));
              });
          });
      }
      
      function getDragAfterElement(container, x, y) {
          const draggableElements = [...container.querySelectorAll('.big-game-cube:not(.dragging)')];
          
          return draggableElements.reduce((closest, child) => {
              const box = child.getBoundingClientRect();
              const offsetY = y - box.top - box.height / 2;
              
              if (offsetY < 0 && offsetY > closest.offset) {
                  return { offset: offsetY, element: child };
              } else {
                  return closest;
              }
          }, { offset: Number.NEGATIVE_INFINITY }).element;
      }
      
      function saveGameOrder(container, gamesList) {
          const cubes = Array.from(container.querySelectorAll('.big-game-cube'));
          const order = cubes.map(cube => cube.getAttribute('data-game-key')).filter(Boolean);
          
          // Also save the full order including all games (not just visible ones)
          const allGamesOrder = localStorage.getItem('adminGameOrder');
          let fullOrder = [];
          
          if (allGamesOrder) {
              try {
                  fullOrder = JSON.parse(allGamesOrder);
              } catch (e) {
                  console.error('Error parsing saved order:', e);
              }
          }
          
          // Update the order for visible games
          const gamesMap = new Map(gamesList.map(game => [getGameKey(game.embed), game]));
          const existingKeys = new Set(fullOrder);
          
          // Remove keys that are in the new order
          fullOrder = fullOrder.filter(key => !order.includes(key));
          
          // Insert new order at the beginning
          fullOrder = [...order, ...fullOrder];
          
          localStorage.setItem('adminGameOrder', JSON.stringify(fullOrder));
          console.log('Game order saved:', fullOrder.length, 'games');
      }
      
      // ================= Cookie Consent System =================
      const cookieConsent = document.getElementById('cookieConsent');
      const cookieSettingsModal = document.getElementById('cookieSettingsModal');
      const cookieAcceptBtn = document.getElementById('cookieAcceptBtn');
      const cookieRejectBtn = document.getElementById('cookieRejectBtn');
      const cookieSettingsBtn = document.getElementById('cookieSettingsBtn');
      const closeCookieSettingsBtn = document.getElementById('closeCookieSettingsBtn');
      const cookieSaveSettingsBtn = document.getElementById('cookieSaveSettingsBtn');
      const cookieAcceptAllModalBtn = document.getElementById('cookieAcceptAllModalBtn');
      const essentialCookies = document.getElementById('essentialCookies');
      const analyticsCookies = document.getElementById('analyticsCookies');
      const advertisingCookies = document.getElementById('advertisingCookies');
      const functionalCookies = document.getElementById('functionalCookies');
      
      // Check if user has already made a cookie choice
      const cookieConsentGiven = localStorage.getItem('cookieConsent');
      
      // Show cookie consent banner if consent hasn't been given
      if (!cookieConsentGiven && cookieConsent) {
          cookieConsent.style.display = 'block';
      }
      
      // Accept all cookies
      if (cookieAcceptBtn) {
          cookieAcceptBtn.addEventListener('click', () => {
              localStorage.setItem('cookieConsent', 'accepted');
              localStorage.setItem('essentialCookies', 'true');
              localStorage.setItem('analyticsCookies', 'true');
              localStorage.setItem('advertisingCookies', 'true');
              localStorage.setItem('functionalCookies', 'true');
              if (cookieConsent) cookieConsent.style.display = 'none';
          });
      }
      
      // Reject all cookies (only essential)
      if (cookieRejectBtn) {
          cookieRejectBtn.addEventListener('click', () => {
              localStorage.setItem('cookieConsent', 'rejected');
              localStorage.setItem('essentialCookies', 'true');
              localStorage.setItem('analyticsCookies', 'false');
              localStorage.setItem('advertisingCookies', 'false');
              localStorage.setItem('functionalCookies', 'false');
              if (cookieConsent) cookieConsent.style.display = 'none';
          });
      }
      
      // Open cookie settings modal
      if (cookieSettingsBtn) {
          cookieSettingsBtn.addEventListener('click', () => {
              if (cookieConsent) cookieConsent.style.display = 'none';
              if (cookieSettingsModal) {
                  cookieSettingsModal.style.display = 'flex';
                  document.body.style.overflow = 'hidden';
                  
                  // Load current preferences
                  if (analyticsCookies) {
                      analyticsCookies.checked = localStorage.getItem('analyticsCookies') !== 'false';
                  }
                  if (advertisingCookies) {
                      advertisingCookies.checked = localStorage.getItem('advertisingCookies') !== 'false';
                  }
                  if (functionalCookies) {
                      functionalCookies.checked = localStorage.getItem('functionalCookies') !== 'false';
                  }
              }
          });
      }
      
      // Close cookie settings modal
      if (closeCookieSettingsBtn) {
          closeCookieSettingsBtn.addEventListener('click', () => {
              if (cookieSettingsModal) {
                  cookieSettingsModal.style.display = 'none';
                  document.body.style.overflow = '';
              }
          });
      }
      
      // Close modal when clicking outside
      if (cookieSettingsModal) {
          cookieSettingsModal.addEventListener('click', (e) => {
              if (e.target === cookieSettingsModal) {
                  cookieSettingsModal.style.display = 'none';
                  document.body.style.overflow = '';
              }
          });
      }
      
      // Save cookie preferences
      if (cookieSaveSettingsBtn) {
          cookieSaveSettingsBtn.addEventListener('click', () => {
              localStorage.setItem('cookieConsent', 'custom');
              localStorage.setItem('essentialCookies', 'true');
              localStorage.setItem('analyticsCookies', analyticsCookies?.checked ? 'true' : 'false');
              localStorage.setItem('advertisingCookies', advertisingCookies?.checked ? 'true' : 'false');
              localStorage.setItem('functionalCookies', functionalCookies?.checked ? 'true' : 'false');
              
              if (cookieSettingsModal) {
                  cookieSettingsModal.style.display = 'none';
                  document.body.style.overflow = '';
              }
              if (cookieConsent) cookieConsent.style.display = 'none';
              
              // Show success feedback
              const originalText = cookieSaveSettingsBtn.innerHTML;
              cookieSaveSettingsBtn.innerHTML = '<i class="fas fa-check"></i> Saved!';
              setTimeout(() => {
                  cookieSaveSettingsBtn.innerHTML = originalText;
              }, 2000);
          });
      }
      
      // Accept all from modal
      if (cookieAcceptAllModalBtn) {
          cookieAcceptAllModalBtn.addEventListener('click', () => {
              localStorage.setItem('cookieConsent', 'accepted');
              localStorage.setItem('essentialCookies', 'true');
              localStorage.setItem('analyticsCookies', 'true');
              localStorage.setItem('advertisingCookies', 'true');
              localStorage.setItem('functionalCookies', 'true');
              
              if (analyticsCookies) analyticsCookies.checked = true;
              if (advertisingCookies) advertisingCookies.checked = true;
              if (functionalCookies) functionalCookies.checked = true;
              
              if (cookieSettingsModal) {
                  cookieSettingsModal.style.display = 'none';
                  document.body.style.overflow = '';
              }
              if (cookieConsent) cookieConsent.style.display = 'none';
          });
      }
  });
  
  

